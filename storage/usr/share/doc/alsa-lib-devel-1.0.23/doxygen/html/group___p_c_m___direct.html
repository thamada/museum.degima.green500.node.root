<!-- This comment will put IE 6, 7 and 8 in quirks mode -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>ALSA project - the C library reference: Direct Access (MMAP) Functions</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.6.1 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <img id="MSearchSelect" src="search/search.png"
             onmouseover="return searchBox.OnSearchSelectShow()"
             onmouseout="return searchBox.OnSearchSelectHide()"
             alt=""/>
        <input type="text" id="MSearchField" value="Search" accesskey="S"
             onfocus="searchBox.OnSearchFieldFocus(true)" 
             onblur="searchBox.OnSearchFieldFocus(false)" 
             onkeyup="searchBox.OnSearchFieldChange(event)"/>
        <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
        </div>
      </li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>Direct Access (MMAP) Functions<br/>
<small>
[<a class="el" href="group___p_c_m.html">PCM Interface</a>]</small>
</h1><table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___p_c_m___direct.html#ga6d4acf42de554d4d1177fb035d484ea4">snd_pcm_mmap_begin</a> (<a class="el" href="group___p_c_m.html#ga919e634deecd855b6e2e15174e70d3ea">snd_pcm_t</a> *pcm, const <a class="el" href="structsnd__pcm__channel__area__t.html">snd_pcm_channel_area_t</a> **areas, <a class="el" href="group___p_c_m.html#gab01fcfe9b97382a8d3f2027c664b8b8a">snd_pcm_uframes_t</a> *offset, <a class="el" href="group___p_c_m.html#gab01fcfe9b97382a8d3f2027c664b8b8a">snd_pcm_uframes_t</a> *frames)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Application request to access a portion of direct (mmap) area.  <a href="#ga6d4acf42de554d4d1177fb035d484ea4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___p_c_m.html#ga71cdfa37e258d2210b8bd0216bf0c36c">snd_pcm_sframes_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___p_c_m___direct.html#gac306bd13c305825aa39dd9180a3ad520">snd_pcm_mmap_commit</a> (<a class="el" href="group___p_c_m.html#ga919e634deecd855b6e2e15174e70d3ea">snd_pcm_t</a> *pcm, <a class="el" href="group___p_c_m.html#gab01fcfe9b97382a8d3f2027c664b8b8a">snd_pcm_uframes_t</a> offset, <a class="el" href="group___p_c_m.html#gab01fcfe9b97382a8d3f2027c664b8b8a">snd_pcm_uframes_t</a> frames)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Application has completed the access to area requested with <a class="el" href="group___p_c_m___direct.html#ga6d4acf42de554d4d1177fb035d484ea4" title="Application request to access a portion of direct (mmap) area.">snd_pcm_mmap_begin</a>.  <a href="#gac306bd13c305825aa39dd9180a3ad520"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___p_c_m.html#ga71cdfa37e258d2210b8bd0216bf0c36c">snd_pcm_sframes_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___p_c_m___direct.html#ga5a9ee8e1e764b12da6d54dfa195f7c52">snd_pcm_mmap_writei</a> (<a class="el" href="group___p_c_m.html#ga919e634deecd855b6e2e15174e70d3ea">snd_pcm_t</a> *pcm, const void *buffer, <a class="el" href="group___p_c_m.html#gab01fcfe9b97382a8d3f2027c664b8b8a">snd_pcm_uframes_t</a> size)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Write interleaved frames to a PCM using direct buffer (mmap).  <a href="#ga5a9ee8e1e764b12da6d54dfa195f7c52"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___p_c_m.html#ga71cdfa37e258d2210b8bd0216bf0c36c">snd_pcm_sframes_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___p_c_m___direct.html#ga24b6c538c8d7ddd0776ee65f8fb909eb">snd_pcm_mmap_readi</a> (<a class="el" href="group___p_c_m.html#ga919e634deecd855b6e2e15174e70d3ea">snd_pcm_t</a> *pcm, void *buffer, <a class="el" href="group___p_c_m.html#gab01fcfe9b97382a8d3f2027c664b8b8a">snd_pcm_uframes_t</a> size)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read interleaved frames from a PCM using direct buffer (mmap).  <a href="#ga24b6c538c8d7ddd0776ee65f8fb909eb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___p_c_m.html#ga71cdfa37e258d2210b8bd0216bf0c36c">snd_pcm_sframes_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___p_c_m___direct.html#ga092b1a7f387e9fc2977649bfd43b0958">snd_pcm_mmap_writen</a> (<a class="el" href="group___p_c_m.html#ga919e634deecd855b6e2e15174e70d3ea">snd_pcm_t</a> *pcm, void **bufs, <a class="el" href="group___p_c_m.html#gab01fcfe9b97382a8d3f2027c664b8b8a">snd_pcm_uframes_t</a> size)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Write non interleaved frames to a PCM using direct buffer (mmap).  <a href="#ga092b1a7f387e9fc2977649bfd43b0958"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___p_c_m.html#ga71cdfa37e258d2210b8bd0216bf0c36c">snd_pcm_sframes_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___p_c_m___direct.html#ga29ce9af60eafb67f0303418a176bf3ea">snd_pcm_mmap_readn</a> (<a class="el" href="group___p_c_m.html#ga919e634deecd855b6e2e15174e70d3ea">snd_pcm_t</a> *pcm, void **bufs, <a class="el" href="group___p_c_m.html#gab01fcfe9b97382a8d3f2027c664b8b8a">snd_pcm_uframes_t</a> size)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read non interleaved frames to a PCM using direct buffer (mmap).  <a href="#ga29ce9af60eafb67f0303418a176bf3ea"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>See the <a class="el" href="pcm.html">PCM (digital audio) interface</a> page for more details. </p>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ga6d4acf42de554d4d1177fb035d484ea4"></a><!-- doxytag: member="pcm.h::snd_pcm_mmap_begin" ref="ga6d4acf42de554d4d1177fb035d484ea4" args="(snd_pcm_t *pcm, const snd_pcm_channel_area_t **areas, snd_pcm_uframes_t *offset, snd_pcm_uframes_t *frames)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int snd_pcm_mmap_begin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___p_c_m.html#ga919e634deecd855b6e2e15174e70d3ea">snd_pcm_t</a> *&nbsp;</td>
          <td class="paramname"> <em>pcm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsnd__pcm__channel__area__t.html">snd_pcm_channel_area_t</a> **&nbsp;</td>
          <td class="paramname"> <em>areas</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___p_c_m.html#gab01fcfe9b97382a8d3f2027c664b8b8a">snd_pcm_uframes_t</a> *&nbsp;</td>
          <td class="paramname"> <em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___p_c_m.html#gab01fcfe9b97382a8d3f2027c664b8b8a">snd_pcm_uframes_t</a> *&nbsp;</td>
          <td class="paramname"> <em>frames</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Application request to access a portion of direct (mmap) area. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pcm</em>&nbsp;</td><td>PCM handle </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>areas</em>&nbsp;</td><td>Returned mmap channel areas </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>offset</em>&nbsp;</td><td>Returned mmap area offset in area steps (== frames) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>frames</em>&nbsp;</td><td>mmap area portion size in frames (wanted on entry, contiguous available on exit) </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 on success otherwise a negative error code</dd></dl>
<p>It is necessary to call the <a class="el" href="group___p_c_m.html#ga8bb836bd0c414b59789d51a5f5379c08" title="Return number of frames ready to be read (capture) / written (playback).">snd_pcm_avail_update()</a> function directly before this call. Otherwise, this function can return a wrong count of available frames.</p>
<p>The function should be called before a sample-direct area can be accessed. The resulting size parameter is always less or equal to the input count of frames and can be zero, if no frames can be processed (the ring buffer is full).</p>
<p>See the <a class="el" href="group___p_c_m___direct.html#gac306bd13c305825aa39dd9180a3ad520" title="Application has completed the access to area requested with snd_pcm_mmap_begin.">snd_pcm_mmap_commit()</a> function to finish the frame processing in the direct areas. </p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="_2test_2pcm_8c-example.html#a50">/test/pcm.c</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="gac306bd13c305825aa39dd9180a3ad520"></a><!-- doxytag: member="pcm.h::snd_pcm_mmap_commit" ref="gac306bd13c305825aa39dd9180a3ad520" args="(snd_pcm_t *pcm, snd_pcm_uframes_t offset, snd_pcm_uframes_t frames)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___p_c_m.html#ga71cdfa37e258d2210b8bd0216bf0c36c">snd_pcm_sframes_t</a> snd_pcm_mmap_commit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___p_c_m.html#ga919e634deecd855b6e2e15174e70d3ea">snd_pcm_t</a> *&nbsp;</td>
          <td class="paramname"> <em>pcm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___p_c_m.html#gab01fcfe9b97382a8d3f2027c664b8b8a">snd_pcm_uframes_t</a>&nbsp;</td>
          <td class="paramname"> <em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___p_c_m.html#gab01fcfe9b97382a8d3f2027c664b8b8a">snd_pcm_uframes_t</a>&nbsp;</td>
          <td class="paramname"> <em>frames</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Application has completed the access to area requested with <a class="el" href="group___p_c_m___direct.html#ga6d4acf42de554d4d1177fb035d484ea4" title="Application request to access a portion of direct (mmap) area.">snd_pcm_mmap_begin</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pcm</em>&nbsp;</td><td>PCM handle </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>offset</em>&nbsp;</td><td>area offset in area steps (== frames) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>frames</em>&nbsp;</td><td>area portion size in frames </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>count of transferred frames otherwise a negative error code</dd></dl>
<p>You should pass this function the offset value that <a class="el" href="group___p_c_m___direct.html#ga6d4acf42de554d4d1177fb035d484ea4" title="Application request to access a portion of direct (mmap) area.">snd_pcm_mmap_begin()</a> returned. The frames parameter should hold the number of frames you have written or read to/from the audio buffer. The frames parameter must never exceed the contiguous frames count that <a class="el" href="group___p_c_m___direct.html#ga6d4acf42de554d4d1177fb035d484ea4" title="Application request to access a portion of direct (mmap) area.">snd_pcm_mmap_begin()</a> returned. Each call to <a class="el" href="group___p_c_m___direct.html#ga6d4acf42de554d4d1177fb035d484ea4" title="Application request to access a portion of direct (mmap) area.">snd_pcm_mmap_begin()</a> must be followed by a call to <a class="el" href="group___p_c_m___direct.html#gac306bd13c305825aa39dd9180a3ad520" title="Application has completed the access to area requested with snd_pcm_mmap_begin.">snd_pcm_mmap_commit()</a>.</p>
<p>Example: </p>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">double</span> phase = 0;
  <span class="keyword">const</span> snd_pcm_area_t *areas;
  <a class="code" href="group___p_c_m.html#ga71cdfa37e258d2210b8bd0216bf0c36c">snd_pcm_sframes_t</a> avail, size, commitres;
  <a class="code" href="group___p_c_m.html#gab01fcfe9b97382a8d3f2027c664b8b8a">snd_pcm_uframes_t</a> offset, frames;
  <span class="keywordtype">int</span> err;

  avail = <a class="code" href="group___p_c_m.html#ga8bb836bd0c414b59789d51a5f5379c08" title="Return number of frames ready to be read (capture) / written (playback).">snd_pcm_avail_update</a>(pcm);
  <span class="keywordflow">if</span> (avail &lt; 0)
    error(avail);
  <span class="comment">// at this point, we can transfer at least &apos;avail&apos; frames</span>
  
  <span class="comment">// we want to process frames in chunks (period_size)</span>
  <span class="keywordflow">if</span> (avail &lt; period_size)
    <span class="keywordflow">goto</span> _skip;
  size = period_size;
  <span class="comment">// it is possible that contiguous areas are smaller, thus we use a loop</span>
  <span class="keywordflow">while</span> (size &gt; 0) {
    frames = size;

    err = <a class="code" href="group___p_c_m___direct.html#ga6d4acf42de554d4d1177fb035d484ea4" title="Application request to access a portion of direct (mmap) area.">snd_pcm_mmap_begin</a>(pcm_handle, &amp;areas, &amp;offset, &amp;frames);
    <span class="keywordflow">if</span> (err &lt; 0)
      error(err);
    <span class="comment">// this function fills the areas from offset with count of frames</span>
    generate_sine(areas, offset, frames, &amp;phase);
    commitres = <a class="code" href="group___p_c_m___direct.html#gac306bd13c305825aa39dd9180a3ad520" title="Application has completed the access to area requested with snd_pcm_mmap_begin.">snd_pcm_mmap_commit</a>(pcm_handle, offset, frames);
    <span class="keywordflow">if</span> (commitres &lt; 0 || commitres != frames)
      error(commitres &gt;= 0 ? -EPIPE : commitres);
      
    size -= frames;
  }
 _skip:
</pre></div><p>Look to the <a class="el" href="pcm.html#example_test_pcm">Sine-wave generator</a> example for more details about the generate_sine function. </p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="_2test_2pcm_8c-example.html#a51">/test/pcm.c</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ga24b6c538c8d7ddd0776ee65f8fb909eb"></a><!-- doxytag: member="pcm.h::snd_pcm_mmap_readi" ref="ga24b6c538c8d7ddd0776ee65f8fb909eb" args="(snd_pcm_t *pcm, void *buffer, snd_pcm_uframes_t size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___p_c_m.html#ga71cdfa37e258d2210b8bd0216bf0c36c">snd_pcm_sframes_t</a> snd_pcm_mmap_readi </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___p_c_m.html#ga919e634deecd855b6e2e15174e70d3ea">snd_pcm_t</a> *&nbsp;</td>
          <td class="paramname"> <em>pcm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___p_c_m.html#gab01fcfe9b97382a8d3f2027c664b8b8a">snd_pcm_uframes_t</a>&nbsp;</td>
          <td class="paramname"> <em>size</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Read interleaved frames from a PCM using direct buffer (mmap). </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pcm</em>&nbsp;</td><td>PCM handle </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>buffer</em>&nbsp;</td><td>frames containing buffer </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>frames to be written </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a positive number of frames actually read otherwise a negative error code </dd></dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>-EBADFD</em>&nbsp;</td><td>PCM is not in the right state (<a class="el" href="group___p_c_m.html#gga61ac499cb3701ce536d4d83725908860a3eb4a3b75c7d2adb22f1829f3f738b27">SND_PCM_STATE_PREPARED</a> or <a class="el" href="group___p_c_m.html#gga61ac499cb3701ce536d4d83725908860a86f6fbc796881f19fde0e1957f878147">SND_PCM_STATE_RUNNING</a>) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>-EPIPE</em>&nbsp;</td><td>an overrun occurred </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>-ESTRPIPE</em>&nbsp;</td><td>a suspend event occurred (stream is suspended and waiting for an application recovery)</td></tr>
  </table>
  </dd>
</dl>
<p>If the blocking behaviour was selected, then routine waits until all requested bytes are filled. The count of bytes can be less only if a signal or underrun occurred.</p>
<p>If the non-blocking behaviour is selected, then routine doesn't wait at all. </p>

</div>
</div>
<a class="anchor" id="ga29ce9af60eafb67f0303418a176bf3ea"></a><!-- doxytag: member="pcm.h::snd_pcm_mmap_readn" ref="ga29ce9af60eafb67f0303418a176bf3ea" args="(snd_pcm_t *pcm, void **bufs, snd_pcm_uframes_t size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___p_c_m.html#ga71cdfa37e258d2210b8bd0216bf0c36c">snd_pcm_sframes_t</a> snd_pcm_mmap_readn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___p_c_m.html#ga919e634deecd855b6e2e15174e70d3ea">snd_pcm_t</a> *&nbsp;</td>
          <td class="paramname"> <em>pcm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&nbsp;</td>
          <td class="paramname"> <em>bufs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___p_c_m.html#gab01fcfe9b97382a8d3f2027c664b8b8a">snd_pcm_uframes_t</a>&nbsp;</td>
          <td class="paramname"> <em>size</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Read non interleaved frames to a PCM using direct buffer (mmap). </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pcm</em>&nbsp;</td><td>PCM handle </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bufs</em>&nbsp;</td><td>frames containing buffers (one for each channel) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>frames to be written </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a positive number of frames actually read otherwise a negative error code </dd></dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>-EBADFD</em>&nbsp;</td><td>PCM is not in the right state (<a class="el" href="group___p_c_m.html#gga61ac499cb3701ce536d4d83725908860a3eb4a3b75c7d2adb22f1829f3f738b27">SND_PCM_STATE_PREPARED</a> or <a class="el" href="group___p_c_m.html#gga61ac499cb3701ce536d4d83725908860a86f6fbc796881f19fde0e1957f878147">SND_PCM_STATE_RUNNING</a>) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>-EPIPE</em>&nbsp;</td><td>an overrun occurred </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>-ESTRPIPE</em>&nbsp;</td><td>a suspend event occurred (stream is suspended and waiting for an application recovery)</td></tr>
  </table>
  </dd>
</dl>
<p>If the blocking behaviour was selected, then routine waits until all requested bytes are filled. The count of bytes can be less only if a signal or underrun occurred.</p>
<p>If the non-blocking behaviour is selected, then routine doesn't wait at all. </p>

</div>
</div>
<a class="anchor" id="ga5a9ee8e1e764b12da6d54dfa195f7c52"></a><!-- doxytag: member="pcm.h::snd_pcm_mmap_writei" ref="ga5a9ee8e1e764b12da6d54dfa195f7c52" args="(snd_pcm_t *pcm, const void *buffer, snd_pcm_uframes_t size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___p_c_m.html#ga71cdfa37e258d2210b8bd0216bf0c36c">snd_pcm_sframes_t</a> snd_pcm_mmap_writei </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___p_c_m.html#ga919e634deecd855b6e2e15174e70d3ea">snd_pcm_t</a> *&nbsp;</td>
          <td class="paramname"> <em>pcm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___p_c_m.html#gab01fcfe9b97382a8d3f2027c664b8b8a">snd_pcm_uframes_t</a>&nbsp;</td>
          <td class="paramname"> <em>size</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Write interleaved frames to a PCM using direct buffer (mmap). </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pcm</em>&nbsp;</td><td>PCM handle </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>buffer</em>&nbsp;</td><td>frames containing buffer </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>frames to be written </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a positive number of frames actually written otherwise a negative error code </dd></dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>-EBADFD</em>&nbsp;</td><td>PCM is not in the right state (<a class="el" href="group___p_c_m.html#gga61ac499cb3701ce536d4d83725908860a3eb4a3b75c7d2adb22f1829f3f738b27">SND_PCM_STATE_PREPARED</a> or <a class="el" href="group___p_c_m.html#gga61ac499cb3701ce536d4d83725908860a86f6fbc796881f19fde0e1957f878147">SND_PCM_STATE_RUNNING</a>) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>-EPIPE</em>&nbsp;</td><td>an underrun occurred </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>-ESTRPIPE</em>&nbsp;</td><td>a suspend event occurred (stream is suspended and waiting for an application recovery)</td></tr>
  </table>
  </dd>
</dl>
<p>If the blocking behaviour is selected, then routine waits until all requested bytes are played or put to the playback ring buffer. The count of bytes can be less only if a signal or underrun occurred.</p>
<p>If the non-blocking behaviour is selected, then routine doesn't wait at all. </p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="_2test_2pcm_8c-example.html#a53">/test/pcm.c</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ga092b1a7f387e9fc2977649bfd43b0958"></a><!-- doxytag: member="pcm.h::snd_pcm_mmap_writen" ref="ga092b1a7f387e9fc2977649bfd43b0958" args="(snd_pcm_t *pcm, void **bufs, snd_pcm_uframes_t size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___p_c_m.html#ga71cdfa37e258d2210b8bd0216bf0c36c">snd_pcm_sframes_t</a> snd_pcm_mmap_writen </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___p_c_m.html#ga919e634deecd855b6e2e15174e70d3ea">snd_pcm_t</a> *&nbsp;</td>
          <td class="paramname"> <em>pcm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&nbsp;</td>
          <td class="paramname"> <em>bufs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___p_c_m.html#gab01fcfe9b97382a8d3f2027c664b8b8a">snd_pcm_uframes_t</a>&nbsp;</td>
          <td class="paramname"> <em>size</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Write non interleaved frames to a PCM using direct buffer (mmap). </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pcm</em>&nbsp;</td><td>PCM handle </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bufs</em>&nbsp;</td><td>frames containing buffers (one for each channel) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>frames to be written </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a positive number of frames actually written otherwise a negative error code </dd></dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>-EBADFD</em>&nbsp;</td><td>PCM is not in the right state (<a class="el" href="group___p_c_m.html#gga61ac499cb3701ce536d4d83725908860a3eb4a3b75c7d2adb22f1829f3f738b27">SND_PCM_STATE_PREPARED</a> or <a class="el" href="group___p_c_m.html#gga61ac499cb3701ce536d4d83725908860a86f6fbc796881f19fde0e1957f878147">SND_PCM_STATE_RUNNING</a>) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>-EPIPE</em>&nbsp;</td><td>an underrun occurred </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>-ESTRPIPE</em>&nbsp;</td><td>a suspend event occurred (stream is suspended and waiting for an application recovery)</td></tr>
  </table>
  </dd>
</dl>
<p>If the blocking behaviour is selected, then routine waits until all requested bytes are played or put to the playback ring buffer. The count of bytes can be less only if a signal or underrun occurred.</p>
<p>If the non-blocking behaviour is selected, then routine doesn't wait at all. </p>

</div>
</div>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&nbsp;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&nbsp;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&nbsp;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&nbsp;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&nbsp;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr size="1"><address style="text-align: right;"><small>
Generated for ALSA project - the C library reference by&nbsp;<a href="http://www.doxygen.org/
index.html"><img src="doxygen.png" alt="doxygen" align="middle" border="0"></a>
1.6.1</small></address>
</body>
</html>
