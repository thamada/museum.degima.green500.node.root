<!-- This comment will put IE 6, 7 and 8 in quirks mode -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>ALSA project - the C library reference: PCM (digital audio) plugins</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.6.1 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <img id="MSearchSelect" src="search/search.png"
             onmouseover="return searchBox.OnSearchSelectShow()"
             onmouseout="return searchBox.OnSearchSelectHide()"
             alt=""/>
        <input type="text" id="MSearchField" value="Search" accesskey="S"
             onfocus="searchBox.OnSearchFieldFocus(true)" 
             onblur="searchBox.OnSearchFieldFocus(false)" 
             onkeyup="searchBox.OnSearchFieldChange(event)"/>
        <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
        </div>
      </li>
    </ul>
  </div>
</div>
<div class="contents">


<h1><a class="anchor" id="pcm_plugins">PCM (digital audio) plugins </a></h1><p>PCM plugins extends functionality and features of PCM devices. The plugins take care about various sample conversions, sample copying among channels and so on.</p>
<h2><a class="anchor" id="pcm_plugins_slave">
Slave definition</a></h2>
<p>The slave plugin can be specified directly with a string or the definition can be entered inside a compound configuration node. Some restrictions can be also specified (like static rate or count of channels).</p>
<div class="fragment"><pre class="fragment">pcm_slave.NAME {
        pcm STR         # PCM name
<span class="preprocessor">        # or</span>
<span class="preprocessor"></span>        pcm { }         # PCM definition
        format STR      # Format or <span class="stringliteral">&quot;unchanged&quot;</span>
        channels INT    # Count of channels or <span class="stringliteral">&quot;unchanged&quot;</span> <span class="keywordtype">string</span>
        rate INT        # Rate in Hz or <span class="stringliteral">&quot;unchanged&quot;</span> <span class="keywordtype">string</span>
        period_time INT # Period time in us or <span class="stringliteral">&quot;unchanged&quot;</span> <span class="keywordtype">string</span>
        buffer_time INT # Buffer time in us or <span class="stringliteral">&quot;unchanged&quot;</span> <span class="keywordtype">string</span>
}
</pre></div><p>Example:</p>
<div class="fragment"><pre class="fragment">pcm_slave.slave_rate44100Hz {
        pcm <span class="stringliteral">&quot;hw:0,0&quot;</span>
        rate 44100
}

pcm.rate44100Hz {
        type plug
        slave slave_rate44100Hz
}
</pre></div><p>The equivalent configuration (in one compound):</p>
<div class="fragment"><pre class="fragment">pcm.rate44100Hz {
        type plug
        slave {
                pcm <span class="stringliteral">&quot;hw:0,0&quot;</span>
                rate 44100
        }
}
</pre></div><h2><a class="anchor" id="pcm_plugins_hw">
Plugin: hw</a></h2>
<p>This plugin communicates directly with the ALSA kernel driver. It is a raw communication without any conversions. The emulation of mmap access can be optionally enabled, but expect worse latency in the case.</p>
<p>The nonblock option specifies whether the device is opened in a non-blocking manner. Note that the blocking behavior for read/write access won't be changed by this option. This influences only on the blocking behavior at opening the device. If you would like to keep the compatibility with the older ALSA stuff, turn this option off.</p>
<div class="fragment"><pre class="fragment">pcm.name {
        type hw                 # Kernel PCM
        card INT/STR            # Card name (<span class="keywordtype">string</span>) or number (integer)
        [device INT]            <span class="preprocessor"># Device number (default 0)</span>
<span class="preprocessor"></span>        [subdevice INT]         # Subdevice number (<span class="keywordflow">default</span> -1: first available)
        [sync_ptr_ioctl BOOL]   # Use SYNC_PTR ioctl rather than the direct mmap access <span class="keywordflow">for</span> control structures
        [nonblock BOOL]         # Force non-blocking open mode
        [format STR]            # Restrict only to the given format
        [channels INT]          # Restrict only to the given channels
        [rate INT]              # Restrict only to the given rate
}
</pre></div><h3><a class="anchor" id="pcm_plugins_hw_funcref">
Function reference</a></h3>
<ul>
<li>
<a class="el" href="pcm__hw_8c.html#a06abf5d78c26a9d8e79fd0428a5c7183" title="Creates a new hw PCM.">snd_pcm_hw_open()</a> </li>
<li>
<a class="el" href="pcm__hw_8c.html#a7687673b2a39b944c5693043446afaf9" title="Creates a new hw PCM.">_snd_pcm_hw_open()</a> </li>
</ul>
<h2><a class="anchor" id="pcm_plugins_mmap_emul">
Plugin: mmap_emul</a></h2>
<div class="fragment"><pre class="fragment">pcm.name {
        type mmap_emul
        slave PCM
}
</pre></div><h3><a class="anchor" id="pcm_plugins_mmap_emul_funcref">
Function reference</a></h3>
<ul>
<li>
<a class="el" href="pcm__hw_8c.html#a7687673b2a39b944c5693043446afaf9" title="Creates a new hw PCM.">_snd_pcm_hw_open()</a> </li>
</ul>
<h2><a class="anchor" id="pcm_plugins_shm">
Plugin: shm</a></h2>
<p>This plugin communicates with aserver via shared memory. It is a raw communication without any conversions, but it can be expected worse performance.</p>
<div class="fragment"><pre class="fragment">pcm.name {
        type shm                # Shared memory PCM
        server STR              # Server name
        pcm STR                 # PCM name
}
</pre></div><h3><a class="anchor" id="pcm_plugins_shm_funcref">
Function reference</a></h3>
<ul>
<li>
<a class="el" href="pcm__shm_8c.html#a3684b5fb80a3549a9176cbc7ea9e5181" title="Creates a new shared memory PCM.">snd_pcm_shm_open()</a> </li>
<li>
<a class="el" href="pcm__shm_8c.html#adc046ce3ea6720d3545bb2158266bc75" title="Creates a new shm PCM.">_snd_pcm_shm_open()</a> </li>
</ul>
<h2><a class="anchor" id="pcm_plugins_null">
Plugin: Null</a></h2>
<p>This plugin discards contents of a PCM stream or creates a stream with zero samples.</p>
<p>Note: This implementation uses devices /dev/null (playback, must be writable) and /dev/full (capture, must be readable).</p>
<div class="fragment"><pre class="fragment">pcm.name {
        type null               # Null PCM
}
</pre></div><h3><a class="anchor" id="pcm_plugins_null_funcref">
Function reference</a></h3>
<ul>
<li>
<a class="el" href="pcm__null_8c.html#ad1e47f314d908607cf908d9859359724" title="Creates a new null PCM.">snd_pcm_null_open()</a> </li>
<li>
<a class="el" href="pcm__null_8c.html#af964b1e41d92a723748128014026ebd6" title="Creates a new Null PCM.">_snd_pcm_null_open()</a> </li>
</ul>
<h2><a class="anchor" id="pcm_plugins_copy">
Plugin: copy</a></h2>
<p>This plugin copies samples from master copy PCM to given slave PCM. The channel count, format and rate must match for both of them.</p>
<div class="fragment"><pre class="fragment">pcm.name {
        type copy               # Copy PCM
        slave STR               # Slave name
<span class="preprocessor">        # or</span>
<span class="preprocessor"></span>        slave {                 # Slave definition
                pcm STR         # Slave PCM name
<span class="preprocessor">                # or</span>
<span class="preprocessor"></span>                pcm { }         # Slave PCM definition
        }
}
</pre></div><h3><a class="anchor" id="pcm_plugins_copy_funcref">
Function reference</a></h3>
<ul>
<li>
<a class="el" href="pcm__copy_8c.html#a97fb1b1587b7905bbc908cf7d03a727a" title="Creates a new copy PCM.">snd_pcm_copy_open()</a> </li>
<li>
<a class="el" href="pcm__copy_8c.html#a47dd871325fe6dfe7650443de19e31ba" title="Creates a new copy PCM.">_snd_pcm_copy_open()</a> </li>
</ul>
<h2><a class="anchor" id="pcm_plugins_linear">
Plugin: linear</a></h2>
<p>This plugin converts linear samples from master linear conversion PCM to given slave PCM. The channel count, format and rate must match for both of them.</p>
<div class="fragment"><pre class="fragment">pcm.name {
        type linear             # Linear conversion PCM
        slave STR               # Slave name
<span class="preprocessor">        # or</span>
<span class="preprocessor"></span>        slave {                 # Slave definition
                pcm STR         # Slave PCM name
<span class="preprocessor">                # or</span>
<span class="preprocessor"></span>                pcm { }         # Slave PCM definition
                format STR      # Slave format
        }
}
</pre></div><h3><a class="anchor" id="pcm_plugins_linear_funcref">
Function reference</a></h3>
<ul>
<li>
<a class="el" href="pcm__linear_8c.html#ad5aad633e536382e36d128aa074ae2d5" title="Creates a new linear conversion PCM.">snd_pcm_linear_open()</a> </li>
<li>
<a class="el" href="pcm__linear_8c.html#a705b6ecd46bb7ceb0cfef986404686f8" title="Creates a new linear conversion PCM.">_snd_pcm_linear_open()</a> </li>
</ul>
<h2><a class="anchor" id="pcm_plugins_lfloat">
Plugin: linear&lt;-&gt;float</a></h2>
<p>This plugin converts linear to float samples and float to linear samples from master linear&lt;-&gt;float conversion PCM to given slave PCM. The channel count, format and rate must match for both of them.</p>
<div class="fragment"><pre class="fragment">pcm.name {
        type lfloat             # Linear&lt;-&gt;Float conversion PCM
        slave STR               # Slave name
<span class="preprocessor">        # or</span>
<span class="preprocessor"></span>        slave {                 # Slave definition
                pcm STR         # Slave PCM name
<span class="preprocessor">                # or</span>
<span class="preprocessor"></span>                pcm { }         # Slave PCM definition
                format STR      # Slave format
        }
}
</pre></div><h3><a class="anchor" id="pcm_plugins_lfloat_funcref">
Function reference</a></h3>
<ul>
<li>
<a class="el" href="pcm__lfloat_8c.html#a1cf1d379cfe222a0205356e72ae1e460" title="Creates a new linear conversion PCM.">snd_pcm_lfloat_open()</a> </li>
<li>
<a class="el" href="pcm__lfloat_8c.html#a073916f2bcb53f0020b5fd5c371f4fc8" title="Creates a new linear&lt;-&gt;float conversion PCM.">_snd_pcm_lfloat_open()</a> </li>
</ul>
<h2><a class="anchor" id="pcm_plugins_mulaw">
Plugin: Mu-Law</a></h2>
<p>This plugin converts Mu-Law samples to linear or linear to Mu-Law samples from master Mu-Law conversion PCM to given slave PCM. The channel count, format and rate must match for both of them.</p>
<div class="fragment"><pre class="fragment">pcm.name {
        type mulaw              # Mu-Law conversion PCM
        slave STR               # Slave name
<span class="preprocessor">        # or</span>
<span class="preprocessor"></span>        slave {                 # Slave definition
                pcm STR         # Slave PCM name
<span class="preprocessor">                # or</span>
<span class="preprocessor"></span>                pcm { }         # Slave PCM definition
                format STR      # Slave format
        }
}
</pre></div><h3><a class="anchor" id="pcm_plugins_mulaw_funcref">
Function reference</a></h3>
<ul>
<li>
<a class="el" href="pcm__mulaw_8c.html#a5180265fc0f22f9eeabaa15555bcd072" title="Creates a new Mu-Law conversion PCM.">snd_pcm_mulaw_open()</a> </li>
<li>
<a class="el" href="pcm__mulaw_8c.html#aac8ed7d538562e09d0b8bbfe08df3665" title="Creates a new Mu-Law conversion PCM.">_snd_pcm_mulaw_open()</a> </li>
</ul>
<h2><a class="anchor" id="pcm_plugins_alaw">
Plugin: A-Law</a></h2>
<p>This plugin converts A-Law samples to linear or linear to A-Law samples from master A-Law conversion PCM to given slave PCM. The channel count, format and rate must match for both of them.</p>
<div class="fragment"><pre class="fragment">pcm.name {
        type alaw               # A-Law conversion PCM
        slave STR               # Slave name
<span class="preprocessor">        # or</span>
<span class="preprocessor"></span>        slave {                 # Slave definition
                pcm STR         # Slave PCM name
<span class="preprocessor">                # or</span>
<span class="preprocessor"></span>                pcm { }         # Slave PCM definition
                format STR      # Slave format
        }
}
</pre></div><h3><a class="anchor" id="pcm_plugins_alaw_funcref">
Function reference</a></h3>
<ul>
<li>
<a class="el" href="pcm__alaw_8c.html#adfc7fc62627b564e1a6e0a3069730a56" title="Creates a new A-Law conversion PCM.">snd_pcm_alaw_open()</a> </li>
<li>
<a class="el" href="pcm__alaw_8c.html#a033d4c03b15175509e960689b5d515b0" title="Creates a new A-Law conversion PCM.">_snd_pcm_alaw_open()</a> </li>
</ul>
<h2><a class="anchor" id="pcm_plugins_adpcm">
Plugin: Ima-ADPCM</a></h2>
<p>This plugin converts Ima-ADPCM samples to linear or linear to Ima-ADPCM samples from master Ima-ADPCM conversion PCM to given slave PCM. The channel count, format and rate must match for both of them.</p>
<div class="fragment"><pre class="fragment">pcm.name {
        type adpcm              # Ima-ADPCM conversion PCM
        slave STR               # Slave name
<span class="preprocessor">        # or</span>
<span class="preprocessor"></span>        slave {                 # Slave definition
                pcm STR         # Slave PCM name
<span class="preprocessor">                # or</span>
<span class="preprocessor"></span>                pcm { }         # Slave PCM definition
                format STR      # Slave format
        }
}
</pre></div><h3><a class="anchor" id="pcm_plugins_adpcm_funcref">
Function reference</a></h3>
<ul>
<li>
<a class="el" href="pcm__adpcm_8c.html#afc781f794b0c705552491b6707bf2c86" title="Creates a new Ima-ADPCM conversion PCM.">snd_pcm_adpcm_open()</a> </li>
<li>
<a class="el" href="pcm__adpcm_8c.html#a71eccece5048625c5648aa4b1077c271" title="Creates a new Ima-ADPCM conversion PCM.">_snd_pcm_adpcm_open()</a> </li>
</ul>
<h2><a class="anchor" id="pcm_plugins_route">
Plugin: Route &amp; Volume</a></h2>
<p>This plugin converts channels and applies volume during the conversion. The format and rate must match for both of them.</p>
<div class="fragment"><pre class="fragment">pcm.name {
        type route              # Route &amp; Volume conversion PCM
        slave STR               # Slave name
<span class="preprocessor">        # or</span>
<span class="preprocessor"></span>        slave {                 # Slave definition
                pcm STR         # Slave PCM name
<span class="preprocessor">                # or</span>
<span class="preprocessor"></span>                pcm { }         # Slave PCM definition
                [format STR]    # Slave format
                [channels INT]  # Slave channels
        }
        ttable {                # Transfer table (bi-dimensional compound of cchannels * schannels numbers)
                CCHANNEL {
                        SCHANNEL REAL   # route value (0.0 - 1.0)
                }
        }
}
</pre></div><h3><a class="anchor" id="pcm_plugins_route_funcref">
Function reference</a></h3>
<ul>
<li>
<a class="el" href="pcm__route_8c.html#ae19a77e8ec26dc93b8be5a93e7391550" title="Creates a new Route &amp; Volume PCM.">snd_pcm_route_open()</a> </li>
<li>
<a class="el" href="pcm__route_8c.html#abee47f3c05e74d83bf2a96559de9a262" title="Creates a new Route &amp; Volume PCM.">_snd_pcm_route_open()</a> </li>
</ul>
<h2><a class="anchor" id="pcm_plugins_rate">
Plugin: Rate</a></h2>
<p>This plugin converts a stream rate. The input and output formats must be linear.</p>
<div class="fragment"><pre class="fragment">pcm.name {
        type rate               # Rate PCM
        slave STR               # Slave name
<span class="preprocessor">        # or</span>
<span class="preprocessor"></span>        slave {                 # Slave definition
                pcm STR         # Slave PCM name
<span class="preprocessor">                # or</span>
<span class="preprocessor"></span>                pcm { }         # Slave PCM definition
                rate INT        # Slave rate
                [format STR]    # Slave format
        }
        converter STR                   # optional
<span class="preprocessor">        # or</span>
<span class="preprocessor"></span>        converter [ STR1 STR2 ... ]     # optional
<span class="preprocessor">                                # Converter type, default is taken from</span>
<span class="preprocessor"></span><span class="preprocessor">                                # defaults.pcm.rate_converter</span>
<span class="preprocessor">}</span>
</pre></div><h3><a class="anchor" id="pcm_plugins_rate_funcref">
Function reference</a></h3>
<ul>
<li>
<a class="el" href="pcm__rate_8c.html#acbc33a01e5c38505fb8777e8a3cb808f" title="Creates a new rate PCM.">snd_pcm_rate_open()</a> </li>
<li>
<a class="el" href="pcm__rate_8c.html#aa2b39b0460f63d709b2244be669c479b" title="Creates a new rate PCM.">_snd_pcm_rate_open()</a> </li>
</ul>
<h2><a class="anchor" id="pcm_plugins_plug">
Automatic conversion plugin</a></h2>
<p>This plugin converts channels, rate and format on request.</p>
<div class="fragment"><pre class="fragment">pcm.name {
        type plug               # Automatic conversion PCM
        slave STR               # Slave name
<span class="preprocessor">        # or</span>
<span class="preprocessor"></span>        slave {                 # Slave definition
                pcm STR         # Slave PCM name
<span class="preprocessor">                # or</span>
<span class="preprocessor"></span>                pcm { }         # Slave PCM definition
                [format STR]    # Slave format (<span class="keywordflow">default</span> nearest) or <span class="stringliteral">&quot;unchanged&quot;</span>
                [channels INT]  # Slave channels (<span class="keywordflow">default</span> nearest) or <span class="stringliteral">&quot;unchanged&quot;</span>
                [rate INT]      # Slave rate (<span class="keywordflow">default</span> nearest) or <span class="stringliteral">&quot;unchanged&quot;</span>
        }
        route_policy STR        # route policy <span class="keywordflow">for</span> automatic ttable generation
<span class="preprocessor">                                # STR can be &apos;default&apos;, &apos;average&apos;, &apos;copy&apos;, &apos;duplicate&apos;</span>
<span class="preprocessor"></span><span class="preprocessor">                                # average: result is average of input channels</span>
<span class="preprocessor"></span><span class="preprocessor">                                # copy: only first channels are copied to destination</span>
<span class="preprocessor"></span><span class="preprocessor">                                # duplicate: duplicate first set of channels</span>
<span class="preprocessor"></span><span class="preprocessor">                                # default: copy policy, except for mono capture - sum</span>
<span class="preprocessor"></span>        ttable {                # Transfer table (bi-dimensional compound of cchannels * schannels numbers)
                CCHANNEL {
                        SCHANNEL REAL   # route value (0.0 - 1.0)
                }
        }
        rate_converter STR      # type of rate converter
<span class="preprocessor">        # or</span>
<span class="preprocessor"></span>        rate_converter [ STR1 STR2 ... ]
<span class="preprocessor">                                # type of rate converter</span>
<span class="preprocessor"></span><span class="preprocessor">                                # default value is taken from defaults.pcm.rate_converter</span>
<span class="preprocessor">}</span>
</pre></div><h3><a class="anchor" id="pcm_plugins_plug_funcref">
Function reference</a></h3>
<ul>
<li>
snd_pcm_plug_open() </li>
<li>
_snd_pcm_plug_open() </li>
</ul>
<h2><a class="anchor" id="pcm_plugins_file">
Plugin: File</a></h2>
<p>This plugin stores contents of a PCM stream to file or pipes the stream to a command, and optionally uses an existing file as an input data source (i.e., "virtual mic")</p>
<div class="fragment"><pre class="fragment">pcm.name {
        type file               # File PCM
        slave STR               # Slave name
<span class="preprocessor">        # or</span>
<span class="preprocessor"></span>        slave {                 # Slave definition
                pcm STR         # Slave PCM name
<span class="preprocessor">                # or</span>
<span class="preprocessor"></span>                pcm { }         # Slave PCM definition
        }
        file STR                # Output filename (or shell command the stream
                                # will be piped to <span class="keywordflow">if</span> STR starts with the pipe
                                # <span class="keywordtype">char</span>).
                                # STR can contain format keys, replaced by
<span class="preprocessor">                                # real values corresponding to the stream:</span>
<span class="preprocessor"></span><span class="preprocessor">                                # %r    rate (replaced with: 48000)</span>
<span class="preprocessor"></span><span class="preprocessor">                                # %c    channels (replaced with: 2)</span>
<span class="preprocessor"></span><span class="preprocessor">                                # %b    bits per sample (replaced with: 16)</span>
<span class="preprocessor"></span><span class="preprocessor">                                # %f    sample format string</span>
<span class="preprocessor"></span><span class="preprocessor">                                #                       (replaced with: S16_LE)</span>
<span class="preprocessor"></span><span class="preprocessor">                                # %%    replaced with %</span>
<span class="preprocessor"></span>        or
        file INT                # Output file descriptor number
        infile STR              # Input filename - only raw format
        or
        infile INT              # Input file descriptor number
        [format STR]            # File format (<span class="stringliteral">&quot;raw&quot;</span> or <span class="stringliteral">&quot;wav&quot;</span>)
        [perm INT]              # Output file permission (octal, def. 0600)
}
</pre></div><h3><a class="anchor" id="pcm_plugins_file_funcref">
Function reference</a></h3>
<ul>
<li>
<a class="el" href="pcm__file_8c.html#ab0a1377b05d3c826fb244a3c711ec656" title="Creates a new File PCM.">snd_pcm_file_open()</a> </li>
<li>
<a class="el" href="pcm__file_8c.html#a3732156e2f368386a89f2f200c496b0a" title="Creates a new File PCM.">_snd_pcm_file_open()</a> </li>
</ul>
<h2><a class="anchor" id="pcm_plugins_multi">
Plugin: Multiple streams to One</a></h2>
<p>This plugin converts multiple streams to one.</p>
<div class="fragment"><pre class="fragment">pcm.name {
        type multi              # Multiple streams conversion PCM
        slaves {                # Slaves definition
                ID STR          # Slave PCM name
<span class="preprocessor">                # or</span>
<span class="preprocessor"></span>                ID {
                        pcm STR         # Slave PCM name
<span class="preprocessor">                        # or</span>
<span class="preprocessor"></span>                        pcm { }         # Slave PCM definition
                        channels INT    # Slave channels
                }
        }
        bindings {              # Bindings table
                N {
                        slave STR       # Slave key
                        channel INT     # Slave channel
                }
        }
        [master INT]            # Define the master slave
}
</pre></div><p>For example, to bind two PCM streams with two-channel stereo (hw:0,0 and hw:0,1) as one 4-channel stereo PCM stream, define like this: </p>
<div class="fragment"><pre class="fragment">pcm.quad {
        type multi

        slaves.a.pcm <span class="stringliteral">&quot;hw:0,0&quot;</span>
        slaves.a.channels 2
        slaves.b.pcm <span class="stringliteral">&quot;hw:0,1&quot;</span>
        slaves.b.channels 2

        bindings.0.slave a
        bindings.0.channel 0
        bindings.1.slave a
        bindings.1.channel 1
        bindings.2.slave b
        bindings.2.channel 0
        bindings.3.slave b
        bindings.3.channel 1
}
</pre></div><p> Note that the resultant pcm "quad" is not in the interleaved format but in the "complex" format. Hence, it's not accessible by applications which can handle only the interleaved (or the non-interleaved) format. In such a case, wrap this PCM with <a class="el" href="pcm_plugins.html#pcm_plugins_route">route</a> or <a class="el" href="pcm_plugins.html#pcm_plugins_plug">plug</a> plugin. </p>
<div class="fragment"><pre class="fragment">pcm.quad2 {
        type route
        slave.pcm <span class="stringliteral">&quot;quad&quot;</span>
        ttable.0.0 1
        ttable.1.1 1
        ttable.2.2 1
        ttable.3.3 1
}
</pre></div><h3><a class="anchor" id="pcm_plugins_multi_funcref">
Function reference</a></h3>
<ul>
<li>
<a class="el" href="pcm__multi_8c.html#a9cd9738f81265d5255a9c28bbccb8bb4" title="Creates a new Multi PCM.">snd_pcm_multi_open()</a> </li>
<li>
<a class="el" href="pcm__multi_8c.html#aeb0fcef35d9f9bf598384cfe46e163a5" title="Creates a new Multi PCM.">_snd_pcm_multi_open()</a> </li>
</ul>
<h2><a class="anchor" id="pcm_plugins_share">
Plugin: Share</a></h2>
<p>This plugin allows sharing of multiple channels with more clients. The access to each channel is exlusive (samples are not mixed together). It means, if the channel zero is used with first client, the channel cannot be used with second one. If you are looking for a mixing plugin, use the <a class="el" href="pcm_plugins.html#pcm_plugins_dmix">dmix plugin</a>.</p>
<p>The difference from <a class="el" href="pcm_plugins.html#pcm_plugins_dshare">dshare plugin</a> is that share plugin requires the server program "aserver", while dshare plugin doesn't need the explicit server but access to the shared buffer.</p>
<div class="fragment"><pre class="fragment">pcm.name {
        type share              # Share PCM
        slave STR               # Slave name
<span class="preprocessor">        # or</span>
<span class="preprocessor"></span>        slave {                 # Slave definition
                pcm STR         # Slave PCM name
                [format STR]    # Slave format
                [channels INT]  # Slave channels
                [rate INT]      # Slave rate
                [period_time INT] # Slave period time in us
                [buffer_time INT] # Slave buffer time in us
        }
        bindings {
                N INT           # Slave channel INT <span class="keywordflow">for</span> client channel N
        }
}
</pre></div><h3><a class="anchor" id="pcm_plugins_share_funcref">
Function reference</a></h3>
<ul>
<li>
<a class="el" href="pcm__share_8c.html#ab7c7e88e681d727250e67b6fbd11e245" title="Creates a new Share PCM.">snd_pcm_share_open()</a> </li>
<li>
<a class="el" href="pcm__share_8c.html#a201ff59d8aad291bfd324fef114bf2d9" title="Creates a new Share PCM.">_snd_pcm_share_open()</a> </li>
</ul>
<h2><a class="anchor" id="pcm_plugins_hooks">
Plugin: hooks</a></h2>
<p>This plugin is used to call some 'hook' function when this plugin is opened, modified or closed. Typically, it is used to change control values for a certain state specially for the PCM (see the example below).</p>
<div class="fragment"><pre class="fragment"><span class="preprocessor"># Hook arguments definition</span>
<span class="preprocessor"></span>hook_args.NAME {
        ...                     # Arbitrary arguments
}

<span class="preprocessor"># PCM hook type</span>
<span class="preprocessor"></span>pcm_hook_type.NAME {
        [lib STR]               # Library file (<span class="keywordflow">default</span> libasound.so)
        [install STR]           # Install function (<span class="keywordflow">default</span> _snd_pcm_hook_NAME_install)
}

<span class="preprocessor"># PCM hook definition</span>
<span class="preprocessor"></span>pcm_hook.NAME {
        type STR                # PCM Hook type (see pcm_hook_type)
        [args STR]              # Arguments <span class="keywordflow">for</span> install function (see hook_args)
        <span class="preprocessor"># or</span>
<span class="preprocessor"></span>        [args { }]              # Arguments <span class="keywordflow">for</span> install function
}

<span class="preprocessor"># PCM hook plugin</span>
<span class="preprocessor"></span>pcm.NAME {
        type hooks              # PCM with hooks
        slave STR               # Slave name
<span class="preprocessor">        # or</span>
<span class="preprocessor"></span>        slave {                 # Slave definition
                pcm STR         # Slave PCM name
<span class="preprocessor">                # or</span>
<span class="preprocessor"></span>                pcm { }         # Slave PCM definition
        }
        hooks {
                ID STR          # Hook name (see pcm_hook)
                <span class="preprocessor"># or</span>
<span class="preprocessor"></span>                ID { }          # Hook definition (see pcm_hook)
        }
}
</pre></div><p>Example:</p>
<div class="fragment"><pre class="fragment">        hooks.0 {
                type ctl_elems
                hook_args [
                        {
                                name <span class="stringliteral">&quot;Wave Surround Playback Volume&quot;</span>
                                preserve <span class="keyword">true</span>
                                lock <span class="keyword">true</span>
                                optional <span class="keyword">true</span>
                                value [ 0 0 ]
                        }
                        {
                                name <span class="stringliteral">&quot;EMU10K1 PCM Send Volume&quot;</span>
                                index { @func private_pcm_subdevice }
                                lock <span class="keyword">true</span>
                                value [ 0 0 0 0 0 0 255 0 0 0 0 255 ]
                        }
                ]
        }
</pre></div><p> Here, the controls "Wave Surround Playback Volume" and "EMU10K1 PCM Send Volume" are set to the given values when this pcm is accessed. Since these controls take multi-dimensional values, the <code>value</code> field is written as an array. When <code>preserve</code> is true, the old values are saved and restored when the pcm is closed. The <code>lock</code> means that the control is locked during this pcm is opened, and cannot be changed by others. When <code>optional</code> is set, no error is returned but ignored even if the specified control doesn't exist.</p>
<h3><a class="anchor" id="pcm_plugins_hooks_funcref">
Function reference</a></h3>
<ul>
<li>
The function ctl_elems - <a class="el" href="pcm__hooks_8c.html#abfd89c986184f010df8646b46e623490" title="Install CTL settings using hardware associated with PCM handle.">_snd_pcm_hook_ctl_elems_install()</a> - installs CTL settings described by given configuration. </li>
<li>
<a class="el" href="pcm__hooks_8c.html#a0355f8ca87a7361b1c3fdd36baf05175" title="Creates a new hooks PCM.">snd_pcm_hooks_open()</a> </li>
<li>
<a class="el" href="pcm__hooks_8c.html#a4d7e604b82a739945aefde32395bea24" title="Creates a new hooks PCM.">_snd_pcm_hooks_open()</a> </li>
</ul>
<h2><a class="anchor" id="pcm_plugins_dmix">
Plugin: dmix</a></h2>
<p>This plugin provides direct mixing of multiple streams. The resolution for 32-bit mixing is only 24-bit. The low significant byte is filled with zeros. The extra 8 bits are used for the saturation.</p>
<div class="fragment"><pre class="fragment">pcm.name {
        type dmix               # Direct mix
        ipc_key INT             # unique IPC key
        ipc_key_add_uid BOOL    # add current uid to unique IPC key
        ipc_perm INT            # IPC permissions (octal, <span class="keywordflow">default</span> 0600)
        slave STR
        <span class="preprocessor"># or</span>
<span class="preprocessor"></span>        slave {                 # Slave definition
                pcm STR         # slave PCM name
<span class="preprocessor">                # or</span>
<span class="preprocessor"></span>                pcm { }         # slave PCM definition
                format STR      # format definition
                rate INT        # rate definition
                channels INT
                period_time INT # in usec
<span class="preprocessor">                # or</span>
<span class="preprocessor"></span>                period_size INT # in bytes
                buffer_time INT # in usec
<span class="preprocessor">                # or</span>
<span class="preprocessor"></span>                buffer_size INT # in bytes
                periods INT     # when buffer_size or buffer_time is not specified
        }
        bindings {              # note: <span class="keyword">this</span> is client independent!!!
                N INT           # maps slave channel to client channel N
        }
        slowptr BOOL            # slow but more precise pointer updates
}
</pre></div><p><code>ipc_key</code> specfies the unique IPC key in integer. This number must be unique for each different dmix definition, since the shared memory is created with this key number. When <code>ipc_key_add_uid</code> is set true, the uid value is added to the value set in <code>ipc_key</code>. This will avoid the confliction of the same IPC key with different users concurrently.</p>
<p>Note that the dmix plugin itself supports only a single configuration. That is, it supports only the fixed rate (default 48000), format (<code>S16</code>), channels (2), and period_time (125000). For using other configuration, you have to set the value explicitly in the slave PCM definition. The rate, format and channels can be covered by an additional <a class="el" href="pcm_plugins.html#pcm_plugins_dmix">plug plugin</a>, but there is only one base configuration, anyway.</p>
<p>An example configuration for setting 44100 Hz, <code>S32_LE</code> format as the slave PCM of "hw:0" is like below: </p>
<div class="fragment"><pre class="fragment">pcm.dmix_44 {
        type dmix
        ipc_key 321456  # any unique value
        ipc_key_add_uid <span class="keyword">true</span>
        slave {
                pcm <span class="stringliteral">&quot;hw:0&quot;</span>
                format S32_LE
                rate 44100
        }
}
</pre></div><p> You can hear 48000 Hz samples still using this dmix pcm via plug plugin like: </p>
<div class="fragment"><pre class="fragment">% aplay -Dplug:dmix_44 foo_48k.wav
</pre></div><p>For using the dmix plugin for OSS emulation device, you have to set the period and the buffer sizes in power of two. For example, </p>
<div class="fragment"><pre class="fragment">pcm.dmixoss {
        type dmix
        ipc_key 321456  # any unique value
        ipc_key_add_uid <span class="keyword">true</span>
        slave {
                pcm <span class="stringliteral">&quot;hw:0&quot;</span>
                period_time 0
                period_size 1024  # must be power of 2
                buffer_size 8192  # ditto
        }
}
</pre></div><p> <code>period_time 0</code> must be set, too, for resetting the default value. In the case of soundcards with multi-channel IO, adding the bindings would help </p>
<div class="fragment"><pre class="fragment">pcm.dmixoss {
        ...
        bindings {
                0 0   # map from 0 to 0
                1 1   # map from 1 to 1
        }
}
</pre></div><p> so that only the first two channels are used by dmix. Also, note that ICE1712 have the limited buffer size, 5513 frames (corresponding to 640 kB). In this case, reduce the buffer_size to 4096.</p>
<h3><a class="anchor" id="pcm_plugins_dmix_funcref">
Function reference</a></h3>
<ul>
<li>
<a class="el" href="pcm__dmix_8c.html#ae31120062bceb47f24d18e672f728b4f" title="Creates a new dmix PCM.">snd_pcm_dmix_open()</a> </li>
<li>
<a class="el" href="pcm__dmix_8c.html#a98332eee00abd086c486bc63ade4484e" title="Creates a new dmix PCM.">_snd_pcm_dmix_open()</a> </li>
</ul>
<h2><a class="anchor" id="pcm_plugins_dshare">
Plugin: dshare</a></h2>
<p>This plugin provides sharing channels. Unlike <a class="el" href="pcm_plugins.html#pcm_plugins_share">share plugin</a>, this plugin doesn't need the explicit server program but accesses the shared buffer concurrently from each client as well as <a class="el" href="pcm_plugins.html#pcm_plugins_dmix">dmix</a> and <a class="el" href="pcm_plugins.html#pcm_plugins_dsnoop">dsnoop</a> plugins do. The parameters below are almost identical with these plugins.</p>
<div class="fragment"><pre class="fragment">pcm.name {
        type dshare             # Direct sharing
        ipc_key INT             # unique IPC key
        ipc_key_add_uid BOOL    # add current uid to unique IPC key
        ipc_perm INT            # IPC permissions (octal, <span class="keywordflow">default</span> 0600)
        slave STR
        <span class="preprocessor"># or</span>
<span class="preprocessor"></span>        slave {                 # Slave definition
                pcm STR         # slave PCM name
<span class="preprocessor">                # or</span>
<span class="preprocessor"></span>                pcm { }         # slave PCM definition
                format STR      # format definition
                rate INT        # rate definition
                channels INT
                period_time INT # in usec
<span class="preprocessor">                # or</span>
<span class="preprocessor"></span>                period_size INT # in bytes
                buffer_time INT # in usec
<span class="preprocessor">                # or</span>
<span class="preprocessor"></span>                buffer_size INT # in bytes
                periods INT     # when buffer_size or buffer_time is not specified
        }
        bindings {              # note: <span class="keyword">this</span> is client independent!!!
                N INT           # maps slave channel to client channel N
        }
        slowptr BOOL            # slow but more precise pointer updates
}
</pre></div><h3><a class="anchor" id="pcm_plugins_dshare_funcref">
Function reference</a></h3>
<ul>
<li>
<a class="el" href="pcm__dshare_8c.html#a88bec432614f2a75100c33ed8dfd97b6" title="Creates a new dshare PCM.">snd_pcm_dshare_open()</a> </li>
<li>
<a class="el" href="pcm__dshare_8c.html#ae837c9fab4f6e2e0b08aa7864c19901b" title="Creates a new dshare PCM.">_snd_pcm_dshare_open()</a> </li>
</ul>
<h2><a class="anchor" id="pcm_plugins_dsnoop">
Plugin: dsnoop</a></h2>
<p>This plugin splits one capture stream to more. It works the reverse way of <a class="el" href="pcm_plugins.html#pcm_plugins_dmix">dmix plugin</a>, reading the shared capture buffer from many clients concurrently. The meaning of parameters below are almost identical with dmix plugin.</p>
<div class="fragment"><pre class="fragment">pcm.name {
        type dsnoop             # Direct snoop
        ipc_key INT             # unique IPC key
        ipc_key_add_uid BOOL    # add current uid to unique IPC key
        ipc_perm INT            # IPC permissions (octal, <span class="keywordflow">default</span> 0600)
        slave STR
        <span class="preprocessor"># or</span>
<span class="preprocessor"></span>        slave {                 # Slave definition
                pcm STR         # slave PCM name
<span class="preprocessor">                # or</span>
<span class="preprocessor"></span>                pcm { }         # slave PCM definition
                format STR      # format definition
                rate INT        # rate definition
                channels INT
                period_time INT # in usec
<span class="preprocessor">                # or</span>
<span class="preprocessor"></span>                period_size INT # in bytes
                buffer_time INT # in usec
<span class="preprocessor">                # or</span>
<span class="preprocessor"></span>                buffer_size INT # in bytes
                periods INT     # when buffer_size or buffer_time is not specified
        }
        bindings {              # note: <span class="keyword">this</span> is client independent!!!
                N INT           # maps slave channel to client channel N
        }
        slowptr BOOL            # slow but more precise pointer updates
}
</pre></div><h3><a class="anchor" id="pcm_plugins_dsnoop_funcref">
Function reference</a></h3>
<ul>
<li>
<a class="el" href="pcm__dsnoop_8c.html#a8cb7e3979f25d99e74e7a1e6d016436e" title="Creates a new dsnoop PCM.">snd_pcm_dsnoop_open()</a> </li>
<li>
<a class="el" href="pcm__dsnoop_8c.html#a6f504effb6bc99326e94e3450602cd37" title="Creates a new dsnoop PCM.">_snd_pcm_dsnoop_open()</a> </li>
</ul>
<h2><a class="anchor" id="pcm_plugins_ladpsa">
Plugin: LADSPA &lt;-&gt; ALSA</a></h2>
<p>This plugin allows to apply a set of LADPSA plugins. The input and output format is always <a class="el" href="group___p_c_m.html#ggaa14b7f26877a812acbb39811364177f8a7d9fd83c6ff5be7a9cde4b0673b64bf0">SND_PCM_FORMAT_FLOAT</a> (note: this type can be either little or big-endian depending on architecture).</p>
<p>The policy duplicate means that there must be only one binding definition for channel zero. This definition is automatically duplicated for all channels. If the LADSPA plugin has multiple audio inputs or outputs the policy duplicate is automatically switched to policy none.</p>
<p>The plugin serialization works as expected. You can eventually use more channels (inputs / outputs) inside the LADPSA plugin chain than processed in the ALSA plugin chain. If ALSA channel does not exist for given LADSPA input audio port, zero samples are given to this LADSPA port. On the output side (ALSA next plugin input), the valid channels are checked, too. If specific ALSA channel does not exist, the LADSPA output port is connected to a dummy sample area.</p>
<p>Instances of LADSPA plugins are created dynamically.</p>
<div class="fragment"><pre class="fragment">pcm.name {
        type ladspa             # ALSA&lt;-&gt;LADSPA PCM
        slave STR               # Slave name
<span class="preprocessor">        # or</span>
<span class="preprocessor"></span>        slave {                 # Slave definition
                pcm STR         # Slave PCM name
<span class="preprocessor">                # or</span>
<span class="preprocessor"></span>                pcm { }         # Slave PCM definition
        }
        [channels INT]          # count input channels (input to LADSPA plugin chain)
        [path STR]              # Path (directory) with LADSPA plugins
        plugins |               <span class="preprocessor"># Definition for both directions</span>
<span class="preprocessor"></span>        playback_plugins |      # Definition <span class="keywordflow">for</span> playback direction
        capture_plugins {       # Definition <span class="keywordflow">for</span> capture direction
                N {             # Configuration <span class="keywordflow">for</span> LADPSA plugin N
                        [<span class="keywordtype">id</span> INT]        # LADSPA plugin ID (<span class="keywordflow">for</span> example 1043)
                        [label STR]     # LADSPA plugin label (<span class="keywordflow">for</span> example <span class="stringliteral">&apos;delay_5s&apos;</span>)
                        [filename STR]  # Full filename of .so library with LADSPA plugin code
                        [policy STR]    # Policy can be <span class="stringliteral">&apos;none&apos;</span> or <span class="stringliteral">&apos;duplicate&apos;</span>
                        input | output {
                                bindings {
                                        C INT or STR    # C - channel, INT - audio port index, STR - audio port name
                                }
                                controls {
<span class="preprocessor">                                        # valid only in the input block</span>
<span class="preprocessor"></span>                                        I INT or REAL   # I - control port index, INT or REAL - control value
<span class="preprocessor">                                        # or</span>
<span class="preprocessor"></span>                                        STR INT or REAL # STR - control port name, INT or REAL - control value
                                }
                        }
                }
        }
}
</pre></div><h3><a class="anchor" id="pcm_plugins_ladspa_funcref">
Function reference</a></h3>
<ul>
<li>
<a class="el" href="pcm__ladspa_8c.html#adcc43e9aeb068d3f8e1cd17d7f8a92cc" title="Creates a new LADSPA&lt;-&gt;ALSA Plugin.">snd_pcm_ladspa_open()</a> </li>
<li>
<a class="el" href="pcm__ladspa_8c.html#af310f491d26253256cdf8589334a64d2" title="Creates a new LADSPA&lt;-&gt;ALSA PCM.">_snd_pcm_ladspa_open()</a> </li>
</ul>
<h2><a class="anchor" id="pcm_plugins_asym">
Plugin: asym</a></h2>
<p>This plugin is a combination of playback and capture PCM streams. Slave PCMs can be defined asymmetrically for both directions.</p>
<div class="fragment"><pre class="fragment">pcm.name {
        type asym               # Asym PCM
        playback STR            # Playback slave name
<span class="preprocessor">        # or</span>
<span class="preprocessor"></span>        playback {              # Playback slave definition
                pcm STR         # Slave PCM name
<span class="preprocessor">                # or</span>
<span class="preprocessor"></span>                pcm { }         # Slave PCM definition
        }
        capture STR             # Capture slave name
<span class="preprocessor">        # or</span>
<span class="preprocessor"></span>        capture {               # Capture slave definition
                pcm STR         # Slave PCM name
<span class="preprocessor">                # or</span>
<span class="preprocessor"></span>                pcm { }         # Slave PCM definition
        }
}
</pre></div><p>For example, you can combine a dmix plugin and a dsnoop plugin as as a single PCM for playback and capture directions, respectively. </p>
<div class="fragment"><pre class="fragment">pcm.duplex {
        type asym
        playback.pcm <span class="stringliteral">&quot;dmix&quot;</span>
        capture.pcm <span class="stringliteral">&quot;dsnoop&quot;</span>
}
</pre></div><p>By defining only a single direction, the resultant PCM becomes half-duplex.</p>
<h3><a class="anchor" id="pcm_plugins_asym_funcref">
Function reference</a></h3>
<ul>
<li>
<a class="el" href="pcm__asym_8c.html#a39d690db97257936622f800f1d81d306" title="Creates a new asym stream PCM.">_snd_pcm_asym_open()</a> </li>
</ul>
<h2><a class="anchor" id="pcm_plugins_iec958">
Plugin: IEC958</a></h2>
<p>This plugin converts 32bit IEC958 subframe samples to linear, or linear to 32bit IEC958 subframe samples.</p>
<div class="fragment"><pre class="fragment">pcm.name {
        type iec958             # IEC958 subframe conversion PCM
        slave STR               # Slave name
<span class="preprocessor">        # or</span>
<span class="preprocessor"></span>        slave {                 # Slave definition
                pcm STR         # Slave PCM name
<span class="preprocessor">                # or</span>
<span class="preprocessor"></span>                pcm { }         # Slave PCM definition
        }
        [status status-bytes]   # IEC958 status bits (given in byte array)
        <span class="preprocessor"># IEC958 preamble bits definitions</span>
<span class="preprocessor"></span><span class="preprocessor">        # B/M/W or Z/X/Y, B = block start, M = even subframe, W = odd subframe</span>
<span class="preprocessor"></span><span class="preprocessor">        # As default, Z = 0x08, Y = 0x04, X = 0x02</span>
<span class="preprocessor"></span>        [preamble.z or preamble.b val]
        [preamble.x or preamble.m val]
        [preamble.y or preamble.w val]
}
</pre></div><h3><a class="anchor" id="pcm_plugins_iec958_funcref">
Function reference</a></h3>
<ul>
<li>
<a class="el" href="pcm__iec958_8c.html#a5838de1fbcdbbc2debfd3995aa8f402b" title="Creates a new IEC958 subframe conversion PCM.">snd_pcm_iec958_open()</a> </li>
<li>
<a class="el" href="pcm__iec958_8c.html#aa2e0ac89b0b3190b5cf4c31c97e77620" title="Creates a new IEC958 subframe conversion PCM.">_snd_pcm_iec958_open()</a> </li>
</ul>
<h2><a class="anchor" id="pcm_plugins_softvol">
Plugin: Soft Volume</a></h2>
<p>This plugin applies the software volume attenuation. The format, rate and channels must match for both of source and destination.</p>
<p>When the control is stereo (count=2), the channels are assumed to be either mono, 2.0, 2.1, 4.0, 4.1, 5.1 or 7.1.</p>
<p>If the control already exists and it's a system control (i.e. no user-defined control), the plugin simply passes its slave without any changes.</p>
<div class="fragment"><pre class="fragment">pcm.name {
        type softvol            # Soft Volume conversion PCM
        slave STR               # Slave name
<span class="preprocessor">        # or</span>
<span class="preprocessor"></span>        slave {                 # Slave definition
                pcm STR         # Slave PCM name
<span class="preprocessor">                # or</span>
<span class="preprocessor"></span>                pcm { }         # Slave PCM definition
                [format STR]    # Slave format
        }
        control {
                name STR        # control element <span class="keywordtype">id</span> <span class="keywordtype">string</span>
                [card STR]      # control card index
                [iface STR]     # interface of the element
                [index INT]     # index of the element
                [device INT]    # device number of the element
                [subdevice INT] # subdevice number of the element
                [count INT]     # control channels 1 or 2 (<span class="keywordflow">default</span>: 2)
        }
        [min_dB REAL]           # minimal dB value (<span class="keywordflow">default</span>: -51.0)
        [max_dB REAL]           # maximal dB value (<span class="keywordflow">default</span>:   0.0)
        [resolution INT]        # resolution (<span class="keywordflow">default</span>: 256)
                                <span class="preprocessor"># resolution = 2 means a mute switch</span>
<span class="preprocessor">}</span>
</pre></div><h3><a class="anchor" id="pcm_plugins_softvol_funcref">
Function reference</a></h3>
<ul>
<li>
<a class="el" href="pcm__softvol_8c.html#ad569db39824bb0a31c73dd9d4948a4b7" title="Creates a new SoftVolume PCM.">snd_pcm_softvol_open()</a> </li>
<li>
<a class="el" href="pcm__softvol_8c.html#a4347460ac616c9a323681021c6498d0d" title="Creates a new Soft Volume PCM.">_snd_pcm_softvol_open()</a> </li>
</ul>
<h2><a class="anchor" id="pcm_plugins_null">
Plugin: Null</a></h2>
<p>This plugin discards contents of a PCM stream or creates a stream with zero samples.</p>
<p>Note: This implementation uses devices /dev/null (playback, must be writable) and /dev/full (capture, must be readable).</p>
<div class="fragment"><pre class="fragment">pcm.name {
        type null               # Null PCM
}
</pre></div><h3><a class="anchor" id="pcm_plugins_null_funcref">
Function reference</a></h3>
<ul>
<li>
<a class="el" href="pcm__empty_8c.html#a55df6f9b1b71d37ea91557cc26e8ab3a" title="Creates a new Empty PCM.">_snd_pcm_empty_open()</a> </li>
</ul>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&nbsp;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&nbsp;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&nbsp;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&nbsp;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&nbsp;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr size="1"><address style="text-align: right;"><small>
Generated for ALSA project - the C library reference by&nbsp;<a href="http://www.doxygen.org/
index.html"><img src="doxygen.png" alt="doxygen" align="middle" border="0"></a>
1.6.1</small></address>
</body>
</html>
