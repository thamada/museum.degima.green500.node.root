<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>dbus-cxx: DBus::Object Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css">
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link REL="SHORTCUT ICON" HREF="favicon.ico">
</head><body>
<center><a href="http://dbus-cxx.sourceforge.net"><img src="dbus-cxx-logo-med.png" alt="dbus-cxx logo" border="0"/></a></center>
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="classes.html"><span>Class&nbsp;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="namespaceDBus.html">DBus</a>::<a class="el" href="classDBus_1_1Object.html">Object</a>
  </div>
</div>
<div class="contents">
<h1>DBus::Object Class Reference<br/>
<small>
[<a class="el" href="group__local.html">Local Objects</a>,&nbsp;<a class="el" href="group__objects.html">Objects</a>]</small>
</h1><!-- doxytag: class="DBus::Object" --><!-- doxytag: inherits="DBus::ObjectPathHandler" -->
<p><code>#include &lt;<a class="el" href="object_8h_source.html">object.h</a>&gt;</code></p>

<p>Inherits DBus::ObjectPathHandler.</p>

<p><a href="classDBus_1_1Object-members.html">List of all members.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef DBusCxxPointer&lt; <a class="el" href="classDBus_1_1Object.html">Object</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDBus_1_1Object.html#a5bf674b9935ccede5a0cc5c9e5edfbc4">pointer</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Typedef to smart pointers to <a class="el" href="classDBus_1_1Object.html">Object</a>.  <a href="#a5bf674b9935ccede5a0cc5c9e5edfbc4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef std::multimap<br class="typebreak"/>
&lt; std::string, DBusCxxPointer<br class="typebreak"/>
&lt; <a class="el" href="classDBus_1_1Interface.html">Interface</a> &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDBus_1_1Object.html#a3dd597323a47e73d511c8d55e271fb83">Interfaces</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Typedef to the storage structure for an <code><a class="el" href="classDBus_1_1Object.html">Object</a></code> instance's interfaces.  <a href="#a3dd597323a47e73d511c8d55e271fb83"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef std::map&lt; std::string, <br class="typebreak"/>
<a class="el" href="classDBus_1_1Object.html#a5bf674b9935ccede5a0cc5c9e5edfbc4">Object::pointer</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDBus_1_1Object.html#a3deca17387532da99bdc7f1f23812046">Children</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Typedef to storage structure for an <code><a class="el" href="classDBus_1_1Object.html">Object</a></code> instance's children.  <a href="#a3deca17387532da99bdc7f1f23812046"></a><br/></td></tr>
<tr><td colspan="2"><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDBus_1_1Object.html#a22eb06f7f4cbed84f434d8a26b56dded">~Object</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDBus_1_1Object.html#abfe8e9f3bda2822e280be403db3cff23">register_with_connection</a> (DBusCxxPointer&lt; <a class="el" href="classDBus_1_1Connection.html">Connection</a> &gt; conn)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Extends base version to include registering signals.  <a href="#abfe8e9f3bda2822e280be403db3cff23"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classDBus_1_1Object.html#a3dd597323a47e73d511c8d55e271fb83">Interfaces</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDBus_1_1Object.html#a7e3c076e8ff3b7591eda4e9f1726b076">interfaces</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get all the interfaces associated with this <a class="el" href="classDBus_1_1Object.html">Object</a> instance.  <a href="#a7e3c076e8ff3b7591eda4e9f1726b076"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">DBusCxxPointer&lt; <a class="el" href="classDBus_1_1Interface.html">Interface</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDBus_1_1Object.html#a99e149e4850c4ab30218c5cf312c4728">interface</a> (const std::string &amp;name) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the first interface with the given name.  <a href="#a99e149e4850c4ab30218c5cf312c4728"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDBus_1_1Object.html#a34967617b0b59cfb8f861ec2dab7ad2e">add_interface</a> (DBusCxxPointer&lt; <a class="el" href="classDBus_1_1Interface.html">Interface</a> &gt; interface)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds the interface to this object.  <a href="#a34967617b0b59cfb8f861ec2dab7ad2e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">DBusCxxPointer&lt; <a class="el" href="classDBus_1_1Interface.html">Interface</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDBus_1_1Object.html#a76111752ea7a0d59549a9d95be03bd69">create_interface</a> (const std::string &amp;name)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates and adds the named interface to this object.  <a href="#a76111752ea7a0d59549a9d95be03bd69"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_return &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">DBusCxxPointer&lt; <a class="el" href="classDBus_1_1Method.html">Method</a><br class="typebreak"/>
&lt; T_return &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classDBus_1_1Object.html#a7408277265ae75a5b7a2d05a7d48e1f0">create_method</a> (const std::string &amp;method_name, sigc::slot0&lt; T_return &gt; slot)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a method with a signature based on the.  <a href="#a7408277265ae75a5b7a2d05a7d48e1f0"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_arg1 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">DBusCxxPointer&lt; <a class="el" href="classDBus_1_1Method.html">Method</a><br class="typebreak"/>
&lt; T_return, T_arg1 &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classDBus_1_1Object.html#aac92c1a9b8c88ea5d64cf19cd35913f6">create_method</a> (const std::string &amp;method_name, sigc::slot1&lt; T_return, T_arg1 &gt; slot)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a method with a signature based on the.  <a href="#aac92c1a9b8c88ea5d64cf19cd35913f6"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_arg1 , class T_arg2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">DBusCxxPointer&lt; <a class="el" href="classDBus_1_1Method.html">Method</a><br class="typebreak"/>
&lt; T_return, T_arg1, T_arg2 &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classDBus_1_1Object.html#a827c67edc2c85bf8e3e60decd8f6752d">create_method</a> (const std::string &amp;method_name, sigc::slot2&lt; T_return, T_arg1, T_arg2 &gt; slot)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a method with a signature based on the.  <a href="#a827c67edc2c85bf8e3e60decd8f6752d"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_arg1 , class T_arg2 , class T_arg3 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">DBusCxxPointer&lt; <a class="el" href="classDBus_1_1Method.html">Method</a><br class="typebreak"/>
&lt; T_return, T_arg1, T_arg2, <br class="typebreak"/>
T_arg3 &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classDBus_1_1Object.html#a38992ab4d31602f6d372f5107ba7724a">create_method</a> (const std::string &amp;method_name, sigc::slot3&lt; T_return, T_arg1, T_arg2, T_arg3 &gt; slot)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a method with a signature based on the.  <a href="#a38992ab4d31602f6d372f5107ba7724a"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">DBusCxxPointer&lt; <a class="el" href="classDBus_1_1Method.html">Method</a><br class="typebreak"/>
&lt; T_return, T_arg1, T_arg2, <br class="typebreak"/>
T_arg3, T_arg4 &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classDBus_1_1Object.html#a7e6e409b0e82c888a105c3623c9d1eac">create_method</a> (const std::string &amp;method_name, sigc::slot4&lt; T_return, T_arg1, T_arg2, T_arg3, T_arg4 &gt; slot)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a method with a signature based on the.  <a href="#a7e6e409b0e82c888a105c3623c9d1eac"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">DBusCxxPointer&lt; <a class="el" href="classDBus_1_1Method.html">Method</a><br class="typebreak"/>
&lt; T_return, T_arg1, T_arg2, <br class="typebreak"/>
T_arg3, T_arg4, T_arg5 &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classDBus_1_1Object.html#a1116a95b3d46b7a6a698af0321cf13cd">create_method</a> (const std::string &amp;method_name, sigc::slot5&lt; T_return, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 &gt; slot)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a method with a signature based on the.  <a href="#a1116a95b3d46b7a6a698af0321cf13cd"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">DBusCxxPointer&lt; <a class="el" href="classDBus_1_1Method.html">Method</a><br class="typebreak"/>
&lt; T_return, T_arg1, T_arg2, <br class="typebreak"/>
T_arg3, T_arg4, T_arg5, T_arg6 &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classDBus_1_1Object.html#ad7966d36426351c665d7286ecb0cf84e">create_method</a> (const std::string &amp;method_name, sigc::slot6&lt; T_return, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 &gt; slot)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a method with a signature based on the.  <a href="#ad7966d36426351c665d7286ecb0cf84e"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_arg7 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">DBusCxxPointer&lt; <a class="el" href="classDBus_1_1Method.html">Method</a><br class="typebreak"/>
&lt; T_return, T_arg1, T_arg2, <br class="typebreak"/>
T_arg3, T_arg4, T_arg5, T_arg6, <br class="typebreak"/>
T_arg7 &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classDBus_1_1Object.html#ae5fc471dae88bb323fda6e0f864ac3cc">create_method</a> (const std::string &amp;method_name, sigc::slot7&lt; T_return, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 &gt; slot)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a method with a signature based on the.  <a href="#ae5fc471dae88bb323fda6e0f864ac3cc"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_return &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">DBusCxxPointer&lt; <a class="el" href="classDBus_1_1Method.html">Method</a><br class="typebreak"/>
&lt; T_return &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classDBus_1_1Object.html#a14dcdcd85d77fa6f94fb131e2a0f8cc9">create_method</a> (const std::string &amp;interface_name, const std::string &amp;method_name, sigc::slot0&lt; T_return &gt; slot)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a method with a signature based on the.  <a href="#a14dcdcd85d77fa6f94fb131e2a0f8cc9"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_arg1 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">DBusCxxPointer&lt; <a class="el" href="classDBus_1_1Method.html">Method</a><br class="typebreak"/>
&lt; T_return, T_arg1 &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classDBus_1_1Object.html#affbe8c71acb9f7f88b1416e881e8f865">create_method</a> (const std::string &amp;interface_name, const std::string &amp;method_name, sigc::slot1&lt; T_return, T_arg1 &gt; slot)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a method with a signature based on the.  <a href="#affbe8c71acb9f7f88b1416e881e8f865"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_arg1 , class T_arg2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">DBusCxxPointer&lt; <a class="el" href="classDBus_1_1Method.html">Method</a><br class="typebreak"/>
&lt; T_return, T_arg1, T_arg2 &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classDBus_1_1Object.html#acf4a7c07cb235bf20c9409abe50ba10a">create_method</a> (const std::string &amp;interface_name, const std::string &amp;method_name, sigc::slot2&lt; T_return, T_arg1, T_arg2 &gt; slot)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a method with a signature based on the.  <a href="#acf4a7c07cb235bf20c9409abe50ba10a"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_arg1 , class T_arg2 , class T_arg3 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">DBusCxxPointer&lt; <a class="el" href="classDBus_1_1Method.html">Method</a><br class="typebreak"/>
&lt; T_return, T_arg1, T_arg2, <br class="typebreak"/>
T_arg3 &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classDBus_1_1Object.html#a6840db2997a11ef21daf450e4e79c8a1">create_method</a> (const std::string &amp;interface_name, const std::string &amp;method_name, sigc::slot3&lt; T_return, T_arg1, T_arg2, T_arg3 &gt; slot)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a method with a signature based on the.  <a href="#a6840db2997a11ef21daf450e4e79c8a1"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">DBusCxxPointer&lt; <a class="el" href="classDBus_1_1Method.html">Method</a><br class="typebreak"/>
&lt; T_return, T_arg1, T_arg2, <br class="typebreak"/>
T_arg3, T_arg4 &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classDBus_1_1Object.html#aaa52bd646710c6bf975e82f4271c72dc">create_method</a> (const std::string &amp;interface_name, const std::string &amp;method_name, sigc::slot4&lt; T_return, T_arg1, T_arg2, T_arg3, T_arg4 &gt; slot)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a method with a signature based on the.  <a href="#aaa52bd646710c6bf975e82f4271c72dc"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">DBusCxxPointer&lt; <a class="el" href="classDBus_1_1Method.html">Method</a><br class="typebreak"/>
&lt; T_return, T_arg1, T_arg2, <br class="typebreak"/>
T_arg3, T_arg4, T_arg5 &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classDBus_1_1Object.html#a02499155df754c3ce5e07030d303c5b5">create_method</a> (const std::string &amp;interface_name, const std::string &amp;method_name, sigc::slot5&lt; T_return, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 &gt; slot)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a method with a signature based on the.  <a href="#a02499155df754c3ce5e07030d303c5b5"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">DBusCxxPointer&lt; <a class="el" href="classDBus_1_1Method.html">Method</a><br class="typebreak"/>
&lt; T_return, T_arg1, T_arg2, <br class="typebreak"/>
T_arg3, T_arg4, T_arg5, T_arg6 &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classDBus_1_1Object.html#a8e086d945a28e313ef3e8ea09094fb71">create_method</a> (const std::string &amp;interface_name, const std::string &amp;method_name, sigc::slot6&lt; T_return, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 &gt; slot)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a method with a signature based on the.  <a href="#a8e086d945a28e313ef3e8ea09094fb71"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_arg7 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">DBusCxxPointer&lt; <a class="el" href="classDBus_1_1Method.html">Method</a><br class="typebreak"/>
&lt; T_return, T_arg1, T_arg2, <br class="typebreak"/>
T_arg3, T_arg4, T_arg5, T_arg6, <br class="typebreak"/>
T_arg7 &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classDBus_1_1Object.html#a4801c60792558541c412143a4fc24923">create_method</a> (const std::string &amp;interface_name, const std::string &amp;method_name, sigc::slot7&lt; T_return, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 &gt; slot)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a method with a signature based on the.  <a href="#a4801c60792558541c412143a4fc24923"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDBus_1_1Object.html#aabbcd801c315e2e88a39b6654bceedef">remove_interface</a> (const std::string &amp;name)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Removes the first interface found with the given name.  <a href="#aabbcd801c315e2e88a39b6654bceedef"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDBus_1_1Object.html#a9ec6e59d6996734e49cb53e01acfb767">has_interface</a> (const std::string &amp;name)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Test whether an <a class="el" href="classDBus_1_1Object.html">Object</a> has a named interface.  <a href="#a9ec6e59d6996734e49cb53e01acfb767"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">DBusCxxPointer&lt; <a class="el" href="classDBus_1_1Interface.html">Interface</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDBus_1_1Object.html#a24a9541b26674e59b02810781e3b7357">default_interface</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the default interface associated with this object.  <a href="#a24a9541b26674e59b02810781e3b7357"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDBus_1_1Object.html#a723b0433c976e9a7c5277034d3f9cd16">set_default_interface</a> (const std::string &amp;new_default_name)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the default interface to a specific name.  <a href="#a723b0433c976e9a7c5277034d3f9cd16"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDBus_1_1Object.html#af51bf37df4f3de1747a8bd54a0602596">remove_default_interface</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Removes the currently set (if any) default interface.  <a href="#af51bf37df4f3de1747a8bd54a0602596"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_return &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">DBusCxxPointer&lt; <a class="el" href="classDBus_1_1signal.html">signal</a><br class="typebreak"/>
&lt; T_return &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classDBus_1_1Object.html#afb49c0f2b22bac419253d41551a08eed">create_signal</a> (const std::string &amp;name)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a <a class="el" href="classDBus_1_1signal.html" title="Subclass of the numbered sigc::signal templates.">signal</a> with a return value (possibly <code>void</code> ) and 0 parameters and adds it to the default interface.  <a href="#afb49c0f2b22bac419253d41551a08eed"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_arg1 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">DBusCxxPointer&lt; <a class="el" href="classDBus_1_1signal.html">signal</a><br class="typebreak"/>
&lt; T_return, T_arg1 &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classDBus_1_1Object.html#a901c1d70ac1ee228c6245d71f738da50">create_signal</a> (const std::string &amp;name)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a <a class="el" href="classDBus_1_1signal.html" title="Subclass of the numbered sigc::signal templates.">signal</a> with a return value (possibly <code>void</code> ) and 1 parameters and adds it to the default interface.  <a href="#a901c1d70ac1ee228c6245d71f738da50"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_arg1 , class T_arg2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">DBusCxxPointer&lt; <a class="el" href="classDBus_1_1signal.html">signal</a><br class="typebreak"/>
&lt; T_return, T_arg1, T_arg2 &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classDBus_1_1Object.html#add6618a5d7948adafd265e9a1cde8d4a">create_signal</a> (const std::string &amp;name)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a <a class="el" href="classDBus_1_1signal.html" title="Subclass of the numbered sigc::signal templates.">signal</a> with a return value (possibly <code>void</code> ) and 2 parameters and adds it to the default interface.  <a href="#add6618a5d7948adafd265e9a1cde8d4a"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_arg1 , class T_arg2 , class T_arg3 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">DBusCxxPointer&lt; <a class="el" href="classDBus_1_1signal.html">signal</a><br class="typebreak"/>
&lt; T_return, T_arg1, T_arg2, <br class="typebreak"/>
T_arg3 &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classDBus_1_1Object.html#ad28a19a155aa3114eeff9114fdaaf67a">create_signal</a> (const std::string &amp;name)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a <a class="el" href="classDBus_1_1signal.html" title="Subclass of the numbered sigc::signal templates.">signal</a> with a return value (possibly <code>void</code> ) and 3 parameters and adds it to the default interface.  <a href="#ad28a19a155aa3114eeff9114fdaaf67a"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">DBusCxxPointer&lt; <a class="el" href="classDBus_1_1signal.html">signal</a><br class="typebreak"/>
&lt; T_return, T_arg1, T_arg2, <br class="typebreak"/>
T_arg3, T_arg4 &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classDBus_1_1Object.html#a8e2678176add1c8aa0d2836fc3a2ad64">create_signal</a> (const std::string &amp;name)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a <a class="el" href="classDBus_1_1signal.html" title="Subclass of the numbered sigc::signal templates.">signal</a> with a return value (possibly <code>void</code> ) and 4 parameters and adds it to the default interface.  <a href="#a8e2678176add1c8aa0d2836fc3a2ad64"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">DBusCxxPointer&lt; <a class="el" href="classDBus_1_1signal.html">signal</a><br class="typebreak"/>
&lt; T_return, T_arg1, T_arg2, <br class="typebreak"/>
T_arg3, T_arg4, T_arg5 &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classDBus_1_1Object.html#a985156ff30afb5ec17e60a998acaf52a">create_signal</a> (const std::string &amp;name)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a <a class="el" href="classDBus_1_1signal.html" title="Subclass of the numbered sigc::signal templates.">signal</a> with a return value (possibly <code>void</code> ) and 5 parameters and adds it to the default interface.  <a href="#a985156ff30afb5ec17e60a998acaf52a"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">DBusCxxPointer&lt; <a class="el" href="classDBus_1_1signal.html">signal</a><br class="typebreak"/>
&lt; T_return, T_arg1, T_arg2, <br class="typebreak"/>
T_arg3, T_arg4, T_arg5, T_arg6 &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classDBus_1_1Object.html#a7a0d76560b0f1a85860d6d97e15cc298">create_signal</a> (const std::string &amp;name)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a <a class="el" href="classDBus_1_1signal.html" title="Subclass of the numbered sigc::signal templates.">signal</a> with a return value (possibly <code>void</code> ) and 6 parameters and adds it to the default interface.  <a href="#a7a0d76560b0f1a85860d6d97e15cc298"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_arg7 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">DBusCxxPointer&lt; <a class="el" href="classDBus_1_1signal.html">signal</a><br class="typebreak"/>
&lt; T_return, T_arg1, T_arg2, <br class="typebreak"/>
T_arg3, T_arg4, T_arg5, T_arg6, <br class="typebreak"/>
T_arg7 &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classDBus_1_1Object.html#abd765c8245be91aca0769ae9763770fe">create_signal</a> (const std::string &amp;name)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a <a class="el" href="classDBus_1_1signal.html" title="Subclass of the numbered sigc::signal templates.">signal</a> with a return value (possibly <code>void</code> ) and 7 parameters and adds it to the default interface.  <a href="#abd765c8245be91aca0769ae9763770fe"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_return &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">DBusCxxPointer&lt; <a class="el" href="classDBus_1_1signal.html">signal</a><br class="typebreak"/>
&lt; T_return &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classDBus_1_1Object.html#aedfeed0bd72f4b2f9999385d4a549330">create_signal</a> (const std::string &amp;iface, const std::string &amp;name)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a <a class="el" href="classDBus_1_1signal.html" title="Subclass of the numbered sigc::signal templates.">signal</a> with a return value (possibly <code>void</code> ) and 0 parameters and adds it to the named interface.  <a href="#aedfeed0bd72f4b2f9999385d4a549330"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_arg1 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">DBusCxxPointer&lt; <a class="el" href="classDBus_1_1signal.html">signal</a><br class="typebreak"/>
&lt; T_return, T_arg1 &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classDBus_1_1Object.html#a28397bbcb2c498ead9fe268ab60388bb">create_signal</a> (const std::string &amp;iface, const std::string &amp;name)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a <a class="el" href="classDBus_1_1signal.html" title="Subclass of the numbered sigc::signal templates.">signal</a> with a return value (possibly <code>void</code> ) and 1 parameters and adds it to the named interface.  <a href="#a28397bbcb2c498ead9fe268ab60388bb"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_arg1 , class T_arg2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">DBusCxxPointer&lt; <a class="el" href="classDBus_1_1signal.html">signal</a><br class="typebreak"/>
&lt; T_return, T_arg1, T_arg2 &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classDBus_1_1Object.html#aa76832622995ef0672a83d9435c140d4">create_signal</a> (const std::string &amp;iface, const std::string &amp;name)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a <a class="el" href="classDBus_1_1signal.html" title="Subclass of the numbered sigc::signal templates.">signal</a> with a return value (possibly <code>void</code> ) and 2 parameters and adds it to the named interface.  <a href="#aa76832622995ef0672a83d9435c140d4"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_arg1 , class T_arg2 , class T_arg3 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">DBusCxxPointer&lt; <a class="el" href="classDBus_1_1signal.html">signal</a><br class="typebreak"/>
&lt; T_return, T_arg1, T_arg2, <br class="typebreak"/>
T_arg3 &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classDBus_1_1Object.html#a64fdf15015737af989703c80bda8f8a1">create_signal</a> (const std::string &amp;iface, const std::string &amp;name)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a <a class="el" href="classDBus_1_1signal.html" title="Subclass of the numbered sigc::signal templates.">signal</a> with a return value (possibly <code>void</code> ) and 3 parameters and adds it to the named interface.  <a href="#a64fdf15015737af989703c80bda8f8a1"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">DBusCxxPointer&lt; <a class="el" href="classDBus_1_1signal.html">signal</a><br class="typebreak"/>
&lt; T_return, T_arg1, T_arg2, <br class="typebreak"/>
T_arg3, T_arg4 &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classDBus_1_1Object.html#a86d3c1048106ef882901ddf7fb405b2b">create_signal</a> (const std::string &amp;iface, const std::string &amp;name)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a <a class="el" href="classDBus_1_1signal.html" title="Subclass of the numbered sigc::signal templates.">signal</a> with a return value (possibly <code>void</code> ) and 4 parameters and adds it to the named interface.  <a href="#a86d3c1048106ef882901ddf7fb405b2b"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">DBusCxxPointer&lt; <a class="el" href="classDBus_1_1signal.html">signal</a><br class="typebreak"/>
&lt; T_return, T_arg1, T_arg2, <br class="typebreak"/>
T_arg3, T_arg4, T_arg5 &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classDBus_1_1Object.html#a5ebb06f97931bfa7786df4a1b5fbef4f">create_signal</a> (const std::string &amp;iface, const std::string &amp;name)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a <a class="el" href="classDBus_1_1signal.html" title="Subclass of the numbered sigc::signal templates.">signal</a> with a return value (possibly <code>void</code> ) and 5 parameters and adds it to the named interface.  <a href="#a5ebb06f97931bfa7786df4a1b5fbef4f"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">DBusCxxPointer&lt; <a class="el" href="classDBus_1_1signal.html">signal</a><br class="typebreak"/>
&lt; T_return, T_arg1, T_arg2, <br class="typebreak"/>
T_arg3, T_arg4, T_arg5, T_arg6 &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classDBus_1_1Object.html#ab8077d318561fcf7afe00cdcb3dc66c0">create_signal</a> (const std::string &amp;iface, const std::string &amp;name)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a <a class="el" href="classDBus_1_1signal.html" title="Subclass of the numbered sigc::signal templates.">signal</a> with a return value (possibly <code>void</code> ) and 6 parameters and adds it to the named interface.  <a href="#ab8077d318561fcf7afe00cdcb3dc66c0"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_arg7 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">DBusCxxPointer&lt; <a class="el" href="classDBus_1_1signal.html">signal</a><br class="typebreak"/>
&lt; T_return, T_arg1, T_arg2, <br class="typebreak"/>
T_arg3, T_arg4, T_arg5, T_arg6, <br class="typebreak"/>
T_arg7 &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classDBus_1_1Object.html#abeb313fbd7d5952ee6ebcbfd6420d5c3">create_signal</a> (const std::string &amp;iface, const std::string &amp;name)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a <a class="el" href="classDBus_1_1signal.html" title="Subclass of the numbered sigc::signal templates.">signal</a> with a return value (possibly <code>void</code> ) and 7 parameters and adds it to the named interface.  <a href="#abeb313fbd7d5952ee6ebcbfd6420d5c3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classDBus_1_1Object.html#a3deca17387532da99bdc7f1f23812046">Children</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDBus_1_1Object.html#a4525b72bf8df7a7cd2e1182b98b76590">children</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the children associated with this object instance.  <a href="#a4525b72bf8df7a7cd2e1182b98b76590"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDBus_1_1Object.html#a5bf674b9935ccede5a0cc5c9e5edfbc4">Object::pointer</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDBus_1_1Object.html#aada390e421f05f39135324a88fc3a97e">child</a> (const std::string &amp;name) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get a named child of this object.  <a href="#aada390e421f05f39135324a88fc3a97e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDBus_1_1Object.html#a059f7709b0cc19d84ebca2236c717d63">add_child</a> (const std::string &amp;name, <a class="el" href="classDBus_1_1Object.html#a5bf674b9935ccede5a0cc5c9e5edfbc4">Object::pointer</a> child, bool force=false)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add an object as a child with a specified name This method will fail if the object already has a child with the specified name and <code>force</code> is not set.  <a href="#a059f7709b0cc19d84ebca2236c717d63"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDBus_1_1Object.html#a3515d2b48bd3f14aba2a06d77572d4cb">remove_child</a> (const std::string &amp;name)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Remove the named child from this object.  <a href="#a3515d2b48bd3f14aba2a06d77572d4cb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDBus_1_1Object.html#a997b73a0c9f716ef61e4252f38e04488">has_child</a> (const std::string &amp;name) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Test whether an object has a child with a specified name.  <a href="#a997b73a0c9f716ef61e4252f38e04488"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDBus_1_1Object.html#a78b4980a18d58124f44dfcf56d5f0055">introspect</a> (int space_depth=0) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a <a class="el" href="namespaceDBus.html">DBus</a> XML description of this interface.  <a href="#a78b4980a18d58124f44dfcf56d5f0055"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sigc::signal&lt; void, <br class="typebreak"/>
DBusCxxPointer&lt; <a class="el" href="classDBus_1_1Interface.html">Interface</a> &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDBus_1_1Object.html#a9e89d67b4b8edb63cbda1bba602abc5e">signal_interface_added</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Signal emitted when an interface is added to this object.  <a href="#a9e89d67b4b8edb63cbda1bba602abc5e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sigc::signal&lt; void, <br class="typebreak"/>
DBusCxxPointer&lt; <a class="el" href="classDBus_1_1Interface.html">Interface</a> &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDBus_1_1Object.html#a47036e8bdd3468e2903ae33dfe5361e8">signal_interface_removed</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Signal emitted when an interface is removed from this object.  <a href="#a47036e8bdd3468e2903ae33dfe5361e8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sigc::signal&lt; void, <br class="typebreak"/>
DBusCxxPointer&lt; <a class="el" href="classDBus_1_1Interface.html">Interface</a> &gt;<br class="typebreak"/>
,DBusCxxPointer&lt; <a class="el" href="classDBus_1_1Interface.html">Interface</a> &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDBus_1_1Object.html#a66d62aab742803c50168e18115194bf7">signal_default_interface_changed</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Signal emitted when the default interface of this object is changed.  <a href="#a66d62aab742803c50168e18115194bf7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceDBus.html#a7c6b6b3408e5c53b20f8384b0c931eb0">HandlerResult</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDBus_1_1Object.html#a8628e3194e1d927bf483dc6d0ce6ee9b">handle_message</a> (DBusCxxPointer&lt; <a class="el" href="classDBus_1_1Connection.html">Connection</a> &gt; conn, <a class="el" href="classDBus_1_1Message.html#a30b9cd71b63f5c0b5b97c4cff35b1a69">Message::const_pointer</a> msg)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Handles the specified message on the specified connection.  <a href="#a8628e3194e1d927bf483dc6d0ce6ee9b"></a><br/></td></tr>
<tr><td colspan="2"><h2>Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classDBus_1_1Object.html#a5bf674b9935ccede5a0cc5c9e5edfbc4">pointer</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDBus_1_1Object.html#a0b8123fcd7da0638a6fa6d9f48d0102e">create</a> (const std::string &amp;path=std::string(), <a class="el" href="namespaceDBus.html#a5d4886d2a1b758bd4cb4c8fd87b1b849">PrimaryFallback</a> pf=PRIMARY)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a named <a class="el" href="classDBus_1_1Object.html">Object</a> that will register as a primary or fallback handler.  <a href="#a0b8123fcd7da0638a6fa6d9f48d0102e"></a><br/></td></tr>
<tr><td colspan="2"><h2>Protected Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef std::map<br class="typebreak"/>
&lt; DBusCxxPointer&lt; <a class="el" href="classDBus_1_1Interface.html">Interface</a> &gt;<br class="typebreak"/>
,sigc::connection &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDBus_1_1Object.html#a5389375b09c7c05a0f03af84da24ba6f">InterfaceSignalNameConnections</a></td></tr>
<tr><td colspan="2"><h2>Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDBus_1_1Object.html#a2dc063018105e5ddfe1df51f93659c28">Object</a> (const std::string &amp;path, <a class="el" href="namespaceDBus.html#a5d4886d2a1b758bd4cb4c8fd87b1b849">PrimaryFallback</a> pf=PRIMARY)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This class has a protected constructor.  <a href="#a2dc063018105e5ddfe1df51f93659c28"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDBus_1_1Object.html#a0fb58727e387a7e00d4f53f0793e805e">on_interface_name_changed</a> (const std::string &amp;oldname, const std::string &amp;newname, DBusCxxPointer&lt; <a class="el" href="classDBus_1_1Interface.html">Interface</a> &gt; interface)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Callback point that updates the interface name map when an interface changes its name.  <a href="#a0fb58727e387a7e00d4f53f0793e805e"></a><br/></td></tr>
<tr><td colspan="2"><h2>Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDBus_1_1Object.html#a3deca17387532da99bdc7f1f23812046">Children</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDBus_1_1Object.html#a3f713d2810dab3129e5dc8f3bb51f495">m_children</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">pthread_rwlock_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDBus_1_1Object.html#a74374aa2b53adad6cb6da0d7b16f5306">m_interfaces_rwlock</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">pthread_mutex_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDBus_1_1Object.html#a684bfb2a817c1ef979753ada9b5e02f3">m_name_mutex</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDBus_1_1Object.html#a3dd597323a47e73d511c8d55e271fb83">Interfaces</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDBus_1_1Object.html#a43fa20c2b2547eb1463e07f4bb2a8ff9">m_interfaces</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">DBusCxxPointer&lt; <a class="el" href="classDBus_1_1Interface.html">Interface</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDBus_1_1Object.html#ad3b564bf7c2079dbe307543145de4474">m_default_interface</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sigc::signal&lt; void, <br class="typebreak"/>
DBusCxxPointer&lt; <a class="el" href="classDBus_1_1Interface.html">Interface</a> &gt;<br class="typebreak"/>
,DBusCxxPointer&lt; <a class="el" href="classDBus_1_1Interface.html">Interface</a> &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDBus_1_1Object.html#a79375a3991daa872acbed92cebd634a1">m_signal_default_interface_changed</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sigc::signal&lt; void, <br class="typebreak"/>
DBusCxxPointer&lt; <a class="el" href="classDBus_1_1Interface.html">Interface</a> &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDBus_1_1Object.html#a313ca46702beaa5b2de7ba9f199b58e9">m_signal_interface_added</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sigc::signal&lt; void, <br class="typebreak"/>
DBusCxxPointer&lt; <a class="el" href="classDBus_1_1Interface.html">Interface</a> &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDBus_1_1Object.html#a1cd04dd8c3d1dc8eb3e24a8c669e3418">m_signal_interface_removed</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDBus_1_1Object.html#a5389375b09c7c05a0f03af84da24ba6f">InterfaceSignalNameConnections</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDBus_1_1Object.html#aeadf56908734af799a62a2797f2f5cc9">m_interface_signal_name_connections</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000003">Todo:</a></b></dt><dd>TODO rethink whether it might be beneficial to have multiple connections for one object</dd></dl>
<dl class="author"><dt><b>Author:</b></dt><dd>Rick L Vinyard Jr &lt;<a href="mailto:rvinyard@cs.nmsu.edu">rvinyard@cs.nmsu.edu</a>&gt; </dd></dl>
<dl><dt><b>Examples: </b></dt><dd>
<p><a class="el" href="calculator__server_8cpp-example.html#_a1">calculator_server.cpp</a>, <a class="el" href="callee__object__inherited_8cpp-example.html#_a0">callee_object_inherited.cpp</a>, and <a class="el" href="signal__emitter__object_8cpp-example.html#_a0">signal_emitter_object.cpp</a>.</p>
</dd>
</dl><hr/><h2>Member Typedef Documentation</h2>
<a class="anchor" id="a3deca17387532da99bdc7f1f23812046"></a><!-- doxytag: member="DBus::Object::Children" ref="a3deca17387532da99bdc7f1f23812046" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::map&lt;std::string, <a class="el" href="classDBus_1_1Object.html#a5bf674b9935ccede5a0cc5c9e5edfbc4">Object::pointer</a>&gt; <a class="el" href="classDBus_1_1Object.html#a3deca17387532da99bdc7f1f23812046">DBus::Object::Children</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Typedef to storage structure for an <code><a class="el" href="classDBus_1_1Object.html">Object</a></code> instance's children. </p>
<p>The <em>key</em> is the child's name and the <em>value</em> </p>
<p><b>Data</b> <b>Structure</b> - map: an object's children must be uniquely named <b>Key</b> - child name <b>Value</b> -smart pointer to a child object.</p>
<p>Can access <em>type</em> as <code><a class="el" href="classDBus_1_1Object.html#a3deca17387532da99bdc7f1f23812046" title="Typedef to storage structure for an Object instance&#39;s children.">Object::Children</a></code> </p>

</div>
</div>
<a class="anchor" id="a3dd597323a47e73d511c8d55e271fb83"></a><!-- doxytag: member="DBus::Object::Interfaces" ref="a3dd597323a47e73d511c8d55e271fb83" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::multimap&lt;std::string, DBusCxxPointer&lt;<a class="el" href="classDBus_1_1Interface.html">Interface</a>&gt; &gt; <a class="el" href="classDBus_1_1Object.html#a3dd597323a47e73d511c8d55e271fb83">DBus::Object::Interfaces</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Typedef to the storage structure for an <code><a class="el" href="classDBus_1_1Object.html">Object</a></code> instance's interfaces. </p>
<p><b>Data</b> <b>Structure</b> - Multimap: There is no restriction that interfaces must be uniquely named <b>Key</b> - interface name <b>Value</b> -smart pointer to an interface.</p>
<p>Can access <em>type</em> as <code><a class="el" href="classDBus_1_1Object.html#a3dd597323a47e73d511c8d55e271fb83" title="Typedef to the storage structure for an Object instance&#39;s interfaces.">Object::Interfaces</a></code> </p>

</div>
</div>
<a class="anchor" id="a5389375b09c7c05a0f03af84da24ba6f"></a><!-- doxytag: member="DBus::Object::InterfaceSignalNameConnections" ref="a5389375b09c7c05a0f03af84da24ba6f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::map&lt;DBusCxxPointer&lt;<a class="el" href="classDBus_1_1Interface.html">Interface</a>&gt; ,sigc::connection&gt; <a class="el" href="classDBus_1_1Object.html#a5389375b09c7c05a0f03af84da24ba6f">DBus::Object::InterfaceSignalNameConnections</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a5bf674b9935ccede5a0cc5c9e5edfbc4"></a><!-- doxytag: member="DBus::Object::pointer" ref="a5bf674b9935ccede5a0cc5c9e5edfbc4" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef DBusCxxPointer&lt;<a class="el" href="classDBus_1_1Object.html">Object</a>&gt; <a class="el" href="classDBus_1_1Object.html#a5bf674b9935ccede5a0cc5c9e5edfbc4">DBus::Object::pointer</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Typedef to smart pointers to <a class="el" href="classDBus_1_1Object.html">Object</a>. </p>
<p>Can access <em>type</em> as <code><a class="el" href="classDBus_1_1Object.html#a5bf674b9935ccede5a0cc5c9e5edfbc4" title="Typedef to smart pointers to Object.">Object::pointer</a></code> </p>

<p>Reimplemented from <a class="el" href="classDBus_1_1MessageHandler.html#a4b7e2501eecf80bf23cb94657a3b2859">DBus::MessageHandler</a>.</p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="callee_8cpp-example.html#a5">callee.cpp</a>, <a class="el" href="callee__2_8cpp-example.html#a5">callee_2.cpp</a>, and <a class="el" href="callee__object_8cpp-example.html#a5">callee_object.cpp</a>.</dd>
</dl>
</div>
</div>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a2dc063018105e5ddfe1df51f93659c28"></a><!-- doxytag: member="DBus::Object::Object" ref="a2dc063018105e5ddfe1df51f93659c28" args="(const std::string &amp;path, PrimaryFallback pf=PRIMARY)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DBus::Object::Object </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceDBus.html#a5d4886d2a1b758bd4cb4c8fd87b1b849">PrimaryFallback</a>&nbsp;</td>
          <td class="paramname"> <em>pf</em> = <code>PRIMARY</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This class has a protected constructor. </p>
<p>Use the <code><a class="el" href="classDBus_1_1Object.html#a0b8123fcd7da0638a6fa6d9f48d0102e" title="Creates a named Object that will register as a primary or fallback handler.">create()</a></code> methods to obtain a smart pointer to a new instance. </p>

<p>References <a class="el" href="object_8h_source.html#l00661">m_interfaces_rwlock</a>, and <a class="el" href="object_8h_source.html#l00663">m_name_mutex</a>.</p>

<p>Referenced by <a class="el" href="object_8cpp_source.html#l00036">create()</a>.</p>

</div>
</div>
<a class="anchor" id="a22eb06f7f4cbed84f434d8a26b56dded"></a><!-- doxytag: member="DBus::Object::~Object" ref="a22eb06f7f4cbed84f434d8a26b56dded" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DBus::Object::~Object </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>References <a class="el" href="object_8h_source.html#l00661">m_interfaces_rwlock</a>, and <a class="el" href="object_8h_source.html#l00663">m_name_mutex</a>.</p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a059f7709b0cc19d84ebca2236c717d63"></a><!-- doxytag: member="DBus::Object::add_child" ref="a059f7709b0cc19d84ebca2236c717d63" args="(const std::string &amp;name, Object::pointer child, bool force=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool DBus::Object::add_child </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDBus_1_1Object.html#a5bf674b9935ccede5a0cc5c9e5edfbc4">Object::pointer</a>&nbsp;</td>
          <td class="paramname"> <em>child</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>force</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add an object as a child with a specified name This method will fail if the object already has a child with the specified name and <code>force</code> is not set. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>True</code> if the child was successfully added, <code>false</code> otherwise. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>The name to use for the child. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>child</em>&nbsp;</td><td>A smart pointer to an object to add as a child. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>force</em>&nbsp;</td><td>If <code>true</code> a child with the same name will be replaced. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="object_8cpp_source.html#l00263">has_child()</a>, and <a class="el" href="object_8h_source.html#l00659">m_children</a>.</p>

</div>
</div>
<a class="anchor" id="a34967617b0b59cfb8f861ec2dab7ad2e"></a><!-- doxytag: member="DBus::Object::add_interface" ref="a34967617b0b59cfb8f861ec2dab7ad2e" args="(DBusCxxPointer&lt; Interface &gt; interface)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool DBus::Object::add_interface </td>
          <td>(</td>
          <td class="paramtype">DBusCxxPointer&lt; <a class="el" href="classDBus_1_1Interface.html">Interface</a> &gt;&nbsp;</td>
          <td class="paramname"> <em>interface</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Adds the interface to this object. </p>

<p>Referenced by <a class="el" href="object_8cpp_source.html#l00124">create_interface()</a>.</p>

</div>
</div>
<a class="anchor" id="aada390e421f05f39135324a88fc3a97e"></a><!-- doxytag: member="DBus::Object::child" ref="aada390e421f05f39135324a88fc3a97e" args="(const std::string &amp;name) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDBus_1_1Object.html#a5bf674b9935ccede5a0cc5c9e5edfbc4">Object::pointer</a> DBus::Object::child </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get a named child of this object. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A smart pointer to a child with the specified name, or a null smart pointer if no child found. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>The name of the child to return </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="object_8h_source.html#l00659">m_children</a>.</p>

</div>
</div>
<a class="anchor" id="a4525b72bf8df7a7cd2e1182b98b76590"></a><!-- doxytag: member="DBus::Object::children" ref="a4525b72bf8df7a7cd2e1182b98b76590" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classDBus_1_1Object.html#a3deca17387532da99bdc7f1f23812046">Object::Children</a> &amp; DBus::Object::children </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the children associated with this object instance. </p>

<p>References <a class="el" href="object_8h_source.html#l00659">m_children</a>.</p>

</div>
</div>
<a class="anchor" id="a0b8123fcd7da0638a6fa6d9f48d0102e"></a><!-- doxytag: member="DBus::Object::create" ref="a0b8123fcd7da0638a6fa6d9f48d0102e" args="(const std::string &amp;path=std::string(), PrimaryFallback pf=PRIMARY)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDBus_1_1Object.html#a5bf674b9935ccede5a0cc5c9e5edfbc4">Object::pointer</a> DBus::Object::create </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>path</em> = <code>std::string()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceDBus.html#a5d4886d2a1b758bd4cb4c8fd87b1b849">PrimaryFallback</a>&nbsp;</td>
          <td class="paramname"> <em>pf</em> = <code>PRIMARY</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a named <a class="el" href="classDBus_1_1Object.html">Object</a> that will register as a primary or fallback handler. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>path</em>&nbsp;</td><td>The path the object will handle </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pf</em>&nbsp;</td><td>Determines whether the <a class="el" href="classDBus_1_1Object.html">Object</a> will registar as a primary or fallback handler (<em>default</em> = <code>PRIMARY</code>) </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="object_8cpp_source.html#l00029">Object()</a>.</p>

<p>Referenced by <a class="el" href="object_8cpp_source.html#l00124">create_interface()</a>.</p>

</div>
</div>
<a class="anchor" id="a76111752ea7a0d59549a9d95be03bd69"></a><!-- doxytag: member="DBus::Object::create_interface" ref="a76111752ea7a0d59549a9d95be03bd69" args="(const std::string &amp;name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDBus_1_1Interface.html#a553ac8bdc2476ede606e2ff0ee93067f">Interface::pointer</a> DBus::Object::create_interface </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates and adds the named interface to this object. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>the newly created interface </dd></dl>

<p>References <a class="el" href="classDBus_1_1Object.html#a34967617b0b59cfb8f861ec2dab7ad2e">add_interface()</a>, and <a class="el" href="object_8cpp_source.html#l00036">create()</a>.</p>

<p>Referenced by <a class="el" href="object_8h_source.html#l00699">create_method()</a>, and <a class="el" href="object_8h_source.html#l00957">create_signal()</a>.</p>

</div>
</div>
<a class="anchor" id="a4801c60792558541c412143a4fc24923"></a><!-- doxytag: member="DBus::Object::create_method" ref="a4801c60792558541c412143a4fc24923" args="(const std::string &amp;interface_name, const std::string &amp;method_name, sigc::slot7&lt; T_return, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 &gt; slot)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T_return , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_arg7 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">DBusCxxPointer&lt; <a class="el" href="classDBus_1_1Method.html">Method</a>&lt; T_return, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 &gt; &gt; DBus::Object::create_method </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>interface_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>method_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sigc::slot7&lt; T_return, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 &gt;&nbsp;</td>
          <td class="paramname"> <em>slot</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a method with a signature based on the. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>slot</em>&nbsp;</td><td>parameter signature and adds it to the named interface </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A smart pointer to the newly created method </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>slot</em>&nbsp;</td><td>This slot will be called with the given signature when the method is invoked</td></tr>
  </table>
  </dd>
</dl>
<p>Template parameters of the sigc::slot will determine the signature of the method created. </p>

<p>References <a class="el" href="object_8cpp_source.html#l00124">create_interface()</a>, and <a class="el" href="object_8cpp_source.html#l00066">interface()</a>.</p>

</div>
</div>
<a class="anchor" id="a8e086d945a28e313ef3e8ea09094fb71"></a><!-- doxytag: member="DBus::Object::create_method" ref="a8e086d945a28e313ef3e8ea09094fb71" args="(const std::string &amp;interface_name, const std::string &amp;method_name, sigc::slot6&lt; T_return, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 &gt; slot)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T_return , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">DBusCxxPointer&lt; <a class="el" href="classDBus_1_1Method.html">Method</a>&lt; T_return, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 &gt; &gt; DBus::Object::create_method </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>interface_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>method_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sigc::slot6&lt; T_return, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 &gt;&nbsp;</td>
          <td class="paramname"> <em>slot</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a method with a signature based on the. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>slot</em>&nbsp;</td><td>parameter signature and adds it to the named interface </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A smart pointer to the newly created method </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>slot</em>&nbsp;</td><td>This slot will be called with the given signature when the method is invoked</td></tr>
  </table>
  </dd>
</dl>
<p>Template parameters of the sigc::slot will determine the signature of the method created. </p>

<p>References <a class="el" href="object_8cpp_source.html#l00124">create_interface()</a>, and <a class="el" href="object_8cpp_source.html#l00066">interface()</a>.</p>

</div>
</div>
<a class="anchor" id="a02499155df754c3ce5e07030d303c5b5"></a><!-- doxytag: member="DBus::Object::create_method" ref="a02499155df754c3ce5e07030d303c5b5" args="(const std::string &amp;interface_name, const std::string &amp;method_name, sigc::slot5&lt; T_return, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 &gt; slot)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T_return , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">DBusCxxPointer&lt; <a class="el" href="classDBus_1_1Method.html">Method</a>&lt; T_return, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 &gt; &gt; DBus::Object::create_method </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>interface_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>method_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sigc::slot5&lt; T_return, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 &gt;&nbsp;</td>
          <td class="paramname"> <em>slot</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a method with a signature based on the. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>slot</em>&nbsp;</td><td>parameter signature and adds it to the named interface </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A smart pointer to the newly created method </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>slot</em>&nbsp;</td><td>This slot will be called with the given signature when the method is invoked</td></tr>
  </table>
  </dd>
</dl>
<p>Template parameters of the sigc::slot will determine the signature of the method created. </p>

<p>References <a class="el" href="object_8cpp_source.html#l00124">create_interface()</a>, and <a class="el" href="object_8cpp_source.html#l00066">interface()</a>.</p>

</div>
</div>
<a class="anchor" id="aaa52bd646710c6bf975e82f4271c72dc"></a><!-- doxytag: member="DBus::Object::create_method" ref="aaa52bd646710c6bf975e82f4271c72dc" args="(const std::string &amp;interface_name, const std::string &amp;method_name, sigc::slot4&lt; T_return, T_arg1, T_arg2, T_arg3, T_arg4 &gt; slot)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T_return , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">DBusCxxPointer&lt; <a class="el" href="classDBus_1_1Method.html">Method</a>&lt; T_return, T_arg1, T_arg2, T_arg3, T_arg4 &gt; &gt; DBus::Object::create_method </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>interface_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>method_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sigc::slot4&lt; T_return, T_arg1, T_arg2, T_arg3, T_arg4 &gt;&nbsp;</td>
          <td class="paramname"> <em>slot</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a method with a signature based on the. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>slot</em>&nbsp;</td><td>parameter signature and adds it to the named interface </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A smart pointer to the newly created method </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>slot</em>&nbsp;</td><td>This slot will be called with the given signature when the method is invoked</td></tr>
  </table>
  </dd>
</dl>
<p>Template parameters of the sigc::slot will determine the signature of the method created. </p>

<p>References <a class="el" href="object_8cpp_source.html#l00124">create_interface()</a>, and <a class="el" href="object_8cpp_source.html#l00066">interface()</a>.</p>

</div>
</div>
<a class="anchor" id="a6840db2997a11ef21daf450e4e79c8a1"></a><!-- doxytag: member="DBus::Object::create_method" ref="a6840db2997a11ef21daf450e4e79c8a1" args="(const std::string &amp;interface_name, const std::string &amp;method_name, sigc::slot3&lt; T_return, T_arg1, T_arg2, T_arg3 &gt; slot)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T_return , class T_arg1 , class T_arg2 , class T_arg3 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">DBusCxxPointer&lt; <a class="el" href="classDBus_1_1Method.html">Method</a>&lt; T_return, T_arg1, T_arg2, T_arg3 &gt; &gt; DBus::Object::create_method </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>interface_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>method_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sigc::slot3&lt; T_return, T_arg1, T_arg2, T_arg3 &gt;&nbsp;</td>
          <td class="paramname"> <em>slot</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a method with a signature based on the. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>slot</em>&nbsp;</td><td>parameter signature and adds it to the named interface </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A smart pointer to the newly created method </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>slot</em>&nbsp;</td><td>This slot will be called with the given signature when the method is invoked</td></tr>
  </table>
  </dd>
</dl>
<p>Template parameters of the sigc::slot will determine the signature of the method created. </p>

<p>References <a class="el" href="object_8cpp_source.html#l00124">create_interface()</a>, and <a class="el" href="object_8cpp_source.html#l00066">interface()</a>.</p>

</div>
</div>
<a class="anchor" id="acf4a7c07cb235bf20c9409abe50ba10a"></a><!-- doxytag: member="DBus::Object::create_method" ref="acf4a7c07cb235bf20c9409abe50ba10a" args="(const std::string &amp;interface_name, const std::string &amp;method_name, sigc::slot2&lt; T_return, T_arg1, T_arg2 &gt; slot)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T_return , class T_arg1 , class T_arg2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">DBusCxxPointer&lt; <a class="el" href="classDBus_1_1Method.html">Method</a>&lt; T_return, T_arg1, T_arg2 &gt; &gt; DBus::Object::create_method </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>interface_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>method_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sigc::slot2&lt; T_return, T_arg1, T_arg2 &gt;&nbsp;</td>
          <td class="paramname"> <em>slot</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a method with a signature based on the. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>slot</em>&nbsp;</td><td>parameter signature and adds it to the named interface </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A smart pointer to the newly created method </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>slot</em>&nbsp;</td><td>This slot will be called with the given signature when the method is invoked</td></tr>
  </table>
  </dd>
</dl>
<p>Template parameters of the sigc::slot will determine the signature of the method created. </p>

<p>References <a class="el" href="object_8cpp_source.html#l00124">create_interface()</a>, and <a class="el" href="object_8cpp_source.html#l00066">interface()</a>.</p>

</div>
</div>
<a class="anchor" id="affbe8c71acb9f7f88b1416e881e8f865"></a><!-- doxytag: member="DBus::Object::create_method" ref="affbe8c71acb9f7f88b1416e881e8f865" args="(const std::string &amp;interface_name, const std::string &amp;method_name, sigc::slot1&lt; T_return, T_arg1 &gt; slot)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T_return , class T_arg1 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">DBusCxxPointer&lt; <a class="el" href="classDBus_1_1Method.html">Method</a>&lt; T_return, T_arg1 &gt; &gt; DBus::Object::create_method </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>interface_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>method_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sigc::slot1&lt; T_return, T_arg1 &gt;&nbsp;</td>
          <td class="paramname"> <em>slot</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a method with a signature based on the. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>slot</em>&nbsp;</td><td>parameter signature and adds it to the named interface </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A smart pointer to the newly created method </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>slot</em>&nbsp;</td><td>This slot will be called with the given signature when the method is invoked</td></tr>
  </table>
  </dd>
</dl>
<p>Template parameters of the sigc::slot will determine the signature of the method created. </p>

<p>References <a class="el" href="object_8cpp_source.html#l00124">create_interface()</a>, and <a class="el" href="object_8cpp_source.html#l00066">interface()</a>.</p>

</div>
</div>
<a class="anchor" id="a14dcdcd85d77fa6f94fb131e2a0f8cc9"></a><!-- doxytag: member="DBus::Object::create_method" ref="a14dcdcd85d77fa6f94fb131e2a0f8cc9" args="(const std::string &amp;interface_name, const std::string &amp;method_name, sigc::slot0&lt; T_return &gt; slot)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T_return &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">DBusCxxPointer&lt; <a class="el" href="classDBus_1_1Method.html">Method</a>&lt; T_return &gt; &gt; DBus::Object::create_method </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>interface_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>method_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sigc::slot0&lt; T_return &gt;&nbsp;</td>
          <td class="paramname"> <em>slot</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a method with a signature based on the. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>slot</em>&nbsp;</td><td>parameter signature and adds it to the named interface </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A smart pointer to the newly created method </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>slot</em>&nbsp;</td><td>This slot will be called with the given signature when the method is invoked</td></tr>
  </table>
  </dd>
</dl>
<p>Template parameters of the sigc::slot will determine the signature of the method created. </p>

<p>References <a class="el" href="object_8cpp_source.html#l00124">create_interface()</a>, and <a class="el" href="object_8cpp_source.html#l00066">interface()</a>.</p>

</div>
</div>
<a class="anchor" id="ae5fc471dae88bb323fda6e0f864ac3cc"></a><!-- doxytag: member="DBus::Object::create_method" ref="ae5fc471dae88bb323fda6e0f864ac3cc" args="(const std::string &amp;method_name, sigc::slot7&lt; T_return, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 &gt; slot)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T_return , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_arg7 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">DBusCxxPointer&lt; <a class="el" href="classDBus_1_1Method.html">Method</a>&lt; T_return, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 &gt; &gt; DBus::Object::create_method </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>method_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sigc::slot7&lt; T_return, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 &gt;&nbsp;</td>
          <td class="paramname"> <em>slot</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a method with a signature based on the. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>slot</em>&nbsp;</td><td>parameter signature and adds it to the default interface </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A smart pointer to the newly created method </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>slot</em>&nbsp;</td><td>This slot will be called with the given signature when the method is invoked</td></tr>
  </table>
  </dd>
</dl>
<p>Template parameters of the sigc::slot will determine the signature of the method created. </p>

<p>References <a class="el" href="object_8cpp_source.html#l00124">create_interface()</a>, <a class="el" href="object_8h_source.html#l00667">m_default_interface</a>, and <a class="el" href="object_8cpp_source.html#l00199">set_default_interface()</a>.</p>

</div>
</div>
<a class="anchor" id="ad7966d36426351c665d7286ecb0cf84e"></a><!-- doxytag: member="DBus::Object::create_method" ref="ad7966d36426351c665d7286ecb0cf84e" args="(const std::string &amp;method_name, sigc::slot6&lt; T_return, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 &gt; slot)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T_return , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">DBusCxxPointer&lt; <a class="el" href="classDBus_1_1Method.html">Method</a>&lt; T_return, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 &gt; &gt; DBus::Object::create_method </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>method_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sigc::slot6&lt; T_return, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 &gt;&nbsp;</td>
          <td class="paramname"> <em>slot</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a method with a signature based on the. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>slot</em>&nbsp;</td><td>parameter signature and adds it to the default interface </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A smart pointer to the newly created method </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>slot</em>&nbsp;</td><td>This slot will be called with the given signature when the method is invoked</td></tr>
  </table>
  </dd>
</dl>
<p>Template parameters of the sigc::slot will determine the signature of the method created. </p>

<p>References <a class="el" href="object_8cpp_source.html#l00124">create_interface()</a>, <a class="el" href="object_8h_source.html#l00667">m_default_interface</a>, and <a class="el" href="object_8cpp_source.html#l00199">set_default_interface()</a>.</p>

</div>
</div>
<a class="anchor" id="a1116a95b3d46b7a6a698af0321cf13cd"></a><!-- doxytag: member="DBus::Object::create_method" ref="a1116a95b3d46b7a6a698af0321cf13cd" args="(const std::string &amp;method_name, sigc::slot5&lt; T_return, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 &gt; slot)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T_return , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">DBusCxxPointer&lt; <a class="el" href="classDBus_1_1Method.html">Method</a>&lt; T_return, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 &gt; &gt; DBus::Object::create_method </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>method_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sigc::slot5&lt; T_return, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 &gt;&nbsp;</td>
          <td class="paramname"> <em>slot</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a method with a signature based on the. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>slot</em>&nbsp;</td><td>parameter signature and adds it to the default interface </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A smart pointer to the newly created method </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>slot</em>&nbsp;</td><td>This slot will be called with the given signature when the method is invoked</td></tr>
  </table>
  </dd>
</dl>
<p>Template parameters of the sigc::slot will determine the signature of the method created. </p>

<p>References <a class="el" href="object_8cpp_source.html#l00124">create_interface()</a>, <a class="el" href="object_8h_source.html#l00667">m_default_interface</a>, and <a class="el" href="object_8cpp_source.html#l00199">set_default_interface()</a>.</p>

</div>
</div>
<a class="anchor" id="a7e6e409b0e82c888a105c3623c9d1eac"></a><!-- doxytag: member="DBus::Object::create_method" ref="a7e6e409b0e82c888a105c3623c9d1eac" args="(const std::string &amp;method_name, sigc::slot4&lt; T_return, T_arg1, T_arg2, T_arg3, T_arg4 &gt; slot)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T_return , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">DBusCxxPointer&lt; <a class="el" href="classDBus_1_1Method.html">Method</a>&lt; T_return, T_arg1, T_arg2, T_arg3, T_arg4 &gt; &gt; DBus::Object::create_method </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>method_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sigc::slot4&lt; T_return, T_arg1, T_arg2, T_arg3, T_arg4 &gt;&nbsp;</td>
          <td class="paramname"> <em>slot</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a method with a signature based on the. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>slot</em>&nbsp;</td><td>parameter signature and adds it to the default interface </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A smart pointer to the newly created method </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>slot</em>&nbsp;</td><td>This slot will be called with the given signature when the method is invoked</td></tr>
  </table>
  </dd>
</dl>
<p>Template parameters of the sigc::slot will determine the signature of the method created. </p>

<p>References <a class="el" href="object_8cpp_source.html#l00124">create_interface()</a>, <a class="el" href="object_8h_source.html#l00667">m_default_interface</a>, and <a class="el" href="object_8cpp_source.html#l00199">set_default_interface()</a>.</p>

</div>
</div>
<a class="anchor" id="a38992ab4d31602f6d372f5107ba7724a"></a><!-- doxytag: member="DBus::Object::create_method" ref="a38992ab4d31602f6d372f5107ba7724a" args="(const std::string &amp;method_name, sigc::slot3&lt; T_return, T_arg1, T_arg2, T_arg3 &gt; slot)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T_return , class T_arg1 , class T_arg2 , class T_arg3 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">DBusCxxPointer&lt; <a class="el" href="classDBus_1_1Method.html">Method</a>&lt; T_return, T_arg1, T_arg2, T_arg3 &gt; &gt; DBus::Object::create_method </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>method_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sigc::slot3&lt; T_return, T_arg1, T_arg2, T_arg3 &gt;&nbsp;</td>
          <td class="paramname"> <em>slot</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a method with a signature based on the. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>slot</em>&nbsp;</td><td>parameter signature and adds it to the default interface </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A smart pointer to the newly created method </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>slot</em>&nbsp;</td><td>This slot will be called with the given signature when the method is invoked</td></tr>
  </table>
  </dd>
</dl>
<p>Template parameters of the sigc::slot will determine the signature of the method created. </p>

<p>References <a class="el" href="object_8cpp_source.html#l00124">create_interface()</a>, <a class="el" href="object_8h_source.html#l00667">m_default_interface</a>, and <a class="el" href="object_8cpp_source.html#l00199">set_default_interface()</a>.</p>

</div>
</div>
<a class="anchor" id="a827c67edc2c85bf8e3e60decd8f6752d"></a><!-- doxytag: member="DBus::Object::create_method" ref="a827c67edc2c85bf8e3e60decd8f6752d" args="(const std::string &amp;method_name, sigc::slot2&lt; T_return, T_arg1, T_arg2 &gt; slot)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T_return , class T_arg1 , class T_arg2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">DBusCxxPointer&lt; <a class="el" href="classDBus_1_1Method.html">Method</a>&lt; T_return, T_arg1, T_arg2 &gt; &gt; DBus::Object::create_method </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>method_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sigc::slot2&lt; T_return, T_arg1, T_arg2 &gt;&nbsp;</td>
          <td class="paramname"> <em>slot</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a method with a signature based on the. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>slot</em>&nbsp;</td><td>parameter signature and adds it to the default interface </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A smart pointer to the newly created method </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>slot</em>&nbsp;</td><td>This slot will be called with the given signature when the method is invoked</td></tr>
  </table>
  </dd>
</dl>
<p>Template parameters of the sigc::slot will determine the signature of the method created. </p>

<p>References <a class="el" href="object_8cpp_source.html#l00124">create_interface()</a>, <a class="el" href="object_8h_source.html#l00667">m_default_interface</a>, and <a class="el" href="object_8cpp_source.html#l00199">set_default_interface()</a>.</p>

</div>
</div>
<a class="anchor" id="aac92c1a9b8c88ea5d64cf19cd35913f6"></a><!-- doxytag: member="DBus::Object::create_method" ref="aac92c1a9b8c88ea5d64cf19cd35913f6" args="(const std::string &amp;method_name, sigc::slot1&lt; T_return, T_arg1 &gt; slot)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T_return , class T_arg1 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">DBusCxxPointer&lt; <a class="el" href="classDBus_1_1Method.html">Method</a>&lt; T_return, T_arg1 &gt; &gt; DBus::Object::create_method </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>method_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sigc::slot1&lt; T_return, T_arg1 &gt;&nbsp;</td>
          <td class="paramname"> <em>slot</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a method with a signature based on the. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>slot</em>&nbsp;</td><td>parameter signature and adds it to the default interface </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A smart pointer to the newly created method </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>slot</em>&nbsp;</td><td>This slot will be called with the given signature when the method is invoked</td></tr>
  </table>
  </dd>
</dl>
<p>Template parameters of the sigc::slot will determine the signature of the method created. </p>

<p>References <a class="el" href="object_8cpp_source.html#l00124">create_interface()</a>, <a class="el" href="object_8h_source.html#l00667">m_default_interface</a>, and <a class="el" href="object_8cpp_source.html#l00199">set_default_interface()</a>.</p>

</div>
</div>
<a class="anchor" id="a7408277265ae75a5b7a2d05a7d48e1f0"></a><!-- doxytag: member="DBus::Object::create_method" ref="a7408277265ae75a5b7a2d05a7d48e1f0" args="(const std::string &amp;method_name, sigc::slot0&lt; T_return &gt; slot)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T_return &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">DBusCxxPointer&lt; <a class="el" href="classDBus_1_1Method.html">Method</a>&lt; T_return &gt; &gt; DBus::Object::create_method </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>method_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sigc::slot0&lt; T_return &gt;&nbsp;</td>
          <td class="paramname"> <em>slot</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a method with a signature based on the. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>slot</em>&nbsp;</td><td>parameter signature and adds it to the default interface </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A smart pointer to the newly created method </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>slot</em>&nbsp;</td><td>This slot will be called with the given signature when the method is invoked</td></tr>
  </table>
  </dd>
</dl>
<p>Template parameters of the sigc::slot will determine the signature of the method created. </p>

<p>References <a class="el" href="object_8cpp_source.html#l00124">create_interface()</a>, <a class="el" href="object_8h_source.html#l00667">m_default_interface</a>, and <a class="el" href="object_8cpp_source.html#l00199">set_default_interface()</a>.</p>

</div>
</div>
<a class="anchor" id="abeb313fbd7d5952ee6ebcbfd6420d5c3"></a><!-- doxytag: member="DBus::Object::create_signal" ref="abeb313fbd7d5952ee6ebcbfd6420d5c3" args="(const std::string &amp;iface, const std::string &amp;name)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T_return , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_arg7 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">DBusCxxPointer&lt;<a class="el" href="classDBus_1_1signal.html">signal</a>&lt;T_return, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7&gt; &gt; DBus::Object::create_signal </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>iface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a <a class="el" href="classDBus_1_1signal.html" title="Subclass of the numbered sigc::signal templates.">signal</a> with a return value (possibly <code>void</code> ) and 7 parameters and adds it to the named interface. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A smart pointer to the newly created <a class="el" href="classDBus_1_1signal.html" title="Subclass of the numbered sigc::signal templates.">signal</a></dd></dl>
<p>Template parameters for the <code><a class="el" href="classDBus_1_1Object.html#afb49c0f2b22bac419253d41551a08eed" title="Creates a signal with a return value (possibly void ) and 0 parameters and adds it...">create_signal()</a></code> call will determine the signature of the <a class="el" href="classDBus_1_1signal.html" title="Subclass of the numbered sigc::signal templates.">signal</a> created. </p>

</div>
</div>
<a class="anchor" id="ab8077d318561fcf7afe00cdcb3dc66c0"></a><!-- doxytag: member="DBus::Object::create_signal" ref="ab8077d318561fcf7afe00cdcb3dc66c0" args="(const std::string &amp;iface, const std::string &amp;name)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T_return , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">DBusCxxPointer&lt;<a class="el" href="classDBus_1_1signal.html">signal</a>&lt;T_return, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6&gt; &gt; DBus::Object::create_signal </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>iface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a <a class="el" href="classDBus_1_1signal.html" title="Subclass of the numbered sigc::signal templates.">signal</a> with a return value (possibly <code>void</code> ) and 6 parameters and adds it to the named interface. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A smart pointer to the newly created <a class="el" href="classDBus_1_1signal.html" title="Subclass of the numbered sigc::signal templates.">signal</a></dd></dl>
<p>Template parameters for the <code><a class="el" href="classDBus_1_1Object.html#afb49c0f2b22bac419253d41551a08eed" title="Creates a signal with a return value (possibly void ) and 0 parameters and adds it...">create_signal()</a></code> call will determine the signature of the <a class="el" href="classDBus_1_1signal.html" title="Subclass of the numbered sigc::signal templates.">signal</a> created. </p>

</div>
</div>
<a class="anchor" id="a5ebb06f97931bfa7786df4a1b5fbef4f"></a><!-- doxytag: member="DBus::Object::create_signal" ref="a5ebb06f97931bfa7786df4a1b5fbef4f" args="(const std::string &amp;iface, const std::string &amp;name)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T_return , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">DBusCxxPointer&lt;<a class="el" href="classDBus_1_1signal.html">signal</a>&lt;T_return, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5&gt; &gt; DBus::Object::create_signal </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>iface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a <a class="el" href="classDBus_1_1signal.html" title="Subclass of the numbered sigc::signal templates.">signal</a> with a return value (possibly <code>void</code> ) and 5 parameters and adds it to the named interface. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A smart pointer to the newly created <a class="el" href="classDBus_1_1signal.html" title="Subclass of the numbered sigc::signal templates.">signal</a></dd></dl>
<p>Template parameters for the <code><a class="el" href="classDBus_1_1Object.html#afb49c0f2b22bac419253d41551a08eed" title="Creates a signal with a return value (possibly void ) and 0 parameters and adds it...">create_signal()</a></code> call will determine the signature of the <a class="el" href="classDBus_1_1signal.html" title="Subclass of the numbered sigc::signal templates.">signal</a> created. </p>

</div>
</div>
<a class="anchor" id="a86d3c1048106ef882901ddf7fb405b2b"></a><!-- doxytag: member="DBus::Object::create_signal" ref="a86d3c1048106ef882901ddf7fb405b2b" args="(const std::string &amp;iface, const std::string &amp;name)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T_return , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">DBusCxxPointer&lt;<a class="el" href="classDBus_1_1signal.html">signal</a>&lt;T_return, T_arg1,T_arg2,T_arg3,T_arg4&gt; &gt; DBus::Object::create_signal </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>iface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a <a class="el" href="classDBus_1_1signal.html" title="Subclass of the numbered sigc::signal templates.">signal</a> with a return value (possibly <code>void</code> ) and 4 parameters and adds it to the named interface. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A smart pointer to the newly created <a class="el" href="classDBus_1_1signal.html" title="Subclass of the numbered sigc::signal templates.">signal</a></dd></dl>
<p>Template parameters for the <code><a class="el" href="classDBus_1_1Object.html#afb49c0f2b22bac419253d41551a08eed" title="Creates a signal with a return value (possibly void ) and 0 parameters and adds it...">create_signal()</a></code> call will determine the signature of the <a class="el" href="classDBus_1_1signal.html" title="Subclass of the numbered sigc::signal templates.">signal</a> created. </p>

</div>
</div>
<a class="anchor" id="a64fdf15015737af989703c80bda8f8a1"></a><!-- doxytag: member="DBus::Object::create_signal" ref="a64fdf15015737af989703c80bda8f8a1" args="(const std::string &amp;iface, const std::string &amp;name)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T_return , class T_arg1 , class T_arg2 , class T_arg3 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">DBusCxxPointer&lt;<a class="el" href="classDBus_1_1signal.html">signal</a>&lt;T_return, T_arg1,T_arg2,T_arg3&gt; &gt; DBus::Object::create_signal </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>iface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a <a class="el" href="classDBus_1_1signal.html" title="Subclass of the numbered sigc::signal templates.">signal</a> with a return value (possibly <code>void</code> ) and 3 parameters and adds it to the named interface. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A smart pointer to the newly created <a class="el" href="classDBus_1_1signal.html" title="Subclass of the numbered sigc::signal templates.">signal</a></dd></dl>
<p>Template parameters for the <code><a class="el" href="classDBus_1_1Object.html#afb49c0f2b22bac419253d41551a08eed" title="Creates a signal with a return value (possibly void ) and 0 parameters and adds it...">create_signal()</a></code> call will determine the signature of the <a class="el" href="classDBus_1_1signal.html" title="Subclass of the numbered sigc::signal templates.">signal</a> created. </p>

</div>
</div>
<a class="anchor" id="aa76832622995ef0672a83d9435c140d4"></a><!-- doxytag: member="DBus::Object::create_signal" ref="aa76832622995ef0672a83d9435c140d4" args="(const std::string &amp;iface, const std::string &amp;name)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T_return , class T_arg1 , class T_arg2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">DBusCxxPointer&lt;<a class="el" href="classDBus_1_1signal.html">signal</a>&lt;T_return, T_arg1,T_arg2&gt; &gt; DBus::Object::create_signal </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>iface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a <a class="el" href="classDBus_1_1signal.html" title="Subclass of the numbered sigc::signal templates.">signal</a> with a return value (possibly <code>void</code> ) and 2 parameters and adds it to the named interface. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A smart pointer to the newly created <a class="el" href="classDBus_1_1signal.html" title="Subclass of the numbered sigc::signal templates.">signal</a></dd></dl>
<p>Template parameters for the <code><a class="el" href="classDBus_1_1Object.html#afb49c0f2b22bac419253d41551a08eed" title="Creates a signal with a return value (possibly void ) and 0 parameters and adds it...">create_signal()</a></code> call will determine the signature of the <a class="el" href="classDBus_1_1signal.html" title="Subclass of the numbered sigc::signal templates.">signal</a> created. </p>

</div>
</div>
<a class="anchor" id="a28397bbcb2c498ead9fe268ab60388bb"></a><!-- doxytag: member="DBus::Object::create_signal" ref="a28397bbcb2c498ead9fe268ab60388bb" args="(const std::string &amp;iface, const std::string &amp;name)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T_return , class T_arg1 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">DBusCxxPointer&lt;<a class="el" href="classDBus_1_1signal.html">signal</a>&lt;T_return, T_arg1&gt; &gt; DBus::Object::create_signal </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>iface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a <a class="el" href="classDBus_1_1signal.html" title="Subclass of the numbered sigc::signal templates.">signal</a> with a return value (possibly <code>void</code> ) and 1 parameters and adds it to the named interface. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A smart pointer to the newly created <a class="el" href="classDBus_1_1signal.html" title="Subclass of the numbered sigc::signal templates.">signal</a></dd></dl>
<p>Template parameters for the <code><a class="el" href="classDBus_1_1Object.html#afb49c0f2b22bac419253d41551a08eed" title="Creates a signal with a return value (possibly void ) and 0 parameters and adds it...">create_signal()</a></code> call will determine the signature of the <a class="el" href="classDBus_1_1signal.html" title="Subclass of the numbered sigc::signal templates.">signal</a> created. </p>

</div>
</div>
<a class="anchor" id="aedfeed0bd72f4b2f9999385d4a549330"></a><!-- doxytag: member="DBus::Object::create_signal" ref="aedfeed0bd72f4b2f9999385d4a549330" args="(const std::string &amp;iface, const std::string &amp;name)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T_return , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_arg7 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">DBusCxxPointer&lt; <a class="el" href="classDBus_1_1signal.html">signal</a>&lt; T_return, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 &gt; &gt; DBus::Object::create_signal </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>iface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a <a class="el" href="classDBus_1_1signal.html" title="Subclass of the numbered sigc::signal templates.">signal</a> with a return value (possibly <code>void</code> ) and 0 parameters and adds it to the named interface. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A smart pointer to the newly created <a class="el" href="classDBus_1_1signal.html" title="Subclass of the numbered sigc::signal templates.">signal</a></dd></dl>
<p>Template parameters for the <code><a class="el" href="classDBus_1_1Object.html#afb49c0f2b22bac419253d41551a08eed" title="Creates a signal with a return value (possibly void ) and 0 parameters and adds it...">create_signal()</a></code> call will determine the signature of the <a class="el" href="classDBus_1_1signal.html" title="Subclass of the numbered sigc::signal templates.">signal</a> created. </p>

<p>References <a class="el" href="object_8cpp_source.html#l00124">create_interface()</a>, <a class="el" href="object_8cpp_source.html#l00179">has_interface()</a>, and <a class="el" href="object_8cpp_source.html#l00066">interface()</a>.</p>

</div>
</div>
<a class="anchor" id="abd765c8245be91aca0769ae9763770fe"></a><!-- doxytag: member="DBus::Object::create_signal" ref="abd765c8245be91aca0769ae9763770fe" args="(const std::string &amp;name)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T_return , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_arg7 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">DBusCxxPointer&lt;<a class="el" href="classDBus_1_1signal.html">signal</a>&lt;T_return, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7&gt; &gt; DBus::Object::create_signal </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a <a class="el" href="classDBus_1_1signal.html" title="Subclass of the numbered sigc::signal templates.">signal</a> with a return value (possibly <code>void</code> ) and 7 parameters and adds it to the default interface. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A smart pointer to the newly created <a class="el" href="classDBus_1_1signal.html" title="Subclass of the numbered sigc::signal templates.">signal</a></dd></dl>
<p>Template parameters for the <code><a class="el" href="classDBus_1_1Object.html#afb49c0f2b22bac419253d41551a08eed" title="Creates a signal with a return value (possibly void ) and 0 parameters and adds it...">create_signal()</a></code> call will determine the signature of the <a class="el" href="classDBus_1_1signal.html" title="Subclass of the numbered sigc::signal templates.">signal</a> created. </p>

</div>
</div>
<a class="anchor" id="a7a0d76560b0f1a85860d6d97e15cc298"></a><!-- doxytag: member="DBus::Object::create_signal" ref="a7a0d76560b0f1a85860d6d97e15cc298" args="(const std::string &amp;name)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T_return , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">DBusCxxPointer&lt;<a class="el" href="classDBus_1_1signal.html">signal</a>&lt;T_return, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6&gt; &gt; DBus::Object::create_signal </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a <a class="el" href="classDBus_1_1signal.html" title="Subclass of the numbered sigc::signal templates.">signal</a> with a return value (possibly <code>void</code> ) and 6 parameters and adds it to the default interface. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A smart pointer to the newly created <a class="el" href="classDBus_1_1signal.html" title="Subclass of the numbered sigc::signal templates.">signal</a></dd></dl>
<p>Template parameters for the <code><a class="el" href="classDBus_1_1Object.html#afb49c0f2b22bac419253d41551a08eed" title="Creates a signal with a return value (possibly void ) and 0 parameters and adds it...">create_signal()</a></code> call will determine the signature of the <a class="el" href="classDBus_1_1signal.html" title="Subclass of the numbered sigc::signal templates.">signal</a> created. </p>

</div>
</div>
<a class="anchor" id="a985156ff30afb5ec17e60a998acaf52a"></a><!-- doxytag: member="DBus::Object::create_signal" ref="a985156ff30afb5ec17e60a998acaf52a" args="(const std::string &amp;name)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T_return , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">DBusCxxPointer&lt;<a class="el" href="classDBus_1_1signal.html">signal</a>&lt;T_return, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5&gt; &gt; DBus::Object::create_signal </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a <a class="el" href="classDBus_1_1signal.html" title="Subclass of the numbered sigc::signal templates.">signal</a> with a return value (possibly <code>void</code> ) and 5 parameters and adds it to the default interface. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A smart pointer to the newly created <a class="el" href="classDBus_1_1signal.html" title="Subclass of the numbered sigc::signal templates.">signal</a></dd></dl>
<p>Template parameters for the <code><a class="el" href="classDBus_1_1Object.html#afb49c0f2b22bac419253d41551a08eed" title="Creates a signal with a return value (possibly void ) and 0 parameters and adds it...">create_signal()</a></code> call will determine the signature of the <a class="el" href="classDBus_1_1signal.html" title="Subclass of the numbered sigc::signal templates.">signal</a> created. </p>

</div>
</div>
<a class="anchor" id="a8e2678176add1c8aa0d2836fc3a2ad64"></a><!-- doxytag: member="DBus::Object::create_signal" ref="a8e2678176add1c8aa0d2836fc3a2ad64" args="(const std::string &amp;name)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T_return , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">DBusCxxPointer&lt;<a class="el" href="classDBus_1_1signal.html">signal</a>&lt;T_return, T_arg1,T_arg2,T_arg3,T_arg4&gt; &gt; DBus::Object::create_signal </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a <a class="el" href="classDBus_1_1signal.html" title="Subclass of the numbered sigc::signal templates.">signal</a> with a return value (possibly <code>void</code> ) and 4 parameters and adds it to the default interface. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A smart pointer to the newly created <a class="el" href="classDBus_1_1signal.html" title="Subclass of the numbered sigc::signal templates.">signal</a></dd></dl>
<p>Template parameters for the <code><a class="el" href="classDBus_1_1Object.html#afb49c0f2b22bac419253d41551a08eed" title="Creates a signal with a return value (possibly void ) and 0 parameters and adds it...">create_signal()</a></code> call will determine the signature of the <a class="el" href="classDBus_1_1signal.html" title="Subclass of the numbered sigc::signal templates.">signal</a> created. </p>

</div>
</div>
<a class="anchor" id="ad28a19a155aa3114eeff9114fdaaf67a"></a><!-- doxytag: member="DBus::Object::create_signal" ref="ad28a19a155aa3114eeff9114fdaaf67a" args="(const std::string &amp;name)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T_return , class T_arg1 , class T_arg2 , class T_arg3 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">DBusCxxPointer&lt;<a class="el" href="classDBus_1_1signal.html">signal</a>&lt;T_return, T_arg1,T_arg2,T_arg3&gt; &gt; DBus::Object::create_signal </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a <a class="el" href="classDBus_1_1signal.html" title="Subclass of the numbered sigc::signal templates.">signal</a> with a return value (possibly <code>void</code> ) and 3 parameters and adds it to the default interface. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A smart pointer to the newly created <a class="el" href="classDBus_1_1signal.html" title="Subclass of the numbered sigc::signal templates.">signal</a></dd></dl>
<p>Template parameters for the <code><a class="el" href="classDBus_1_1Object.html#afb49c0f2b22bac419253d41551a08eed" title="Creates a signal with a return value (possibly void ) and 0 parameters and adds it...">create_signal()</a></code> call will determine the signature of the <a class="el" href="classDBus_1_1signal.html" title="Subclass of the numbered sigc::signal templates.">signal</a> created. </p>

</div>
</div>
<a class="anchor" id="add6618a5d7948adafd265e9a1cde8d4a"></a><!-- doxytag: member="DBus::Object::create_signal" ref="add6618a5d7948adafd265e9a1cde8d4a" args="(const std::string &amp;name)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T_return , class T_arg1 , class T_arg2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">DBusCxxPointer&lt;<a class="el" href="classDBus_1_1signal.html">signal</a>&lt;T_return, T_arg1,T_arg2&gt; &gt; DBus::Object::create_signal </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a <a class="el" href="classDBus_1_1signal.html" title="Subclass of the numbered sigc::signal templates.">signal</a> with a return value (possibly <code>void</code> ) and 2 parameters and adds it to the default interface. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A smart pointer to the newly created <a class="el" href="classDBus_1_1signal.html" title="Subclass of the numbered sigc::signal templates.">signal</a></dd></dl>
<p>Template parameters for the <code><a class="el" href="classDBus_1_1Object.html#afb49c0f2b22bac419253d41551a08eed" title="Creates a signal with a return value (possibly void ) and 0 parameters and adds it...">create_signal()</a></code> call will determine the signature of the <a class="el" href="classDBus_1_1signal.html" title="Subclass of the numbered sigc::signal templates.">signal</a> created. </p>

</div>
</div>
<a class="anchor" id="a901c1d70ac1ee228c6245d71f738da50"></a><!-- doxytag: member="DBus::Object::create_signal" ref="a901c1d70ac1ee228c6245d71f738da50" args="(const std::string &amp;name)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T_return , class T_arg1 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">DBusCxxPointer&lt;<a class="el" href="classDBus_1_1signal.html">signal</a>&lt;T_return, T_arg1&gt; &gt; DBus::Object::create_signal </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a <a class="el" href="classDBus_1_1signal.html" title="Subclass of the numbered sigc::signal templates.">signal</a> with a return value (possibly <code>void</code> ) and 1 parameters and adds it to the default interface. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A smart pointer to the newly created <a class="el" href="classDBus_1_1signal.html" title="Subclass of the numbered sigc::signal templates.">signal</a></dd></dl>
<p>Template parameters for the <code><a class="el" href="classDBus_1_1Object.html#afb49c0f2b22bac419253d41551a08eed" title="Creates a signal with a return value (possibly void ) and 0 parameters and adds it...">create_signal()</a></code> call will determine the signature of the <a class="el" href="classDBus_1_1signal.html" title="Subclass of the numbered sigc::signal templates.">signal</a> created. </p>

</div>
</div>
<a class="anchor" id="afb49c0f2b22bac419253d41551a08eed"></a><!-- doxytag: member="DBus::Object::create_signal" ref="afb49c0f2b22bac419253d41551a08eed" args="(const std::string &amp;name)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T_return , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_arg7 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">DBusCxxPointer&lt; <a class="el" href="classDBus_1_1signal.html">signal</a>&lt; T_return, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 &gt; &gt; DBus::Object::create_signal </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a <a class="el" href="classDBus_1_1signal.html" title="Subclass of the numbered sigc::signal templates.">signal</a> with a return value (possibly <code>void</code> ) and 0 parameters and adds it to the default interface. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A smart pointer to the newly created <a class="el" href="classDBus_1_1signal.html" title="Subclass of the numbered sigc::signal templates.">signal</a></dd></dl>
<p>Template parameters for the <code><a class="el" href="classDBus_1_1Object.html#afb49c0f2b22bac419253d41551a08eed" title="Creates a signal with a return value (possibly void ) and 0 parameters and adds it...">create_signal()</a></code> call will determine the signature of the <a class="el" href="classDBus_1_1signal.html" title="Subclass of the numbered sigc::signal templates.">signal</a> created. </p>

<p>References <a class="el" href="object_8cpp_source.html#l00124">create_interface()</a>, and <a class="el" href="object_8cpp_source.html#l00194">default_interface()</a>.</p>

</div>
</div>
<a class="anchor" id="a24a9541b26674e59b02810781e3b7357"></a><!-- doxytag: member="DBus::Object::default_interface" ref="a24a9541b26674e59b02810781e3b7357" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDBus_1_1Interface.html#a553ac8bdc2476ede606e2ff0ee93067f">Interface::pointer</a> DBus::Object::default_interface </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the default interface associated with this object. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The default interface, or a null smart pointer if no default is set </dd></dl>

<p>Referenced by <a class="el" href="object_8h_source.html#l00957">create_signal()</a>.</p>

</div>
</div>
<a class="anchor" id="a8628e3194e1d927bf483dc6d0ce6ee9b"></a><!-- doxytag: member="DBus::Object::handle_message" ref="a8628e3194e1d927bf483dc6d0ce6ee9b" args="(DBusCxxPointer&lt; Connection &gt; conn, Message::const_pointer msg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespaceDBus.html#a7c6b6b3408e5c53b20f8384b0c931eb0">HandlerResult</a> DBus::Object::handle_message </td>
          <td>(</td>
          <td class="paramtype">DBusCxxPointer&lt; <a class="el" href="classDBus_1_1Connection.html">Connection</a> &gt;&nbsp;</td>
          <td class="paramname"> <em>conn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDBus_1_1Message.html#a30b9cd71b63f5c0b5b97c4cff35b1a69">Message::const_pointer</a>&nbsp;</td>
          <td class="paramname"> <em>msg</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Handles the specified message on the specified connection. </p>
<p>If <code>msg</code> is an introspection message, the object will rely on its <code>introspection()</code> method to provide a reply.</p>
<p>Looks for interfaces specified in the message first. If the message does not specify an interface or the specified interface is not found the default interface will be used.</p>
<p>If the specified interface is found, all matching interfaces will be tried until an interface handler returns <code>HANDLED</code>. Once an interface returns <code>HANDLED</code> no further interfaces will be tried.</p>
<p>If no interface returns <code>HANDLED</code> the default interface (if one is set) will be tried.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>HANDLED</code> if this object handled the message, <code>NOT_HANDLED</code> otherwise </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>conn</em>&nbsp;</td><td>The <a class="el" href="classDBus_1_1Connection.html" title="Connection point to the DBus.">Connection</a> to send the reply message on </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>msg</em>&nbsp;</td><td>The message to handle; must be a <a class="el" href="classDBus_1_1CallMessage.html" title="Represents a DBus call message.">CallMessage</a> or it will not be handled </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classDBus_1_1MessageHandler.html#adcc82cf431e790efa9be7719aaf8ea00">DBus::MessageHandler</a>.</p>

</div>
</div>
<a class="anchor" id="a997b73a0c9f716ef61e4252f38e04488"></a><!-- doxytag: member="DBus::Object::has_child" ref="a997b73a0c9f716ef61e4252f38e04488" args="(const std::string &amp;name) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool DBus::Object::has_child </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Test whether an object has a child with a specified name. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>True</code> if the object has the named child, <code>false</code> otherwise. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>The name of the child to test. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="object_8h_source.html#l00659">m_children</a>.</p>

<p>Referenced by <a class="el" href="object_8cpp_source.html#l00246">add_child()</a>.</p>

</div>
</div>
<a class="anchor" id="a9ec6e59d6996734e49cb53e01acfb767"></a><!-- doxytag: member="DBus::Object::has_interface" ref="a9ec6e59d6996734e49cb53e01acfb767" args="(const std::string &amp;name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool DBus::Object::has_interface </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Test whether an <a class="el" href="classDBus_1_1Object.html">Object</a> has a named interface. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>True</code> if the object has the named interface, <code>false</code> otherwise </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>The name of the interface to look for </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="object_8h_source.html#l00665">m_interfaces</a>, and <a class="el" href="object_8h_source.html#l00661">m_interfaces_rwlock</a>.</p>

<p>Referenced by <a class="el" href="object_8h_source.html#l01046">create_signal()</a>.</p>

</div>
</div>
<a class="anchor" id="a99e149e4850c4ab30218c5cf312c4728"></a><!-- doxytag: member="DBus::Object::interface" ref="a99e149e4850c4ab30218c5cf312c4728" args="(const std::string &amp;name) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDBus_1_1Interface.html#a553ac8bdc2476ede606e2ff0ee93067f">Interface::pointer</a> DBus::Object::interface </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the first interface with the given name. </p>

<p>References <a class="el" href="object_8h_source.html#l00665">m_interfaces</a>, and <a class="el" href="object_8h_source.html#l00661">m_interfaces_rwlock</a>.</p>

<p>Referenced by <a class="el" href="object_8h_source.html#l00836">create_method()</a>, and <a class="el" href="object_8h_source.html#l01046">create_signal()</a>.</p>

</div>
</div>
<a class="anchor" id="a7e3c076e8ff3b7591eda4e9f1726b076"></a><!-- doxytag: member="DBus::Object::interfaces" ref="a7e3c076e8ff3b7591eda4e9f1726b076" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classDBus_1_1Object.html#a3dd597323a47e73d511c8d55e271fb83">Object::Interfaces</a> &amp; DBus::Object::interfaces </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get all the interfaces associated with this <a class="el" href="classDBus_1_1Object.html">Object</a> instance. </p>

<p>References <a class="el" href="object_8h_source.html#l00665">m_interfaces</a>.</p>

</div>
</div>
<a class="anchor" id="a78b4980a18d58124f44dfcf56d5f0055"></a><!-- doxytag: member="DBus::Object::introspect" ref="a78b4980a18d58124f44dfcf56d5f0055" args="(int space_depth=0) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string DBus::Object::introspect </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>space_depth</em> = <code>0</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns a <a class="el" href="namespaceDBus.html">DBus</a> XML description of this interface. </p>

<p>References <a class="el" href="utility_8h_source.html#l00040">DBUS_CXX_INTROSPECTABLE_INTERFACE</a>, <a class="el" href="object_8h_source.html#l00659">m_children</a>, and <a class="el" href="object_8h_source.html#l00665">m_interfaces</a>.</p>

</div>
</div>
<a class="anchor" id="a0fb58727e387a7e00d4f53f0793e805e"></a><!-- doxytag: member="DBus::Object::on_interface_name_changed" ref="a0fb58727e387a7e00d4f53f0793e805e" args="(const std::string &amp;oldname, const std::string &amp;newname, DBusCxxPointer&lt; Interface &gt; interface)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DBus::Object::on_interface_name_changed </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>oldname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>newname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DBusCxxPointer&lt; <a class="el" href="classDBus_1_1Interface.html">Interface</a> &gt;&nbsp;</td>
          <td class="paramname"> <em>interface</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Callback point that updates the interface name map when an interface changes its name. </p>

</div>
</div>
<a class="anchor" id="abfe8e9f3bda2822e280be403db3cff23"></a><!-- doxytag: member="DBus::Object::register_with_connection" ref="abfe8e9f3bda2822e280be403db3cff23" args="(DBusCxxPointer&lt; Connection &gt; conn)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool DBus::Object::register_with_connection </td>
          <td>(</td>
          <td class="paramtype">DBusCxxPointer&lt; <a class="el" href="classDBus_1_1Connection.html">Connection</a> &gt;&nbsp;</td>
          <td class="paramname"> <em>conn</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Extends base version to include registering signals. </p>

</div>
</div>
<a class="anchor" id="a3515d2b48bd3f14aba2a06d77572d4cb"></a><!-- doxytag: member="DBus::Object::remove_child" ref="a3515d2b48bd3f14aba2a06d77572d4cb" args="(const std::string &amp;name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool DBus::Object::remove_child </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Remove the named child from this object. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>True</code> if the child was found and removed, <code>false</code> if no child by the name was found to remove. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>The name of the child to remove. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="object_8h_source.html#l00659">m_children</a>.</p>

</div>
</div>
<a class="anchor" id="af51bf37df4f3de1747a8bd54a0602596"></a><!-- doxytag: member="DBus::Object::remove_default_interface" ref="af51bf37df4f3de1747a8bd54a0602596" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DBus::Object::remove_default_interface </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Removes the currently set (if any) default interface. </p>
<p>There wil not be a default interface set. </p>

<p>References <a class="el" href="object_8h_source.html#l00669">m_signal_default_interface_changed</a>.</p>

</div>
</div>
<a class="anchor" id="aabbcd801c315e2e88a39b6654bceedef"></a><!-- doxytag: member="DBus::Object::remove_interface" ref="aabbcd801c315e2e88a39b6654bceedef" args="(const std::string &amp;name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DBus::Object::remove_interface </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Removes the first interface found with the given name. </p>

<p>References <a class="el" href="object_8h_source.html#l00677">m_interface_signal_name_connections</a>, <a class="el" href="object_8h_source.html#l00665">m_interfaces</a>, <a class="el" href="object_8h_source.html#l00661">m_interfaces_rwlock</a>, <a class="el" href="object_8h_source.html#l00669">m_signal_default_interface_changed</a>, and <a class="el" href="object_8h_source.html#l00673">m_signal_interface_removed</a>.</p>

</div>
</div>
<a class="anchor" id="a723b0433c976e9a7c5277034d3f9cd16"></a><!-- doxytag: member="DBus::Object::set_default_interface" ref="a723b0433c976e9a7c5277034d3f9cd16" args="(const std::string &amp;new_default_name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool DBus::Object::set_default_interface </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>new_default_name</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the default interface to a specific name. </p>
<p>The first interface found with a matching name is used. If there is already a default interface set it will be replaced.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>True</code> if an interface with the specified name was found, <code>false</code> otherwise. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>new_default_name</em>&nbsp;</td><td>The name of the interface to use as the default. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="object_8h_source.html#l00665">m_interfaces</a>, <a class="el" href="object_8h_source.html#l00661">m_interfaces_rwlock</a>, and <a class="el" href="object_8h_source.html#l00669">m_signal_default_interface_changed</a>.</p>

<p>Referenced by <a class="el" href="object_8h_source.html#l00699">create_method()</a>.</p>

</div>
</div>
<a class="anchor" id="a66d62aab742803c50168e18115194bf7"></a><!-- doxytag: member="DBus::Object::signal_default_interface_changed" ref="a66d62aab742803c50168e18115194bf7" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sigc::signal&lt; void, <a class="el" href="classDBus_1_1Interface.html#a553ac8bdc2476ede606e2ff0ee93067f">Interface::pointer</a>, <a class="el" href="classDBus_1_1Interface.html#a553ac8bdc2476ede606e2ff0ee93067f">Interface::pointer</a> &gt; DBus::Object::signal_default_interface_changed </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Signal emitted when the default interface of this object is changed. </p>
<p>The first parameter of the callback is a pointer to the old default interface, and the second parameter is a callback to the new default interface. </p>

<p>References <a class="el" href="object_8h_source.html#l00669">m_signal_default_interface_changed</a>.</p>

</div>
</div>
<a class="anchor" id="a9e89d67b4b8edb63cbda1bba602abc5e"></a><!-- doxytag: member="DBus::Object::signal_interface_added" ref="a9e89d67b4b8edb63cbda1bba602abc5e" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sigc::signal&lt; void, <a class="el" href="classDBus_1_1Interface.html#a553ac8bdc2476ede606e2ff0ee93067f">Interface::pointer</a> &gt; DBus::Object::signal_interface_added </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Signal emitted when an interface is added to this object. </p>
<p>The first parameter of the callback is a pointer to the newly added interface. </p>

<p>References <a class="el" href="object_8h_source.html#l00671">m_signal_interface_added</a>.</p>

</div>
</div>
<a class="anchor" id="a47036e8bdd3468e2903ae33dfe5361e8"></a><!-- doxytag: member="DBus::Object::signal_interface_removed" ref="a47036e8bdd3468e2903ae33dfe5361e8" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sigc::signal&lt; void, <a class="el" href="classDBus_1_1Interface.html#a553ac8bdc2476ede606e2ff0ee93067f">Interface::pointer</a> &gt; DBus::Object::signal_interface_removed </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Signal emitted when an interface is removed from this object. </p>
<p>The first parameter of the callback is a pointer to the removed interface. </p>

<p>References <a class="el" href="object_8h_source.html#l00673">m_signal_interface_removed</a>.</p>

</div>
</div>
<hr/><h2>Member Data Documentation</h2>
<a class="anchor" id="a3f713d2810dab3129e5dc8f3bb51f495"></a><!-- doxytag: member="DBus::Object::m_children" ref="a3f713d2810dab3129e5dc8f3bb51f495" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDBus_1_1Object.html#a3deca17387532da99bdc7f1f23812046">Children</a> <a class="el" href="classDBus_1_1Object.html#a3f713d2810dab3129e5dc8f3bb51f495">DBus::Object::m_children</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Referenced by <a class="el" href="object_8cpp_source.html#l00246">add_child()</a>, <a class="el" href="object_8cpp_source.html#l00239">child()</a>, <a class="el" href="object_8cpp_source.html#l00234">children()</a>, <a class="el" href="object_8cpp_source.html#l00263">has_child()</a>, <a class="el" href="object_8cpp_source.html#l00268">introspect()</a>, and <a class="el" href="object_8cpp_source.html#l00255">remove_child()</a>.</p>

</div>
</div>
<a class="anchor" id="ad3b564bf7c2079dbe307543145de4474"></a><!-- doxytag: member="DBus::Object::m_default_interface" ref="ad3b564bf7c2079dbe307543145de4474" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DBusCxxPointer&lt;<a class="el" href="classDBus_1_1Interface.html">Interface</a>&gt; <a class="el" href="classDBus_1_1Object.html#ad3b564bf7c2079dbe307543145de4474">DBus::Object::m_default_interface</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Referenced by <a class="el" href="object_8h_source.html#l00699">create_method()</a>.</p>

</div>
</div>
<a class="anchor" id="aeadf56908734af799a62a2797f2f5cc9"></a><!-- doxytag: member="DBus::Object::m_interface_signal_name_connections" ref="aeadf56908734af799a62a2797f2f5cc9" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDBus_1_1Object.html#a5389375b09c7c05a0f03af84da24ba6f">InterfaceSignalNameConnections</a> <a class="el" href="classDBus_1_1Object.html#aeadf56908734af799a62a2797f2f5cc9">DBus::Object::m_interface_signal_name_connections</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Referenced by <a class="el" href="object_8cpp_source.html#l00135">remove_interface()</a>.</p>

</div>
</div>
<a class="anchor" id="a43fa20c2b2547eb1463e07f4bb2a8ff9"></a><!-- doxytag: member="DBus::Object::m_interfaces" ref="a43fa20c2b2547eb1463e07f4bb2a8ff9" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDBus_1_1Object.html#a3dd597323a47e73d511c8d55e271fb83">Interfaces</a> <a class="el" href="classDBus_1_1Object.html#a43fa20c2b2547eb1463e07f4bb2a8ff9">DBus::Object::m_interfaces</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Referenced by <a class="el" href="object_8cpp_source.html#l00179">has_interface()</a>, <a class="el" href="object_8cpp_source.html#l00066">interface()</a>, <a class="el" href="object_8cpp_source.html#l00061">interfaces()</a>, <a class="el" href="object_8cpp_source.html#l00268">introspect()</a>, <a class="el" href="object_8cpp_source.html#l00135">remove_interface()</a>, and <a class="el" href="object_8cpp_source.html#l00199">set_default_interface()</a>.</p>

</div>
</div>
<a class="anchor" id="a74374aa2b53adad6cb6da0d7b16f5306"></a><!-- doxytag: member="DBus::Object::m_interfaces_rwlock" ref="a74374aa2b53adad6cb6da0d7b16f5306" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pthread_rwlock_t <a class="el" href="classDBus_1_1Object.html#a74374aa2b53adad6cb6da0d7b16f5306">DBus::Object::m_interfaces_rwlock</a><code> [mutable, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Referenced by <a class="el" href="object_8cpp_source.html#l00179">has_interface()</a>, <a class="el" href="object_8cpp_source.html#l00066">interface()</a>, <a class="el" href="object_8cpp_source.html#l00029">Object()</a>, <a class="el" href="object_8cpp_source.html#l00135">remove_interface()</a>, <a class="el" href="object_8cpp_source.html#l00199">set_default_interface()</a>, and <a class="el" href="object_8cpp_source.html#l00041">~Object()</a>.</p>

</div>
</div>
<a class="anchor" id="a684bfb2a817c1ef979753ada9b5e02f3"></a><!-- doxytag: member="DBus::Object::m_name_mutex" ref="a684bfb2a817c1ef979753ada9b5e02f3" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pthread_mutex_t <a class="el" href="classDBus_1_1Object.html#a684bfb2a817c1ef979753ada9b5e02f3">DBus::Object::m_name_mutex</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Referenced by <a class="el" href="object_8cpp_source.html#l00029">Object()</a>, and <a class="el" href="object_8cpp_source.html#l00041">~Object()</a>.</p>

</div>
</div>
<a class="anchor" id="a79375a3991daa872acbed92cebd634a1"></a><!-- doxytag: member="DBus::Object::m_signal_default_interface_changed" ref="a79375a3991daa872acbed92cebd634a1" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sigc::signal&lt;void,DBusCxxPointer&lt;<a class="el" href="classDBus_1_1Interface.html">Interface</a>&gt; ,DBusCxxPointer&lt;<a class="el" href="classDBus_1_1Interface.html">Interface</a>&gt; &gt; <a class="el" href="classDBus_1_1Object.html#a79375a3991daa872acbed92cebd634a1">DBus::Object::m_signal_default_interface_changed</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Referenced by <a class="el" href="object_8cpp_source.html#l00225">remove_default_interface()</a>, <a class="el" href="object_8cpp_source.html#l00135">remove_interface()</a>, <a class="el" href="object_8cpp_source.html#l00199">set_default_interface()</a>, and <a class="el" href="object_8cpp_source.html#l00299">signal_default_interface_changed()</a>.</p>

</div>
</div>
<a class="anchor" id="a313ca46702beaa5b2de7ba9f199b58e9"></a><!-- doxytag: member="DBus::Object::m_signal_interface_added" ref="a313ca46702beaa5b2de7ba9f199b58e9" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sigc::signal&lt;void,DBusCxxPointer&lt;<a class="el" href="classDBus_1_1Interface.html">Interface</a>&gt; &gt; <a class="el" href="classDBus_1_1Object.html#a313ca46702beaa5b2de7ba9f199b58e9">DBus::Object::m_signal_interface_added</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Referenced by <a class="el" href="object_8cpp_source.html#l00289">signal_interface_added()</a>.</p>

</div>
</div>
<a class="anchor" id="a1cd04dd8c3d1dc8eb3e24a8c669e3418"></a><!-- doxytag: member="DBus::Object::m_signal_interface_removed" ref="a1cd04dd8c3d1dc8eb3e24a8c669e3418" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sigc::signal&lt;void,DBusCxxPointer&lt;<a class="el" href="classDBus_1_1Interface.html">Interface</a>&gt; &gt; <a class="el" href="classDBus_1_1Object.html#a1cd04dd8c3d1dc8eb3e24a8c669e3418">DBus::Object::m_signal_interface_removed</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Referenced by <a class="el" href="object_8cpp_source.html#l00135">remove_interface()</a>, and <a class="el" href="object_8cpp_source.html#l00294">signal_interface_removed()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="object_8h_source.html">object.h</a></li>
<li><a class="el" href="object_8cpp.html">object.cpp</a></li>
</ul>
</div>
<hr size="1"><address style="align: right;"><small>
Generated on Thu Mar 18 09:31:34 2010 for dbus-cxx by&nbsp;<a href="http://www.doxygen.org/index.html"><img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.6.1</small></address>
</body>
</html>
