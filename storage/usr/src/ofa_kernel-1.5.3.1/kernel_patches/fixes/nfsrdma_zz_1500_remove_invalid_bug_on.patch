rpcrdma: Remove invalid BUG_ON in rpcrdma_reply_handler

From: Tom Tucker <tom@ogc.us>

The rpcrdma_reply_handler has a BUG_ON that checks if a reply buffer is
already attached to the request. Since the reply buffer is reset to null in
rpcrdma_ep_post, the theory was that it couldn't be non-null. However, if
this request is retransmitted, (e.g. due to a timeout), then there is a 
race condition between this function and xprt_rdma_send_request where a new
reply buffer is allocated and assigned to this request -- making the BUG_ON
condition true.

The first check in the BUG_ON (!req) is also invalid since the req is 
assigned from container_of on a pointer that has already been checked for
null, and therefore, req can't possibly be null.

The fix is to remove the BUG_ON and replace it with code that posts and/or
frees the unneeded reply buffer.

Signed-off-by: Tom Tucker <tom@ogc.us>
---

 net/sunrpc/xprtrdma/rpc_rdma.c |   12 +++++++++++-
 1 files changed, 11 insertions(+), 1 deletions(-)


diff --git a/net/sunrpc/xprtrdma/rpc_rdma.c b/net/sunrpc/xprtrdma/rpc_rdma.c
index 2ac3f6e..6b70793 100644
--- a/net/sunrpc/xprtrdma/rpc_rdma.c
+++ b/net/sunrpc/xprtrdma/rpc_rdma.c
@@ -778,7 +778,17 @@ repost:
 		"                   RPC request 0x%p xid 0x%08x\n",
 			__func__, rep, req, rqst, headerp->rm_xid);
 
-	BUG_ON(!req || req->rl_reply);
+	/*
+	 * If this req was re-transmited, rl_reply will point to a new
+	 * buffer allocated in xprt_rdma_send_request. Post/free it.
+	 */
+	if (req->rl_reply) {
+		struct rpcrdma_rep *_rep = req->rl_reply;
+                req->rl_reply = NULL;
+                _rep->rr_func = rpcrdma_reply_handler;
+                if (rpcrdma_ep_post_recv(&r_xprt->rx_ia, &r_xprt->rx_ep, _rep))
+                        rpcrdma_recv_buffer_put(_rep);
+	}
 
 	/* from here on, the reply is no longer an orphan */
 	req->rl_reply = rep;
