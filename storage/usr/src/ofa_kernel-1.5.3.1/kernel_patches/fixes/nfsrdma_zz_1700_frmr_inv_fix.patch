rpcrdma: Fix FRMR invalidate logic

From: Tom Tucker <tom@ogc.us>

The FRMR validate/invalidate logic was not resilient to transport errors
that may cause FRMR INVALIDATE WQE to be flushed and not processed by the
adapter. Since FRMR are retained across connections, this would result in
FRMR registration failures when the FRMR was reused on
another connection and result in an error and termination.

Since invalidating an already invalid FRMR is not an error, moved the
invalidate step to immediately before registration. This guarantees that
the FRMR is always in the correct state prior to registration.

Signed-off-by: Tom Tucker <tom@ogc.us>
---

 net/sunrpc/xprtrdma/verbs.c |   38 ++++++++++++++++++++++++--------------
 1 files changed, 24 insertions(+), 14 deletions(-)


diff --git a/net/sunrpc/xprtrdma/verbs.c b/net/sunrpc/xprtrdma/verbs.c
index be1ad9d..5f9fc28 100644
--- a/net/sunrpc/xprtrdma/verbs.c
+++ b/net/sunrpc/xprtrdma/verbs.c
@@ -1462,6 +1462,23 @@ rpcrdma_unmap_one(struct rpcrdma_ia *ia, struct rpcrdma_mr_seg *seg)
 				seg->mr_dma, seg->mr_dmalen, seg->mr_dir);
 }
 
+static void rpcrdma_deregister_frmr(struct rpcrdma_mr_seg *seg,
+				   struct rpcrdma_ia *ia)
+{
+        struct ib_send_wr invalidate_wr, *bad_wr;
+        int rc;
+
+        memset(&invalidate_wr, 0, sizeof invalidate_wr);
+        invalidate_wr.opcode = IB_WR_LOCAL_INV;
+        invalidate_wr.send_flags = 0;                   /* unsignaled */
+        invalidate_wr.ex.invalidate_rkey = seg->mr_chunk.rl_mw->r.frmr.fr_mr->rkey;
+
+        rc = ib_post_send(ia->ri_id->qp, &invalidate_wr, &bad_wr);
+        if (rc)
+                dprintk("RPC:       %s: failed ib_post_send for invalidate,"
+                        " status %i\n", __func__, rc);
+}
+
 static int
 rpcrdma_register_frmr_external(struct rpcrdma_mr_seg *seg,
 			int *nsegs, int writing, struct rpcrdma_ia *ia,
@@ -1493,6 +1510,12 @@ rpcrdma_register_frmr_external(struct rpcrdma_mr_seg *seg,
 	dprintk("RPC:       %s: Using frmr %p to map %d segments\n",
 		__func__, seg1->mr_chunk.rl_mw, i);
 
+        /*
+	 * Lazy invalidate the FRMR. It is not an error to invalidate
+	 * an invalid FRMR.
+	 */
+        rpcrdma_deregister_frmr(seg1, ia);
+
 	/* Bump the key */
 	key = (u8)(seg1->mr_chunk.rl_mw->r.frmr.fr_mr->rkey & 0x000000FF);
 	ib_update_fast_reg_key(seg1->mr_chunk.rl_mw->r.frmr.fr_mr, ++key);
@@ -1534,23 +1557,10 @@ rpcrdma_deregister_frmr_external(struct rpcrdma_mr_seg *seg,
 			struct rpcrdma_ia *ia, struct rpcrdma_xprt *r_xprt)
 {
 	struct rpcrdma_mr_seg *seg1 = seg;
-	struct ib_send_wr invalidate_wr, *bad_wr;
-	int rc;
-
 	while (seg1->mr_nsegs--)
 		rpcrdma_unmap_one(ia, seg++);
 
-	memset(&invalidate_wr, 0, sizeof invalidate_wr);
-	invalidate_wr.opcode = IB_WR_LOCAL_INV;
-	invalidate_wr.send_flags = 0;			/* unsignaled */
-	invalidate_wr.ex.invalidate_rkey = seg1->mr_chunk.rl_mw->r.frmr.fr_mr->rkey;
-	DECR_CQCOUNT(&r_xprt->rx_ep);
-
-	rc = ib_post_send(ia->ri_id->qp, &invalidate_wr, &bad_wr);
-	if (rc)
-		dprintk("RPC:       %s: failed ib_post_send for invalidate,"
-			" status %i\n", __func__, rc);
-	return rc;
+	return 0;
 }
 
 static int
