rpcrdma: Fix rq_list race in xprt_transmit

From: Tom Tucker <tom@ogc.us>

Move the spin lock to protect rq_received and rq_list when electing
to transmit a new request. This function races with the reply
handler as part of the retransmit path.

Absent this change, the request can be added back to the list as a reply is
being processed.

Signed-off-by: Tom Tucker <tom@ogc.us>
---

 net/sunrpc/xprt.c |    8 +++++---
 1 files changed, 5 insertions(+), 3 deletions(-)


diff --git a/net/sunrpc/xprt.c b/net/sunrpc/xprt.c
index 06ca058..a5150e8 100644
--- a/net/sunrpc/xprt.c
+++ b/net/sunrpc/xprt.c
@@ -872,21 +872,23 @@ void xprt_transmit(struct rpc_task *task)
 
 	dprintk("RPC: %5u xprt_transmit(%u)\n", task->tk_pid, req->rq_slen);
 
+	spin_lock_bh(&xprt->transport_lock);
 	if (!req->rq_received) {
 		if (list_empty(&req->rq_list)) {
-			spin_lock_bh(&xprt->transport_lock);
 			/* Update the softirq receive buffer */
 			memcpy(&req->rq_private_buf, &req->rq_rcv_buf,
 					sizeof(req->rq_private_buf));
 			/* Add request to the receive list */
 			list_add_tail(&req->rq_list, &xprt->recv);
-			spin_unlock_bh(&xprt->transport_lock);
 			xprt_reset_majortimeo(req);
 			/* Turn off autodisconnect */
 			del_singleshot_timer_sync(&xprt->timer);
 		}
-	} else if (!req->rq_bytes_sent)
+		spin_unlock_bh(&xprt->transport_lock);
+	} else if (!req->rq_bytes_sent) {
+		spin_unlock_bh(&xprt->transport_lock);
 		return;
+	}
 
 	req->rq_connect_cookie = xprt->connect_cookie;
 	req->rq_xtime = jiffies;
