ipoib: fix unprotected use of priv->broadcast in ipoib_mcast_join_task.

There is a race whereby the ipoib broadcast pointer may be set to NULL by flush while the join
task is being started.  This protects the broadcast pointer access via a spinlock.  If the
pointer is indeed NULL, we set the mcast_mtu value to the current admin_mtu value -- since
it does not matter anyway, the I/F is going down.

We also minimize the race by testing for non-null broadcast pointer in test_bit.
The spinlock cannot be taken here because ipoib_mcast_join uses mutexes.

This is a temporary fix for an ipoib architectural bug.

Signed-off-by: Jack Morgenstein <jackm@dev.mellanox.co.il>

Index: ofed_kernel/drivers/infiniband/ulp/ipoib/ipoib_multicast.c
===================================================================
--- ofed_kernel.orig/drivers/infiniband/ulp/ipoib/ipoib_multicast.c	2009-02-01 10:06:44.870307000 +0200
+++ ofed_kernel/drivers/infiniband/ulp/ipoib/ipoib_multicast.c	2009-02-01 10:08:22.841779000 +0200
@@ -564,8 +564,10 @@ void ipoib_mcast_join_task(struct work_s
 		spin_unlock_irq(&priv->lock);
 	}
 
-	if (!test_bit(IPOIB_MCAST_FLAG_ATTACHED, &priv->broadcast->flags)) {
-		if (!test_bit(IPOIB_MCAST_FLAG_BUSY, &priv->broadcast->flags))
+	if (priv->broadcast &&
+	    !test_bit(IPOIB_MCAST_FLAG_ATTACHED, &priv->broadcast->flags)) {
+		if (priv->broadcast &&
+		    !test_bit(IPOIB_MCAST_FLAG_BUSY, &priv->broadcast->flags))
 			ipoib_mcast_join(dev, priv->broadcast, 0);
 		return;
 	}
@@ -593,7 +595,12 @@ void ipoib_mcast_join_task(struct work_s
 		return;
 	}
 
-	priv->mcast_mtu = IPOIB_UD_MTU(ib_mtu_enum_to_int(priv->broadcast->mcmember.mtu));
+	spin_lock_irq(&priv->lock);
+	if (priv->broadcast)
+		priv->mcast_mtu = IPOIB_UD_MTU(ib_mtu_enum_to_int(priv->broadcast->mcmember.mtu));
+	else
+		priv->mcast_mtu = priv->admin_mtu;
+	spin_unlock_irq(&priv->lock);
 
 	if (!ipoib_cm_admin_enabled(dev)) {
 		rtnl_lock();
