commit 07d8170ebbd3438c2543beaf899862edc4d1f049
Author: root <root@almus.(none)>
Date:   Tue Sep 1 12:20:02 2009 -0700

    cxgb3_00545_ael2020update.patch

diff --git a/drivers/net/cxgb3/adapter.h b/drivers/net/cxgb3/adapter.h
index 57087fa..8deb55f 100644
--- a/drivers/net/cxgb3/adapter.h
+++ b/drivers/net/cxgb3/adapter.h
@@ -276,6 +276,14 @@ static inline struct port_info *adap2pinfo(struct adapter *adap, int idx)
 	return netdev_priv(adap->port[idx]);
 }
 
+static inline int phy2portid(struct cphy *phy)
+{
+	struct adapter *adap = phy->adapter;
+	struct port_info *port0 = adap2pinfo(adap, 0);
+
+	return &port0->phy == phy ? 0 : 1;
+}
+
 #define OFFLOAD_DEVMAP_BIT 15
 
 #define tdev2adap(d) container_of(d, struct adapter, tdev)
diff --git a/drivers/net/cxgb3/ael1002.c b/drivers/net/cxgb3/ael1002.c
index 3b98984..45daccd 100644
--- a/drivers/net/cxgb3/ael1002.c
+++ b/drivers/net/cxgb3/ael1002.c
@@ -1643,9 +1643,39 @@ static int ael2020_get_module_type(struct cphy *phy, int delay_ms)
  */
 static int ael2020_intr_enable(struct cphy *phy)
 {
-	int err = mdio_write(phy, MDIO_DEV_PMA_PMD, AEL2020_GPIO_CTRL,
-				0x2 << (AEL2020_GPIO_MODDET*4));
-	return err ? err : t3_phy_lasi_intr_enable(phy);
+ 	struct reg_val regs[] = {
+ 		/* output Module's Loss Of Signal (LOS) to LED */
+ 		{ MDIO_DEV_PMA_PMD, AEL2020_GPIO_CFG+AEL2020_GPIO_LSTAT,
+ 			0xffff, 0x4 },
+ 		{ MDIO_DEV_PMA_PMD, AEL2020_GPIO_CTRL,
+ 			0xffff, 0x8 << (AEL2020_GPIO_LSTAT*4) },
+ 
+ 		 /* enable module detect status change interrupts */
+ 		{ MDIO_DEV_PMA_PMD, AEL2020_GPIO_CTRL,
+ 			0xffff, 0x2 << (AEL2020_GPIO_MODDET*4) },
+ 
+ 		/* end */
+ 		{ 0, 0, 0, 0 }
+ 	};
+ 	int err, link_ok = 0;
+ 
+ 	/* set up "link status" LED and enable module change interrupts */
+ 	err = set_phy_regs(phy, regs);
+ 	if (err)
+ 		return err;
+ 
+ 	err = get_link_status_r(phy, &link_ok, NULL, NULL, NULL);
+ 	if (err)
+ 		return err;
+ 	if (link_ok)
+ 		t3_link_changed(phy->adapter,
+ 				phy2portid(phy));
+ 
+ 	err = t3_phy_lasi_intr_enable(phy);
+ 	if (err)
+ 		return err;
+ 
+ 	return 0;
 }
 
 /*
@@ -1653,9 +1683,26 @@ static int ael2020_intr_enable(struct cphy *phy)
  */
 static int ael2020_intr_disable(struct cphy *phy)
 {
-	int err = mdio_write(phy, MDIO_DEV_PMA_PMD, AEL2020_GPIO_CTRL,
-				0x1 << (AEL2020_GPIO_MODDET*4));
-	return err ? err : t3_phy_lasi_intr_disable(phy);
+ 	struct reg_val regs[] = {
+ 		/* reset "link status" LED to "off" */
+ 		{ MDIO_DEV_PMA_PMD, AEL2020_GPIO_CTRL,
+ 			0xffff, 0xb << (AEL2020_GPIO_LSTAT*4) },
+ 
+ 		/* disable module detect status change interrupts */
+ 		{ MDIO_DEV_PMA_PMD, AEL2020_GPIO_CTRL,
+ 			0xffff, 0x1 << (AEL2020_GPIO_MODDET*4) },
+ 
+ 		/* end */
+ 		{ 0, 0, 0, 0 }
+ 	};
+ 	int err;
+ 
+ 	/* turn off "link status" LED and disable module change interrupts */
+ 	err = set_phy_regs(phy, regs);
+ 	if (err)
+ 		return err;
+ 
+ 	return t3_phy_lasi_intr_disable(phy);
 }
 
 /*
@@ -1673,31 +1720,27 @@ static int ael2020_intr_clear(struct cphy *phy)
 	return err ? err : t3_phy_lasi_intr_clear(phy);
 }
 
+static struct reg_val ael2020_reset_regs[] = {
+	/* Erratum #2: CDRLOL asserted, causing PMA link down status */
+ 	{ MDIO_DEV_PMA_PMD, 0xc003, 0xffff, 0x3101 },
+ 
+ 	/* force XAUI to send LF when RX_LOS is asserted */
+ 	{ MDIO_DEV_PMA_PMD, 0xcd40, 0xffff, 0x0001 },
+ 
+ 	/* allow writes to transceiver module EEPROM on i2c bus */
+ 	{ MDIO_DEV_PMA_PMD, 0xff02, 0xffff, 0x0023 },
+ 	{ MDIO_DEV_PMA_PMD, 0xff03, 0xffff, 0x0000 },
+ 	{ MDIO_DEV_PMA_PMD, 0xff04, 0xffff, 0x0000 },
+ 
+ 	/* end */
+ 	{ 0, 0, 0, 0 }
+};
+
 /*
  * Reset the PHY and put it into a canonical operating state.
  */
 static int ael2020_reset(struct cphy *phy, int wait)
 {
-	static struct reg_val regs0[] = {
-		/* Erratum #2: CDRLOL asserted, causing PMA link down status */
-		{ MDIO_DEV_PMA_PMD, 0xc003, 0xffff, 0x3101 },
-
-		/* force XAUI to send LF when RX_LOS is asserted */
-		{ MDIO_DEV_PMA_PMD, 0xcd40, 0xffff, 0x0001 },
-
-		/* RX_LOS pin is active high */
-		{ MDIO_DEV_PMA_PMD, AEL_OPT_SETTINGS,
-			0x0020, 0x0020 },
-
-		/* output Module's Loss Of Signal (LOS) to LED */
-		{ MDIO_DEV_PMA_PMD, AEL2020_GPIO_CFG+AEL2020_GPIO_LSTAT,
-			0xffff, 0x0004 },
-		{ MDIO_DEV_PMA_PMD, AEL2020_GPIO_CTRL,
-			0xffff, 0x8 << (AEL2020_GPIO_LSTAT*4) },
-
-		/* end */
-		{ 0, 0, 0, 0 }
-	};
 	int err;
 	unsigned int lasi_ctrl;
 
@@ -1713,7 +1756,7 @@ static int ael2020_reset(struct cphy *phy, int wait)
 
 	/* basic initialization for all module types */
 	phy->priv = edc_none;
-	err = set_phy_regs(phy, regs0);
+	err = set_phy_regs(phy, ael2020_reset_regs);
 	if (err)
 		return err;
 
@@ -1790,10 +1833,16 @@ static struct cphy_ops ael2020_ops = {
 int t3_ael2020_phy_prep(struct cphy *phy, struct adapter *adapter, int phy_addr,
 			const struct mdio_ops *mdio_ops)
 {
+	int err;
+
 	cphy_init(phy, adapter, phy_addr, &ael2020_ops, mdio_ops,
 		  SUPPORTED_10000baseT_Full | SUPPORTED_AUI | SUPPORTED_FIBRE |
 		  SUPPORTED_IRQ, "10GBASE-R");
 	msleep(125);
+
+	err = set_phy_regs(phy, ael2020_reset_regs);
+	if (err)
+		return err;
 	return 0;
 }
 
