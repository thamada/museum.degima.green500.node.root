commit 40e1cb4dbea45bee305328cdaeb73990f4b432be
Author: Vladimir Sokolovsky <vlad@mellanox.co.il>
Date:   Mon Nov 24 13:31:48 2008 +0200

    IPoIB: Prevent address handles leak.
    
    When removing the ib_ipoib module, ipoib_ib_dev_stop() is
    called and all address handles (ah) in the dead_ahs list are reaped.
    However, some ah's may be still be added to the dead list by ipoib_mcast_free()
    after ipoib_ib_dev_stop() is called. These ah's will not be freed.
    
    The solution is to reap any remaining ah's after multicast device is really
    flushed during cleanup.
    
    Based on a recommendation by Yossi Etigin.
    This fixes Bugzilla https://bugs.openfabrics.org/show_bug.cgi?id=1410
    
    Signed-off-by: Vladimir Sokolovsky <vlad@mellanox.co.il>

diff --git a/drivers/infiniband/ulp/ipoib/ipoib_ib.c b/drivers/infiniband/ulp/ipoib/ipoib_ib.c
index 66cafa2..2b77bbd 100644
--- a/drivers/infiniband/ulp/ipoib/ipoib_ib.c
+++ b/drivers/infiniband/ulp/ipoib/ipoib_ib.c
@@ -640,6 +640,25 @@ void ipoib_reap_ah(struct work_struct *work)
 				   round_jiffies_relative(HZ));
 }
 
+static void ipoib_ah_dev_cleanup(struct net_device *dev)
+{
+	struct ipoib_dev_priv *priv = netdev_priv(dev);
+	unsigned long begin;
+
+	begin = jiffies;
+
+	while (!list_empty(&priv->dead_ahs)) {
+		__ipoib_reap_ah(dev);
+
+		if (time_after(jiffies, begin + HZ)) {
+			ipoib_warn(priv, "timing out; will leak address handles\n");
+			break;
+		}
+
+		msleep(1);
+	}
+}
+
 static void ipoib_ib_tx_timer_func(unsigned long ctx)
 {
 	drain_tx_cq((struct net_device *)ctx);
@@ -861,18 +880,7 @@ timeout:
 	if (flush)
 		flush_workqueue(ipoib_workqueue);
 
-	begin = jiffies;
-
-	while (!list_empty(&priv->dead_ahs)) {
-		__ipoib_reap_ah(dev);
-
-		if (time_after(jiffies, begin + HZ)) {
-			ipoib_warn(priv, "timing out; will leak address handles\n");
-			break;
-		}
-
-		msleep(1);
-	}
+	ipoib_ah_dev_cleanup(dev);
 
 	ib_req_notify_cq(priv->recv_cq, IB_CQ_NEXT_COMP);
 
@@ -1005,6 +1013,7 @@ void ipoib_ib_dev_cleanup(struct net_device *dev)
 	ipoib_mcast_stop_thread(dev, 1);
 	ipoib_mcast_dev_flush(dev);
 
+	ipoib_ah_dev_cleanup(dev);
 	ipoib_transport_dev_cleanup(dev);
 }
 
