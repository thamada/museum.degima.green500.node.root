cxgb3: allow reading/writing of T3 regs via cxgb3tool.

From: Steve Wise <swise@opengridcomputing.com>


---

 drivers/net/cxgb3/cxgb3_ioctl.h |    2 ++
 drivers/net/cxgb3/cxgb3_main.c  |   24 ++++++++++++++++++++++++
 2 files changed, 26 insertions(+), 0 deletions(-)


diff --git a/drivers/net/cxgb3/cxgb3_ioctl.h b/drivers/net/cxgb3/cxgb3_ioctl.h
index b19e437..385a91a 100644
--- a/drivers/net/cxgb3/cxgb3_ioctl.h
+++ b/drivers/net/cxgb3/cxgb3_ioctl.h
@@ -36,6 +36,8 @@
  * Ioctl commands specific to this driver.
  */
 enum {
+	CHELSIO_SETREG			= 1024,
+	CHELSIO_GETREG			= 1025,
 	CHELSIO_GETMTUTAB 		= 1029,
 	CHELSIO_SETMTUTAB 		= 1030,
 	CHELSIO_SET_PM 			= 1032,
diff --git a/drivers/net/cxgb3/cxgb3_main.c b/drivers/net/cxgb3/cxgb3_main.c
index c97ab82..94a0e5c 100644
--- a/drivers/net/cxgb3/cxgb3_main.c
+++ b/drivers/net/cxgb3/cxgb3_main.c
@@ -1996,6 +1996,30 @@ static int cxgb_extension_ioctl(struct net_device *dev, void __user *useraddr)
 		return -EFAULT;
 
 	switch (cmd) {
+	case CHELSIO_SETREG: {
+		struct ch_reg edata;
+
+		if (!capable(CAP_NET_ADMIN))
+			return -EPERM;
+		if (copy_from_user(&edata, useraddr, sizeof(edata)))
+			return -EFAULT;
+		if ((edata.addr & 3) != 0 || edata.addr >= adapter->mmio_len)
+			return -EINVAL;
+		writel(edata.val, adapter->regs + edata.addr);
+		break;
+	}
+	case CHELSIO_GETREG: {
+		struct ch_reg edata;
+
+		if (copy_from_user(&edata, useraddr, sizeof(edata)))
+			return -EFAULT;
+		if ((edata.addr & 3) != 0 || edata.addr >= adapter->mmio_len)
+			return -EINVAL;
+		edata.val = readl(adapter->regs + edata.addr);
+		if (copy_to_user(useraddr, &edata, sizeof(edata)))
+			return -EFAULT;
+		break;
+	}
 	case CHELSIO_SET_QSET_PARAMS:{
 		int i;
 		struct qset_params *q;
