commit 483fe703b03b1db99fa4a968fc3a918aa43f856f
Author: Eli Cohen <eli@mellanox.co.il>
Date:   Wed Feb 3 13:10:14 2010 +0200

    CMA: Fix iWarp failures to bind to a device
    
    rdma_addr_get_sgid() relies on dev_addr->transport to retrieve the correct GID
    based on the hardware address. However, when called from cma_acquire_dev(), the
    transport field is not yet valid. The solution is to avoid calling
    rdma_addr_get_sgid() from cma_acquire_dev() and find the device based on it's
    GID: for ethernet, assume first it is rocee and search the GID table, if not
    found generate the GID by copying it from the hardware address.
    
    Signed-off-by: Eli Cohen <eli@mellanox.co.il>

diff --git a/drivers/infiniband/core/cma.c b/drivers/infiniband/core/cma.c
index a2d5aad..3c5c59f 100644
--- a/drivers/infiniband/core/cma.c
+++ b/drivers/infiniband/core/cma.c
@@ -348,15 +348,29 @@ static int cma_acquire_dev(struct rdma_id_private *id_priv)
 	union ib_gid gid;
 	int ret = -ENODEV;
 
-	rdma_addr_get_sgid(dev_addr, &gid);
+	if (dev_addr->dev_type != ARPHRD_INFINIBAND) {
+		rocee_addr_get_sgid(dev_addr, &gid);
+		list_for_each_entry(cma_dev, &dev_list, list) {
+			ret = ib_find_cached_gid(cma_dev->device, &gid,
+						 &id_priv->id.port_num, NULL);
+			if (!ret)
+				goto out;
+		}
+	}
+
+	memcpy(&gid, dev_addr->src_dev_addr +
+	       rdma_addr_gid_offset(dev_addr), sizeof gid);
 	list_for_each_entry(cma_dev, &dev_list, list) {
 		ret = ib_find_cached_gid(cma_dev->device, &gid,
 					 &id_priv->id.port_num, NULL);
-		if (!ret) {
-			cma_attach_to_dev(id_priv, cma_dev);
+		if (!ret)
 			break;
-		}
 	}
+
+out:
+	if (!ret)
+		cma_attach_to_dev(id_priv, cma_dev);
+
 	return ret;
 }
 
