commit 3a7eeafbb06b23556fefc78d817d047941cf3582
Author: Mitko Haralanov <mitko@qlogic.com>
Date:   Mon Dec 7 16:54:36 2009 -0800

    IB/qib: fix IPoIB device stop deadlock
    
    We create our own workqueue mainly because we want to be
    able to flush it when devices are being removed.  We can't
    use schedule_work()/flush_scheduled_work() because both
    unregister_netdev() and linkwatch_event take the rtnl lock,
    so flush_scheduled_work() can deadlock during device
    removal.
    
    INTERNAL: bug 114557
    
    Signed-off-by: Mitko Haralanov <mitko@qlogic.com>

diff --git a/drivers/infiniband/hw/qib/qib_init.c b/drivers/infiniband/hw/qib/qib_init.c
index a5fdd72..a41b4c4 100644
--- a/drivers/infiniband/hw/qib/qib_init.c
+++ b/drivers/infiniband/hw/qib/qib_init.c
@@ -80,6 +80,8 @@ unsigned qib_wc_pat = 1; /* default (1) is to use PAT, not MTRR */
 module_param_named(wc_pat, qib_wc_pat, uint, S_IRUGO);
 MODULE_PARM_DESC(wc_pat, "enable write-combining via PAT mechanism");
 
+struct workqueue_struct *qib_wq;
+
 static void verify_interrupt(unsigned long);
 
 static struct idr qib_unit_table;
@@ -1063,6 +1065,16 @@ static int __init qlogic_ib_init(void)
 		goto bail_dev;
 
 	/*
+	 * We create our own workqueue mainly because we want to be
+	 * able to flush it when devices are being removed.  We can't
+	 * use schedule_work()/flush_scheduled_work() because both
+	 * unregister_netdev() and linkwatch_event take the rtnl lock,
+	 * so flush_scheduled_work() can deadlock during device
+	 * removal.
+	 */
+	qib_wq = create_workqueue("qib");
+
+	/*
 	 * These must be called before the driver is registered with
 	 * the PCI subsystem.
 	 */
@@ -1128,6 +1140,8 @@ static void __exit qlogic_ib_cleanup(void)
 		qib_dbg("WC PAT mechanism is disabled\n");
 	}
 
+	destroy_workqueue(qib_wq);
+
 	idr_destroy(&qib_unit_table);
 	qib_trace_fini();
 	qib_dev_cleanup();
diff --git a/drivers/infiniband/hw/qib/qib_verbs.h b/drivers/infiniband/hw/qib/qib_verbs.h
index 20c8ec1..4a2f20d 100644
--- a/drivers/infiniband/hw/qib/qib_verbs.h
+++ b/drivers/infiniband/hw/qib/qib_verbs.h
@@ -804,6 +804,8 @@ static inline int qib_send_ok(struct qib_qp *qp)
 		 !(qp->s_flags & QIB_S_ANY_WAIT_SEND));
 }
 
+extern struct workqueue_struct *qib_wq;
+
 /*
  * This must be called with s_lock held.
  */
@@ -811,9 +813,10 @@ static inline void qib_schedule_send(struct qib_qp *qp)
 {
 	if (qib_send_ok(qp)) {
 		if (qp->processor_id == smp_processor_id())
-			schedule_work(&qp->s_work);
+			queue_work(qib_wq, &qp->s_work);
 		else
-			schedule_work_on(qp->processor_id, &qp->s_work);
+			queue_work_on(qp->processor_id,
+				      qib_wq, &qp->s_work);
 	}
 }
 
