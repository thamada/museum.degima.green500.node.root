diff -up a/drivers/infiniband/hw/qib/qib.h b/drivers/infiniband/hw/qib/qib.h
--- a/drivers/infiniband/hw/qib/qib.h	2009-12-15 13:40:25.000000000 -0800
+++ b/drivers/infiniband/hw/qib/qib.h	2009-12-16 09:42:14.000000000 -0800
@@ -967,6 +967,7 @@ struct qib_devdata {
 	u8 gpio_sda_num;
 	u8 gpio_scl_num;
 	u8 twsi_eeprom_dev;
+	u8 board_atten;
 
 	/* Support (including locks) for EEPROM logging of errors and time */
 	/* control access to actual counters, timer */
Only in b/drivers/infiniband/hw/qib: qib.h.orig
diff -up a/drivers/infiniband/hw/qib/qib_iba7322.c b/drivers/infiniband/hw/qib/qib_iba7322.c
--- a/drivers/infiniband/hw/qib/qib_iba7322.c	2009-12-15 13:40:25.000000000 -0800
+++ b/drivers/infiniband/hw/qib/qib_iba7322.c	2009-12-16 16:36:22.000000000 -0800
@@ -121,7 +121,7 @@ module_param_call(qmh_serdes_setup, setu
 #define KREG_IBPORT_IDX(regname) ((QIB_7322_##regname##_0_OFFS / sizeof(u64)))
 
 #define MASK_ACROSS(lsb, msb) \
-  (((1ULL << ((msb)+1-(lsb))) - 1) << (lsb))
+	(((1ULL << ((msb)+1-(lsb))) - 1) << (lsb))
 
 #define SYM_RMASK(regname, fldname) ((u64)              \
 	QIB_7322_##regname##_##fldname##_RMASK)
@@ -509,8 +509,16 @@ struct qib_chip_specific {
 struct txdds_ent {
 	u8 amp;
 	u8 pre;
-	u8 post;
 	u8 main;
+	u8 post;
+};
+
+struct vendor_txdds_ent {
+	u8 oui[QSFP_VOUI_LEN];
+	u8 *partnum;
+	struct txdds_ent sdr;
+	struct txdds_ent ddr;
+	struct txdds_ent qdr;
 };
 
 #define TXDDS_TABLE_SZ 16 /* number of entries per speed in onchip table */
@@ -538,13 +546,13 @@ struct txdds_ent {
 
 #define QDR_DFE_DISABLE_DELAY 4000 /* msec after LINKUP */
 
-static const struct txdds_ent qmh_sdr_txdds =  { 11, 0,  6, 5 };
-static const struct txdds_ent qmh_ddr_txdds =  {  7, 0,  8, 2 };
-static const struct txdds_ent qmh_qdr_txdds =  {  0, 1, 10, 3 };
-
-static const struct txdds_ent qme_sdr_txdds =  { 11, 0,  4,  4};
-static const struct txdds_ent qme_ddr_txdds =  {  7, 0,  7,  2};
-static const struct txdds_ent qme_qdr_txdds =  {  0, 1, 14, 12};
+static const struct txdds_ent qmh_sdr_txdds =  { 11, 0,  5,  6 };
+static const struct txdds_ent qmh_ddr_txdds =  {  7, 0,  2,  8 };
+static const struct txdds_ent qmh_qdr_txdds =  {  0, 1,  3, 10 };
+
+static const struct txdds_ent qme_sdr_txdds =  { 11, 0,  4,  4 };
+static const struct txdds_ent qme_ddr_txdds =  {  7, 0,  2,  7 };
+static const struct txdds_ent qme_qdr_txdds =  {  0, 1, 12, 14 };
 
 struct qib_chippport_specific {
 	u64 __iomem *kpregbase;
@@ -587,8 +595,8 @@ struct qib_chippport_specific {
 	u16 h1_val;
 	u8 amp[SERDES_CHANS];
 	u8 pre[SERDES_CHANS];
-	u8 post[SERDES_CHANS];
 	u8 mainv[SERDES_CHANS];
+	u8 post[SERDES_CHANS];
 	u8 ipg_tries;
 	u8 switch_port;
 	u8 ibmalfusesnap;
@@ -1767,13 +1775,11 @@ static void handle_serdes_issues(struct
 
 	if (!ppd->cpspec->qdr_dfe_on && ibclt != IB_7322_LT_STATE_LINKUP &&
 	    ibclt <= IB_7322_LT_STATE_SLEEPQUIET) {
-		/* link down, reenable QDR DFE */
 		ppd->cpspec->qdr_dfe_on = 1;
 		ppd->cpspec->qdr_dfe_time = 0;
-		/* force cmode off, let H0 and other adaptation work */
-		ahb_mod(ppd->dd, IBSD(ppd->hw_pidx), 5, 10, 0 << 14, 1 << 14);
+		/* On link down, reenable all QDR adaptation */
 		qib_write_kreg_port(ppd, krp_static_adapt_dis(2), 0ULL);
-		qib_cdbg(LINKVERB, "IB%u:%u re-enabled QDR adaptation\n"
+		qib_cdbg(LINKVERB, "IB%u:%u re-enabled QDR adaptation "
 			 "ibclt %x\n", ppd->dd->unit, ppd->port, ibclt);
 	}
 }
@@ -3524,6 +3530,7 @@ static unsigned qib_7322_boardname(struc
 		qib_dev_err(dd, "Unknown 7322 board type %u\n", boardid);
 		break;
 	}
+	dd->board_atten = 1; /* index into txdds_Xdr */
 
 	namelen = strlen(n) + 1;
 	dd->boardname = kmalloc(namelen, GFP_KERNEL);
@@ -5100,16 +5107,12 @@ static void qib_get_7322_faststats(unsig
 		    time_after64(get_jiffies_64(), ppd->cpspec->qdr_dfe_time)) {
 			ppd->cpspec->qdr_dfe_on = 0;
 
-			qib_cdbg(LINKVERB, "IB%u:%u Disable QDR DFE, set H1\n",
-				 ppd->dd->unit, ppd->port);
-			/* disable all DFE bits, not LE or gain */
+			qib_cdbg(LINKVERB, "IB%u:%u Disable QDR DFE, gain\n",
+				ppd->dd->unit, ppd->port);
+			/* disable all DFE bits, and gain (H0), not LE */
 			qib_write_kreg_port(ppd, krp_static_adapt_dis(2),
-				0xFFULL * 0x1010101ULL);
+				0xf0ffffffffULL);
 			force_h1(ppd);
-			/* force cmode on, and freeze H0 (gain) */
-			ahb_mod(ppd->dd, IBSD(ppd->hw_pidx), 5, 10,
-				1 << 14, 1 << 14);
-			ibsd_wr_allchans(ppd, 1, 0 << 1, 1 << 1);
 		}
 	}
 	mod_timer(&dd->stats_timer, jiffies + HZ * ACTIVITY_TIMER);
@@ -6393,8 +6396,8 @@ static int qib_init_7322_variables(struc
 			for (i = 0; i < SERDES_CHANS; i++) {
 				cp->amp[i] = qmh_qdr_txdds.amp;
 				cp->pre[i] = qmh_qdr_txdds.pre;
-				cp->post[i] = qmh_qdr_txdds.post;
 				cp->mainv[i] = qmh_qdr_txdds.main;
+				cp->post[i] = qmh_qdr_txdds.post;
 			}
 		} else if (IS_QME(ppd->dd))
 			cp->h1_val = H1_FORCE_QME;
@@ -7160,13 +7163,12 @@ bail:
 	return dd;
 }
 
-
 /*
  * Set the table entry at the specified index from the table specifed.
- * There are 3 * TXDDS_TABLE_SZ  entries in all per port, with the first
+ * There are 3 * TXDDS_TABLE_SZ entries in all per port, with the first
  * TXDDS_TABLE_SZ for SDR, the next for DDR, and the last for QDR.
  * 'idx' below addresses the correct entry, while its 4 LSBs select the
- * corresponding entry (one of TXDDS_TABLE_SZ ) from the selected table.
+ * corresponding entry (one of TXDDS_TABLE_SZ) from the selected table.
  */
 #define DDS_ENT_AMP_LSB 14
 #define DDS_ENT_MAIN_LSB 9
@@ -7206,151 +7208,212 @@ static void set_txdds(struct qib_pportda
 	if ((ridx & 0xF) == 0)
 		qib_cdbg(LINKVERB, "IB%u:%u %cDR TxDDS: %d, %d, %d, %d\n",
 			 ppd->dd->unit, ppd->port, "SDQ"[ridx >> 4],
-			 tp->amp, tp->pre, tp->post, tp->main);
+			 tp->amp, tp->pre, tp->main, tp->post);
 }
 
+static const struct vendor_txdds_ent vendor_txdds[] = {
+	{ /* Amphenol 1m 30awg NoEq */
+		{ 0x41, 0x50, 0x48 }, "584470002       ",
+		{ 10,  0,  0,  5 }, { 10,  0,  0,  9 }, {  7,  1,  0, 13 },
+	},
+	{ /* Amphenol 3m 28awg NoEq */
+		{ 0x41, 0x50, 0x48 }, "584470004       ",
+		{  0,  0,  0,  8 }, {  0,  0,  0, 11 }, {  0,  1,  7, 15 },
+	},
+	{ /* Finisar 30m OM2 Optical */
+		{ 0x00, 0x90, 0x65 }, "CBL2-1003001    ",
+		{  0,  0,  0,  1 }, {  0,  0,  0,  5 }, {  0,  0,  0, 10 },
+	},
+	{ /* Gore 1m 30awg NoEq */
+		{ 0x00, 0x21, 0x77 }, "QSN3300-1       ",
+		{  0,  0,  0,  6 }, {  0,  0,  0,  9 }, {  0,  1,  0, 15 },
+	},
+	{ /* Gore 2m 30awg NoEq */
+		{ 0x00, 0x21, 0x77 }, "QSN3300-2       ",
+		{  0,  0,  0,  8 }, {  0,  0,  0, 10 }, {  0,  1,  7, 15 },
+	},
+	{ /* Gore 1m 28awg NoEq */
+		{ 0x00, 0x21, 0x77 }, "QSN3800-1       ",
+		{  0,  0,  0,  6 }, {  0,  0,  0,  8 }, {  0,  1,  0, 15 },
+	},
+	{ /* Gore 3m 28awg NoEq */
+		{ 0x00, 0x21, 0x77 }, "QSN3800-3       ",
+		{  0,  0,  0,  9 }, {  0,  0,  0, 13 }, {  0,  1,  7, 15 },
+	},
+	{ /* Gore 5m 24awg Eq */
+		{ 0x00, 0x21, 0x77 }, "QSN7000-5       ",
+		{  0,  0,  0,  7 }, {  0,  0,  0,  9 }, {  0,  1,  3, 15 },
+	},
+	{ /* Gore 7m 24awg Eq */
+		{ 0x00, 0x21, 0x77 }, "QSN7000-7       ",
+		{  0,  0,  0,  9 }, {  0,  0,  0, 11 }, {  0,  2,  6, 15 },
+	},
+	{ /* Gore 3m 26awg Eq */
+		{ 0x00, 0x21, 0x77 }, "QSN7600-3       ",
+		{ 11,  0,  3,  9 }, {  8,  0,  6,  1 }, {  0,  1, 15, 10 },
+	},
+	{ /* Gore 5m 26awg Eq */
+		{ 0x00, 0x21, 0x77 }, "QSN7600-5       ",
+		{  0,  0,  0,  8 }, {  0,  0,  0, 11 }, {  0,  1,  9, 13 },
+	},
+	{ /* Intersil 12m 24awg Active */
+		{ 0x00, 0x30, 0xB4 }, NULL,
+		{  0,  0,  0,  2 }, {  0,  0,  0,  5 }, {  0,  3,  0,  9 },
+	},
+	{ /* Molex 1M Cu loopback */
+		{ 0x00, 0x09, 0x3A }, "74763-0025      ",
+		{  2,  2,  6, 15 }, {  2,  2,  6, 15 }, {  2,  2,  6, 15 },
+	},
+	{ /* Molex 2m 28awg NoEq */
+		{ 0x00, 0x09, 0x3A }, "74757-2201      ",
+		{  0,  0,  0,  6 }, {  0,  0,  0,  9 }, {  0,  1,  1, 15 },
+	},
+};
+
 static const struct txdds_ent txdds_sdr[TXDDS_TABLE_SZ] = {
-	/* amp, pre, post, main */
-	{  2, 2,  6, 15},	/* Loopback */
-	{ 15, 0,  4, 13},	/* Luxtera Optical */
-	{ 14, 0,  2,  6},	/* 1M Gore */
-	{ 11, 0,  3,  9},	/* 3M Gore */
-	{ 11, 0,  4,  9},	/* 4M Gore */
-	{ 11, 0,  5,  9},	/* 5M Gore */
-	{ 11, 0,  6,  5},	/* 6M Gore */
-	{ 11, 0,  4,  4},	/* 7M Gore */
-	{  5, 1,  5, 15},	/* 0.5M Amphenol 30AWG (P/N 584470001) */
-	{  5, 1,  6, 15},	/* 1M Amphenol 30AWG (P/N 584470002) */
-	{  2, 1, 14,  5},	/* 3M Amphenol 28AWG (P/N 584470004) */
-	{  2, 1,  5, 15},	/* 3M Gore 28AWG Uneq (P/N QSN3800-3 Rev A) */
-	{ 15, 0,  6,  1},	/* 3M Finisar Optical (P/N CBL2-1000301-3) */
-	{ 11, 0,  4,  4},	/* 7M Gore */
-	{ 11, 0,  4,  4},	/* 7M Gore */
-	{ 11, 0,  4,  4},	/* 7M Gore */
+	/* amp, pre, main, post */
+	{  2, 2, 15,  6 },	/* Loopback */
+	{  0, 0,  0,  1 },	/*  2 dB */
+	{  0, 0,  0,  2 },	/*  3 dB */
+	{  0, 0,  0,  3 },	/*  4 dB */
+	{  0, 0,  0,  4 },	/*  5 dB */
+	{  0, 0,  0,  5 },	/*  6 dB */
+	{  0, 0,  0,  6 },	/*  7 dB */
+	{  0, 0,  0,  7 },	/*  8 dB */
+	{  0, 0,  0,  8 },	/*  9 dB */
+	{  0, 0,  0,  9 },	/* 10 dB */
+	{  0, 0,  0, 10 },	/* 11 dB */
+	{  0, 0,  0, 11 },	/* 12 dB */
+	{  0, 0,  0, 12 },	/* 13 dB */
+	{  0, 0,  0, 13 },	/* 14 dB */
+	{  0, 0,  0, 14 },	/* 15 dB */
+	{  0, 0,  0, 15 },	/* 16 dB */
 };
 
 static const struct txdds_ent txdds_ddr[TXDDS_TABLE_SZ] = {
-	/* amp, pre, post, main */
-	{  2, 2,  6, 15},	/* Loopback */
-	{ 15, 0,  5, 13},	/* Luxtera Optical */
-	{ 11, 0,  4,  6},	/* 1M Gore */
-	{  8, 0,  6,  1},	/* 3M Gore */
-	{  8, 0,  5,  2},	/* 4M Gore */
-	{  8, 0,  6,  2},	/* 5M Gore */
-	{  7, 0,  8,  2},	/* 6M Gore */
-	{  7, 0,  7,  2},	/* 7M Gore */
-	{  5, 1,  5, 15},	/* 0.5M Amphenol 30AWG (P/N 584470001) */
-	{  5, 1,  6, 15},	/* 1M Amphenol 30AWG (P/N 584470002) */
-	{  2, 1, 14,  5},	/* 3M Amphenol 28AWG (P/N 584470004) */
-	{  2, 1,  5, 15},	/* 3M Gore 28AWG Uneq (P/N QSN3800-3 Rev A) */
-	{ 15, 0,  6,  1},	/* 3M Finisar Optical (P/N CBL2-1000301-3) */
-	{  7, 0,  7,  2},	/* 7M Gore */
-	{  7, 0,  7,  2},	/* 7M Gore */
-	{  7, 0,  7,  2},	/* 7M Gore */
+	/* amp, pre, main, post */
+	{  2, 2, 15,  6 },	/* Loopback */
+	{  0, 0,  0,  8 },	/*  2 dB */
+	{  0, 0,  0,  8 },	/*  3 dB */
+	{  0, 0,  0,  9 },	/*  4 dB */
+	{  0, 0,  0,  9 },	/*  5 dB */
+	{  0, 0,  0, 10 },	/*  6 dB */
+	{  0, 0,  0, 10 },	/*  7 dB */
+	{  0, 0,  0, 11 },	/*  8 dB */
+	{  0, 0,  0, 11 },	/*  9 dB */
+	{  0, 0,  0, 12 },	/* 10 dB */
+	{  0, 0,  0, 12 },	/* 11 dB */
+	{  0, 0,  0, 13 },	/* 12 dB */
+	{  0, 0,  0, 13 },	/* 13 dB */
+	{  0, 0,  0, 14 },	/* 14 dB */
+	{  0, 0,  0, 14 },	/* 15 dB */
+	{  0, 0,  0, 15 },	/* 16 dB */
 };
 
 static const struct txdds_ent txdds_qdr[TXDDS_TABLE_SZ] = {
-	/* amp, pre, post, main */
-	{  2, 2,  6, 15},	/* Loopback */
-	{ 14, 0,  4, 13},	/* Luxtera Optical */
-	{  3, 1,  8, 15},	/* 1M Gore */
-	{  0, 1, 15, 10},	/* 3M Gore */
-	{  1, 1,  7, 17},	/* 4M Gore */
-	{  0, 1,  8, 14},	/* 5M Gore */
-	{  0, 1, 15, 13},	/* 6M Gore */
-	{  0, 1, 14,  3},	/* 7M Gore */
-	{  5, 1,  5, 15},	/* 0.5M Amphenol 30AWG (P/N 584470001) */
-	{  5, 1,  6, 15},	/* 1M Amphenol 30AWG (P/N 584470002) */
-	{  2, 1, 14,  5},	/* 3M Amphenol 28AWG (P/N 584470004) */
-	{  2, 1,  5, 15},	/* 3M Gore 28AWG Uneq (P/N QSN3800-3 Rev A) */
-	{ 15, 0,  6,  1},	/* 3M Finisar Optical (P/N CBL2-1000301-3) */
-	{  0, 1, 14,  3},	/* 7M Gore */
-	{  0, 1, 14,  3},	/* 7M Gore */
-	{  0, 1, 14,  3},	/* 7M Gore */
+	/* amp, pre, main, post */
+	{  2, 2, 15,  6 },	/* Loopback */
+	{  0, 1,  0,  7 },	/*  2 dB */
+	{  0, 1,  0,  9 },	/*  3 dB */
+	{  0, 1,  0, 11 },	/*  4 dB */
+	{  0, 1,  0, 13 },	/*  5 dB */
+	{  0, 1,  0, 15 },	/*  6 dB */
+	{  0, 1,  3, 15 },	/*  7 dB */
+	{  0, 1,  7, 15 },	/*  8 dB */
+	{  0, 1,  7, 15 },	/*  9 dB */
+	{  0, 1,  8, 15 },	/* 10 dB */
+	{  0, 1,  9, 15 },	/* 11 dB */
+	{  0, 1, 10, 15 },	/* 12 dB */
+	{  0, 2,  6, 15 },	/* 13 dB */
+	{  0, 2,  7, 15 },	/* 14 dB */
+	{  0, 2,  8, 15 },	/* 15 dB */
+	{  0, 2,  9, 15 },	/* 16 dB */
 };
 
-/* Initialize all TxDDS table entries for a port,
- * making a "best guess" entry the default, if
- * we have info to guess. This is an end-run around
- * IBTA1.2 negotiation which picks the "first working"
- * entry rather than the "best working" entry.
- */
-/*
- * First-cut map "length" from QSFP to entry in table
- * that best matches, rounding up (e.g. 2M len -> 3M entry)
- */
-static const u8 dds_len_map[] = {
-	0, 2, 3, 3, /* 0, 1, 2, 3 Meter */
-	4, 5, 6, 7  /* 4, 5, 6, 7 Meter*/
-};
-static const u8 dds_len_map_amp[] = {
-	8, 9, 10, 10, /* 0, 1, 2, 3 Meter */
-	4, 5,  6,  7  /* 4, 5, 6, 7 Meter*/
-};
-#define DDS_1490         1 /* Luxtera cable */
-#define DDS_GORE_3_UNEQ 11
-#define DDS_FINISAR     12 /* Finisar cable */
-#define DDS_QMH7342     13 /* QMH7342 */
+static void find_best_ent(struct qib_pportdata *ppd,
+			  const struct txdds_ent **sdr_dds,
+			  const struct txdds_ent **ddr_dds,
+			  const struct txdds_ent **qdr_dds)
+{
+	struct qib_qsfp_cache *qd = &ppd->cpspec->qsfp_data.cache;
+	int idx;
+
+	/* If there is no QSFP data, assume loopback connector */
+	if (!(ppd->dd->flags & QIB_HAS_QSFP) || !qd->id)
+		goto none;
+
+	/* Search table of known cables */
+	for (idx = 0; idx < ARRAY_SIZE(vendor_txdds); ++idx) {
+		const struct vendor_txdds_ent *v = vendor_txdds + idx;
+
+		if (!memcmp(v->oui, qd->oui, QSFP_VOUI_LEN) &&
+		    (!v->partnum ||
+		     !memcmp(v->partnum, qd->partnum, QSFP_PN_LEN))) {
+			*sdr_dds = &v->sdr;
+			*ddr_dds = &v->ddr;
+			*qdr_dds = &v->qdr;
+			return;
+		}
+	}
+
+	/* Lookup serdes setting by cable type and attenuation */
+	if (QSFP_IS_ACTIVE(qd->tech)) {
+		*sdr_dds = txdds_sdr + ppd->dd->board_atten;
+		*ddr_dds = txdds_ddr + ppd->dd->board_atten;
+		*qdr_dds = txdds_qdr + ppd->dd->board_atten;
+		return;
+	}
+
+	if (QSFP_HAS_ATTEN(qd->tech)) {
+		unsigned atten;
+
+		atten = (qd->atten[0] << 8) | qd->atten[1];
+		if (atten >= TXDDS_TABLE_SZ)
+			atten = TXDDS_TABLE_SZ - 1;
+		*sdr_dds = txdds_sdr + atten;
+		*ddr_dds = txdds_ddr + atten;
+		*qdr_dds = txdds_qdr + atten;
+		return;
+	}
+
+none:
+	*sdr_dds = &txdds_sdr[0];
+	*ddr_dds = &txdds_ddr[0];
+	*qdr_dds = &txdds_qdr[0];
+}
 
 static void init_txdds_table(struct qib_pportdata *ppd)
 {
-	int best_ent, idx, tblidx, tech;
-	struct txdds_ent *sdr_dds, *ddr_dds, *qdr_dds;
-
-	/*
-	 * Set defaults, used for all but qmh and qme, best_ent chosen based
-	 * on QSFP info, for cards with QSFP.
-	 */
-	best_ent = 0;
-	tech = ppd->cpspec->qsfp_data.cache.tech;
-	sdr_dds = (struct txdds_ent *)txdds_sdr;
-	ddr_dds = (struct txdds_ent *)txdds_ddr;
-	qdr_dds = (struct txdds_ent *)txdds_qdr;
+	const struct txdds_ent *sdr_dds, *ddr_dds, *qdr_dds;
+	int idx;
+	int single_ent = 0;
 
 	if (IS_QMH(ppd->dd)) {
 		/* normally will be overridden, via setup_qmh() */
-		sdr_dds = (struct txdds_ent *)&qmh_sdr_txdds;
-		ddr_dds = (struct txdds_ent *)&qmh_ddr_txdds;
-		qdr_dds = (struct txdds_ent *)&qmh_qdr_txdds;
+		sdr_dds = &qmh_sdr_txdds;
+		ddr_dds = &qmh_ddr_txdds;
+		qdr_dds = &qmh_qdr_txdds;
+		single_ent = 1;
 	} else if (IS_QME(ppd->dd)) {
-		sdr_dds = (struct txdds_ent *)&qme_sdr_txdds;
-		ddr_dds = (struct txdds_ent *)&qme_ddr_txdds;
-		qdr_dds = (struct txdds_ent *)&qme_qdr_txdds;
-	} else if (QSFP_IS_CU(tech)) {
-		unsigned len;
-
-		/* length field is only valid for Cu tech */
-		len = ppd->cpspec->qsfp_data.cache.len;
-		if (len >= ARRAY_SIZE(dds_len_map))
-			len = ARRAY_SIZE(dds_len_map) - 1;
-		if (memcmp(ppd->cpspec->qsfp_data.cache.partnum, "QSN3800-3",
-			   sizeof("QSN3800-3")) == 0)
-			best_ent = DDS_GORE_3_UNEQ;
-		else if (QSFP_OUI(ppd->cpspec->qsfp_data.cache.oui) ==
-				QSFP_OUI_AMPHENOL)
-			best_ent = dds_len_map_amp[len];
-		else
-			best_ent = dds_len_map[len];
-	} else if ((tech >> 4) == QSFP_TECH_1490)
-		best_ent = DDS_1490;
-	else if (QSFP_OUI(ppd->cpspec->qsfp_data.cache.oui) == QSFP_OUI_FINISAR)
-		best_ent = DDS_FINISAR;
-
-	for (idx = 0; idx < ARRAY_SIZE(txdds_sdr); ++idx) {
-		/*
-		 * Use best_ent for entry 0, then
-		 * fill in with rest. This drops
-		 * entry 15 from the set used, but
-		 * we will deal with that when
-		 * things stabilize.
-		 */
-		if (idx == 0)
-			tblidx = best_ent;
-		else
-			tblidx = idx - 1;
-		set_txdds(ppd, idx, sdr_dds + tblidx);
-		set_txdds(ppd, idx + TXDDS_TABLE_SZ, ddr_dds + tblidx);
-		set_txdds(ppd, idx + 2 * TXDDS_TABLE_SZ, qdr_dds + tblidx);
+		sdr_dds = &qme_sdr_txdds;
+		ddr_dds = &qme_ddr_txdds;
+		qdr_dds = &qme_qdr_txdds;
+		single_ent = 1;
+	} else
+		find_best_ent(ppd, &sdr_dds, &ddr_dds, &qdr_dds);
+
+	/* Fill in the first entry with the best entry found. */
+	set_txdds(ppd, 0, sdr_dds);
+	set_txdds(ppd, TXDDS_TABLE_SZ, ddr_dds);
+	set_txdds(ppd, 2 * TXDDS_TABLE_SZ, qdr_dds);
+
+	/* Fill in the remaining entries with the default table values. */
+	for (idx = 1; idx < ARRAY_SIZE(txdds_sdr); ++idx) {
+		set_txdds(ppd, idx, single_ent ? sdr_dds : txdds_sdr + idx);
+		set_txdds(ppd, idx + TXDDS_TABLE_SZ,
+			  single_ent ? ddr_dds : txdds_ddr + idx);
+		set_txdds(ppd, idx + 2 * TXDDS_TABLE_SZ,
+			  single_ent ? qdr_dds : txdds_qdr + idx);
 	}
 }
 
@@ -7482,6 +7545,9 @@ static int serdes_7322_init(struct qib_p
 	le_val = IS_QME(ppd->dd) ? 0 : 1;
 	ibsd_wr_allchans(ppd, 13, (le_val << 5), (1 << 5));
 
+	/* Clear cmode-override, may be set from older driver */
+	ahb_mod(ppd->dd, IBSD(ppd->hw_pidx), 5, 10, 0 << 14, 1 << 14);
+
 	/* Timing Recovery: rxtapsel addr 5 bits [9:8] = 0 */
 	ibsd_wr_allchans(ppd, 5, (0 << 8), BMASK(9, 8));
 
@@ -7521,8 +7587,6 @@ static int serdes_7322_init(struct qib_p
 	 * always on, and QDR is enabled until a few seconds after link
 	 * reaches LINKUP
 	 */
-	/* force cmode off a start so H0 adapt enabled */
-	ahb_mod(ppd->dd, IBSD(ppd->hw_pidx), 5, 10, 0 << 14, 1 << 14);
 	qib_write_kreg_port(ppd, krp_static_adapt_dis(0), 0ULL);
 	qib_write_kreg_port(ppd, krp_static_adapt_dis(1), 0ULL);
 	qib_write_kreg_port(ppd, krp_static_adapt_dis(2), 0ULL);
@@ -7584,7 +7648,7 @@ static void adj_qmh_serdes(struct qib_pp
 	struct txdds_ent txdds;
 	u64 deemph;
 	int i;
-	u8 *amp, *pre, *post, *mainv;
+	u8 *amp, *pre, *mainv, *post;
 
 	/*
 	 * Rest is Tx.
@@ -7594,17 +7658,17 @@ static void adj_qmh_serdes(struct qib_pp
 	 */
 	amp = ppd->cpspec->amp;
 	pre = ppd->cpspec->pre;
-	post = ppd->cpspec->post;
 	mainv = ppd->cpspec->mainv;
+	post = ppd->cpspec->post;
 
 	amp[0] &= SYM_RMASK(IBSD_TX_DEEMPHASIS_OVERRIDE_0,
 			    txampcntl_d2a);
 	mainv[0] &= SYM_RMASK(IBSD_TX_DEEMPHASIS_OVERRIDE_0,
-			    txc0_ena);
+			      txc0_ena);
 	post[0] &= SYM_RMASK(IBSD_TX_DEEMPHASIS_OVERRIDE_0,
-			   txcp1_ena);
+			     txcp1_ena);
 	pre[0] &= SYM_RMASK(IBSD_TX_DEEMPHASIS_OVERRIDE_0,
-			   txcn1_ena);
+			    txcn1_ena);
 
 	/*
 	 * Use the channel zero values, only, for now, for
@@ -7612,34 +7676,32 @@ static void adj_qmh_serdes(struct qib_pp
 	*/
 	txdds.amp = amp[0];
 	txdds.pre = pre[0];
-	txdds.post = post[0];
 	txdds.main = mainv[0];
+	txdds.post = post[0];
 
-	qib_cdbg(LINKVERB, "IB%u:%u tx amp=%u pre=%u post=%u "
-		 "main=%u\n", ppd->dd->unit, ppd->port,
-		 amp[0], pre[0], post[0],
-		 mainv[0]);
+	qib_cdbg(LINKVERB, "IB%u:%u tx amp=%u pre=%u main=%u post=%u\n",
+		 ppd->dd->unit, ppd->port,
+		 amp[0], pre[0], mainv[0], post[0]);
 
 	/* write the table for IBC use, as backup */
 	for (i = 0; i < ARRAY_SIZE(txdds_qdr); ++i)
 		set_txdds(ppd, i + 32, &txdds);
 	deemph = qib_read_kreg_port(ppd, krp_tx_deemph_override);
 	/* field names for amp, main, post, pre, respectively */
-	deemph &= ~(SYM_MASK(IBSD_TX_DEEMPHASIS_OVERRIDE_0,
-			    txampcntl_d2a) |
-		   SYM_MASK(IBSD_TX_DEEMPHASIS_OVERRIDE_0, txc0_ena) |
-		   SYM_MASK(IBSD_TX_DEEMPHASIS_OVERRIDE_0, txcp1_ena) |
-		   SYM_MASK(IBSD_TX_DEEMPHASIS_OVERRIDE_0, txcn1_ena));
+	deemph &= ~(SYM_MASK(IBSD_TX_DEEMPHASIS_OVERRIDE_0, txampcntl_d2a) |
+		    SYM_MASK(IBSD_TX_DEEMPHASIS_OVERRIDE_0, txc0_ena) |
+		    SYM_MASK(IBSD_TX_DEEMPHASIS_OVERRIDE_0, txcp1_ena) |
+		    SYM_MASK(IBSD_TX_DEEMPHASIS_OVERRIDE_0, txcn1_ena));
 	deemph |= 1ULL << SYM_LSB(IBSD_TX_DEEMPHASIS_OVERRIDE_0,
-			   tx_override_deemphasis_select);
+				  tx_override_deemphasis_select);
 	deemph |= amp[0] << SYM_LSB(IBSD_TX_DEEMPHASIS_OVERRIDE_0,
-			    txampcntl_d2a);
+				    txampcntl_d2a);
 	deemph |= mainv[0] << SYM_LSB(IBSD_TX_DEEMPHASIS_OVERRIDE_0,
-			    txc0_ena);
+				      txc0_ena);
 	deemph |= post[0] << SYM_LSB(IBSD_TX_DEEMPHASIS_OVERRIDE_0,
-			   txcp1_ena);
+				     txcp1_ena);
 	deemph |= pre[0] << SYM_LSB(IBSD_TX_DEEMPHASIS_OVERRIDE_0,
-			   txcn1_ena);
+				    txcn1_ena);
 	qib_write_kreg_port(ppd, krp_tx_deemph_override, deemph);
 }
 
diff -up a/drivers/infiniband/hw/qib/qib_qsfp.c b/drivers/infiniband/hw/qib/qib_qsfp.c
--- a/drivers/infiniband/hw/qib/qib_qsfp.c	2009-12-15 13:40:25.000000000 -0800
+++ b/drivers/infiniband/hw/qib/qib_qsfp.c	2009-12-16 09:42:14.000000000 -0800
@@ -436,11 +436,11 @@ int qib_refresh_qsfp_cache(struct qib_pp
 		qib_dev_porterr(ppd->dd, ppd->port,
 				"QSFP cks2 is %02X, computed %02X\n", cp->cks2,
 				cks);
-	ret = 0;
+	return 0;
 
 bail:
+	cp->id = 0;
 	return ret;
-
 }
 
 const char * const qib_qsfp_devtech[16] = {
@@ -511,7 +511,7 @@ void qib_qsfp_init(struct qib_qsfp_data
 			qd->ppd->dd->unit, qd->ppd->port);
 		goto bail;
 	}
-	/* We see a Mdoule, but it may be unwise to look yet. Just schedule */
+	/* We see a module, but it may be unwise to look yet. Just schedule */
 	qd->t_insert = get_jiffies_64();
 	schedule_work(&qd->work);
 bail:
diff -up a/drivers/infiniband/hw/qib/qib_qsfp.h b/drivers/infiniband/hw/qib/qib_qsfp.h
--- a/drivers/infiniband/hw/qib/qib_qsfp.h	2009-12-15 13:40:25.000000000 -0800
+++ b/drivers/infiniband/hw/qib/qib_qsfp.h	2009-12-16 09:42:14.000000000 -0800
@@ -77,6 +77,10 @@
  */
 #define QSFP_MOD_TECH_OFFS 147
 extern const char *const qib_qsfp_devtech[16];
+/* Active Equalization includes fiber, copper full EQ, and copper near Eq */
+#define QSFP_IS_ACTIVE(tech) ((0xA2FF >> ((tech) >> 4)) & 1)
+/* Attenuation should be valid for copper other than full/near Eq */
+#define QSFP_HAS_ATTEN(tech) ((0x4D00 >> ((tech) >> 4)) & 1)
 /* Length is only valid if technology is "copper" */
 #define QSFP_IS_CU(tech) ((0xED00 >> ((tech) >> 4)) & 1)
 #define QSFP_TECH_1490 9
