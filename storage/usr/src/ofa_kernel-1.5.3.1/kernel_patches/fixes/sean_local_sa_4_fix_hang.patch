>* It's possible for flush_workqueue to be called from the workqueue thread.
>
>* We hold a mutex when calling flush_workqueue, and a queued work item
>will try to acquire that same mutex.

There's no need to call flush_workqueue unless we're destroying the
port as a result of removing the device.  Can you see if the following patch
fixes your unload issue?  (I wasn't able to reproduce the original problem.)

Signed-off-by: Sean Hefty <sean.hefty@intel.com>
---
Btw, I will have the cache disabled by default when I request the pull for
2.6.23.


---
 drivers/infiniband/core/local_sa.c |    2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

Index: ofed_kernel/drivers/infiniband/core/local_sa.c
===================================================================
--- ofed_kernel.orig/drivers/infiniband/core/local_sa.c
+++ ofed_kernel/drivers/infiniband/core/local_sa.c
@@ -633,7 +633,6 @@ static void unsubscribe_port(struct sa_d
 static void cleanup_port(struct sa_db_port *port)
 {
 	unsubscribe_port(port);
-	flush_workqueue(sa_wq);
 
 	clean_update_list(port);
 	remove_all_attrs(&port->paths);
@@ -1173,6 +1172,7 @@ static void destroy_port(struct sa_db_po
 
 	ib_unregister_mad_agent(port->agent);
 	cleanup_port(port);
+	flush_workqueue(sa_wq);
 }
 
 static void sa_db_add_dev(struct ib_device *device)
