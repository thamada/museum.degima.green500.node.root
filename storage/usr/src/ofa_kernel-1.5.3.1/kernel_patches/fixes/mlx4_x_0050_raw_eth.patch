From fb0b22d037f469b8f052ec650aeed78f4d21cec9 Mon Sep 17 00:00:00 2001
From: Aleksey Senin <alekseys@voltaire.com>
Date: Mon, 14 Jun 2010 15:26:25 +0300
Subject: [PATCH 2/2] Mellanox RAW ETH support.
 Add RAW ETH support in mlx4 drivers.


Signed-off-by: Aleksey Senin <alekseys@voltaire.com>
---
 drivers/infiniband/hw/mlx4/main.c |   13 +++++++++----
 drivers/infiniband/hw/mlx4/qp.c   |   24 +++++++++++++++++++-----
 drivers/net/mlx4/mcg.c            |   20 ++++++++++++--------
 include/linux/mlx4/device.h       |    7 +++++--
 include/linux/mlx4/driver.h       |    5 +++++
 5 files changed, 50 insertions(+), 19 deletions(-)

Index: ofed_kernel-fixes/drivers/infiniband/hw/mlx4/main.c
===================================================================
--- ofed_kernel-fixes.orig/drivers/infiniband/hw/mlx4/main.c	2010-08-22 17:36:40.000000000 +0300
+++ ofed_kernel-fixes/drivers/infiniband/hw/mlx4/main.c	2010-08-22 17:36:40.000000000 +0300
@@ -660,7 +660,9 @@ static int mlx4_ib_mcg_attach(struct ib_
 	struct mlx4_ib_qp *mqp = to_mqp(ibqp);
 
 	err = mlx4_multicast_attach(mdev->dev, &mqp->mqp, gid->raw, !!(mqp->flags &
-				    MLX4_IB_QP_BLOCK_MULTICAST_LOOPBACK));
+				MLX4_IB_QP_BLOCK_MULTICAST_LOOPBACK),
+				(ibqp->qp_type == IB_QPT_RAW_ETH) ?
+				MLX4_MCAST_PROT_EN : MLX4_MCAST_PROT_IB);
 	if (err)
 		return err;
 
@@ -671,7 +673,9 @@ static int mlx4_ib_mcg_attach(struct ib_
 	return 0;
 
 err_add:
-	mlx4_multicast_detach(mdev->dev, &mqp->mqp, gid->raw);
+	mlx4_multicast_detach(mdev->dev, &mqp->mqp, gid->raw,
+				(ibqp->qp_type == IB_QPT_RAW_ETH) ?
+				MLX4_MCAST_PROT_EN : MLX4_MCAST_PROT_IB);
 	return err;
 }
 
@@ -700,8 +704,9 @@ static int mlx4_ib_mcg_detach(struct ib_
 	struct net_device *ndev;
 	struct gid_entry *ge;
 
-	err = mlx4_multicast_detach(mdev->dev,
-				    &mqp->mqp, gid->raw);
+	err = mlx4_multicast_detach(mdev->dev, &mqp->mqp, gid->raw,
+				(ibqp->qp_type == IB_QPT_RAW_ETH) ?
+				MLX4_MCAST_PROT_EN : MLX4_MCAST_PROT_IB);
 	if (err)
 		return err;
 
Index: ofed_kernel-fixes/drivers/infiniband/hw/mlx4/qp.c
===================================================================
--- ofed_kernel-fixes.orig/drivers/infiniband/hw/mlx4/qp.c	2010-08-22 17:36:40.000000000 +0300
+++ ofed_kernel-fixes/drivers/infiniband/hw/mlx4/qp.c	2010-08-22 17:39:27.655537125 +0300
@@ -815,6 +815,7 @@ struct ib_qp *mlx4_ib_create_qp(struct i
 	case IB_QPT_RC:
 	case IB_QPT_UC:
 	case IB_QPT_UD:
+	case IB_QPT_RAW_ETH:
 	{
 		qp = kzalloc(sizeof *qp, GFP_KERNEL);
 		if (!qp)
@@ -905,7 +906,8 @@ static int to_mlx4_st(enum ib_qp_type ty
 	case IB_QPT_XRC:	return MLX4_QP_ST_XRC;
 	case IB_QPT_RAW_ETY:
 	case IB_QPT_SMI:
-	case IB_QPT_GSI:	return MLX4_QP_ST_MLX;
+	case IB_QPT_GSI:
+	case IB_QPT_RAW_ETH:	return MLX4_QP_ST_MLX;
 	default:		return -1;
 	}
 }
@@ -1070,8 +1072,9 @@ static int __mlx4_ib_modify_qp(struct ib
 			break;
 		}
 	}
-
-	if (ibqp->qp_type == IB_QPT_GSI || ibqp->qp_type == IB_QPT_SMI ||
+	if (ibqp->qp_type == IB_QPT_RAW_ETH)
+		context->mtu_msgmax = 0xff;
+	else if (ibqp->qp_type == IB_QPT_GSI || ibqp->qp_type == IB_QPT_SMI ||
 	    ibqp->qp_type == IB_QPT_RAW_ETY)
 		context->mtu_msgmax = (IB_MTU_4096 << 5) | 11;
 	else if (ibqp->qp_type == IB_QPT_UD) {
@@ -1243,7 +1246,8 @@ static int __mlx4_ib_modify_qp(struct ib
 	if (cur_state == IB_QPS_INIT &&
 	    new_state == IB_QPS_RTR  &&
 	    (ibqp->qp_type == IB_QPT_GSI || ibqp->qp_type == IB_QPT_SMI ||
-	     ibqp->qp_type == IB_QPT_UD || ibqp->qp_type == IB_QPT_RAW_ETY)) {
+	     ibqp->qp_type == IB_QPT_UD || ibqp->qp_type == IB_QPT_RAW_ETY ||
+		ibqp->qp_type == IB_QPT_RAW_ETH)) {
 		context->pri_path.sched_queue = (qp->port - 1) << 6;
 		if (is_qp0(dev, qp))
 			context->pri_path.sched_queue |= MLX4_IB_DEFAULT_QP0_SCHED_QUEUE;
@@ -1362,7 +1366,7 @@ int mlx4_ib_modify_qp(struct ib_qp *ibqp
 		goto out;
 	}
 
-	if ((attr_mask & IB_QP_PORT) &&
+	if ((attr_mask & IB_QP_PORT) && (ibqp->qp_type != IB_QPT_RAW_ETH) &&
 	    (attr->port_num == 0 || attr->port_num > dev->num_ports)) {
 		mlx4_ib_dbg("qpn 0x%x: invalid port number (%d) specified "
 			    "for transition %d to %d. qp_type %d",
@@ -1371,6 +1375,16 @@ int mlx4_ib_modify_qp(struct ib_qp *ibqp
 		goto out;
 	}
 
+	if ((attr_mask & IB_QP_PORT) && (ibqp->qp_type == IB_QPT_RAW_ETH) &&
+		(rdma_port_get_link_layer(&dev->ib_dev, attr->port_num)
+				!= IB_LINK_LAYER_ETHERNET)) {
+		mlx4_ib_dbg("qpn 0x%x: invalid port (%d) specified (not RDMAoE)"
+			    "for transition %d to %d. qp_type %d",
+			    ibqp->qp_num, attr->port_num, cur_state,
+			    new_state, ibqp->qp_type);
+		goto out;
+	}
+
 	if (attr_mask & IB_QP_PKEY_INDEX) {
 		int p = attr_mask & IB_QP_PORT ? attr->port_num : qp->port;
 		if (attr->pkey_index >= dev->dev->caps.pkey_table_len[p]) {
Index: ofed_kernel-fixes/drivers/net/mlx4/mcg.c
===================================================================
--- ofed_kernel-fixes.orig/drivers/net/mlx4/mcg.c	2010-08-22 17:36:28.000000000 +0300
+++ ofed_kernel-fixes/drivers/net/mlx4/mcg.c	2010-08-22 17:36:40.000000000 +0300
@@ -36,6 +36,7 @@
 #include <linux/slab.h>
 
 #include <linux/mlx4/cmd.h>
+#include <linux/mlx4/driver.h>
 
 #include "mlx4.h"
 
@@ -97,7 +98,8 @@ static int mlx4_MGID_HASH(struct mlx4_de
  * entry in hash chain and *mgm holds end of hash chain.
  */
 static int find_mgm(struct mlx4_dev *dev,
-		    u8 *gid, struct mlx4_cmd_mailbox *mgm_mailbox,
+		    u8 *gid, enum mlx4_mcast_prot prot,
+		    struct mlx4_cmd_mailbox *mgm_mailbox,
 		    u16 *hash, int *prev, int *index)
 {
 	struct mlx4_cmd_mailbox *mailbox;
@@ -136,7 +138,8 @@ static int find_mgm(struct mlx4_dev *dev
 			return err;
 		}
 
-		if (!memcmp(mgm->gid, gid, 16))
+		if (!memcmp(mgm->gid, gid, 16) &&
+				(prot == be32_to_cpu(mgm->members_count) >> 30))
 			return err;
 
 		*prev = *index;
@@ -148,7 +151,7 @@ static int find_mgm(struct mlx4_dev *dev
 }
 
 int mlx4_multicast_attach(struct mlx4_dev *dev, struct mlx4_qp *qp, u8 gid[16],
-			  int block_mcast_loopback)
+			  int block_mcast_loopback, enum mlx4_mcast_prot prot)
 {
 	struct mlx4_priv *priv = mlx4_priv(dev);
 	struct mlx4_cmd_mailbox *mailbox;
@@ -167,7 +170,7 @@ int mlx4_multicast_attach(struct mlx4_de
 
 	mutex_lock(&priv->mcg_table.mutex);
 
-	err = find_mgm(dev, gid, mailbox, &hash, &prev, &index);
+	err = find_mgm(dev, gid, prot, mailbox, &hash, &prev, &index);
 	if (err)
 		goto out;
 
@@ -206,7 +209,7 @@ int mlx4_multicast_attach(struct mlx4_de
 	mgm->qp[members_count++] = cpu_to_be32((qp->qpn & MGM_QPN_MASK) |
 					       (!!mlx4_blck_lb << MGM_BLCK_LB_BIT));
 
-	mgm->members_count       = cpu_to_be32(members_count);
+	mgm->members_count = cpu_to_be32(members_count | ((u32) prot << 30));
 
 	err = mlx4_WRITE_MCG(dev, index, mailbox);
 	if (err)
@@ -241,7 +244,8 @@ out:
 }
 EXPORT_SYMBOL_GPL(mlx4_multicast_attach);
 
-int mlx4_multicast_detach(struct mlx4_dev *dev, struct mlx4_qp *qp, u8 gid[16])
+int mlx4_multicast_detach(struct mlx4_dev *dev, struct mlx4_qp *qp, u8 gid[16],
+						enum mlx4_mcast_prot prot)
 {
 	struct mlx4_priv *priv = mlx4_priv(dev);
 	struct mlx4_cmd_mailbox *mailbox;
@@ -259,7 +263,7 @@ int mlx4_multicast_detach(struct mlx4_de
 
 	mutex_lock(&priv->mcg_table.mutex);
 
-	err = find_mgm(dev, gid, mailbox, &hash, &prev, &index);
+	err = find_mgm(dev, gid, prot, mailbox, &hash, &prev, &index);
 	if (err)
 		goto out;
 
@@ -281,7 +285,7 @@ int mlx4_multicast_detach(struct mlx4_de
 	}
 
 
-	mgm->members_count = cpu_to_be32(--members_count);
+	mgm->members_count = cpu_to_be32(--members_count | ((u32) prot << 30));
 	mgm->qp[loc]       = mgm->qp[i - 1];
 	mgm->qp[i - 1]     = 0;
 
Index: ofed_kernel-fixes/include/linux/mlx4/device.h
===================================================================
--- ofed_kernel-fixes.orig/include/linux/mlx4/device.h	2010-08-22 17:36:40.000000000 +0300
+++ ofed_kernel-fixes/include/linux/mlx4/device.h	2010-08-22 17:36:40.000000000 +0300
@@ -39,6 +39,8 @@
 
 #include <asm/atomic.h>
 
+#include <linux/mlx4/driver.h>
+
 enum {
 	MLX4_FLAG_MSI_X		= 1 << 0,
 	MLX4_FLAG_OLD_PORT_CMDS	= 1 << 1,
@@ -561,8 +563,9 @@ int mlx4_INIT_PORT(struct mlx4_dev *dev,
 int mlx4_CLOSE_PORT(struct mlx4_dev *dev, int port);
 
 int mlx4_multicast_attach(struct mlx4_dev *dev, struct mlx4_qp *qp, u8 gid[16],
-			  int block_mcast_loopback);
-int mlx4_multicast_detach(struct mlx4_dev *dev, struct mlx4_qp *qp, u8 gid[16]);
+			  int block_mcast_loopback, enum mlx4_mcast_prot prot);
+int mlx4_multicast_detach(struct mlx4_dev *dev, struct mlx4_qp *qp, u8 gid[16],
+				enum mlx4_mcast_prot prot);
 
 int mlx4_register_mac(struct mlx4_dev *dev, u8 port, u64 mac, int *index);
 void mlx4_unregister_mac(struct mlx4_dev *dev, u8 port, int index);
Index: ofed_kernel-fixes/include/linux/mlx4/driver.h
===================================================================
--- ofed_kernel-fixes.orig/include/linux/mlx4/driver.h	2010-08-22 17:36:29.000000000 +0300
+++ ofed_kernel-fixes/include/linux/mlx4/driver.h	2010-08-22 17:36:40.000000000 +0300
@@ -54,6 +54,11 @@ enum mlx4_prot {
 	MLX4_PROT_EN,
 };
 
+enum mlx4_mcast_prot {
+	MLX4_MCAST_PROT_IB = 0,
+	MLX4_MCAST_PROT_EN = 1,
+};
+
 struct mlx4_interface {
 	void *			(*add)	 (struct mlx4_dev *dev);
 	void			(*remove)(struct mlx4_dev *dev, void *context);
