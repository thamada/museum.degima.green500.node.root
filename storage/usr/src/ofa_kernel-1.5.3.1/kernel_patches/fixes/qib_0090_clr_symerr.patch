diff -up a/drivers/infiniband/hw/qib/qib.h b/drivers/infiniband/hw/qib/qib.h
--- a/drivers/infiniband/hw/qib/qib.h	2010-03-09 11:37:41.000000000 -0800
+++ b/drivers/infiniband/hw/qib/qib.h	2010-03-09 12:10:37.000000000 -0800
@@ -619,6 +619,7 @@ struct qib_pportdata {
 	/* Used to flash LEDs in override mode */
 	struct timer_list led_override_timer;
 	struct xmit_wait cong_stats;
+	struct timer_list symerr_clear_timer;
 };
 
 /* Observers. Not to be taken lightly, possibly not to ship. */
@@ -1214,6 +1215,7 @@ void qib_inc_eeprom_err(struct qib_devda
 void qib_dump_lookup_output_queue(struct qib_devdata *);
 void qib_force_pio_avail_update(struct qib_devdata *);
 void signal_ib_event(struct qib_pportdata *ppd, enum ib_event_type ev);
+void clear_symerror_on_linkup(unsigned long opaque);
 
 /*
  * Set LED override, only the two LSBs have "public" meaning, but
diff -up a/drivers/infiniband/hw/qib/qib_iba7220.c b/drivers/infiniband/hw/qib/qib_iba7220.c
--- a/drivers/infiniband/hw/qib/qib_iba7220.c	2010-03-09 11:37:41.000000000 -0800
+++ b/drivers/infiniband/hw/qib/qib_iba7220.c	2010-03-09 12:14:22.000000000 -0800
@@ -2986,8 +2986,10 @@ static void sendctrl_7220_mod(struct qib
 
 	tmp_dd_sendctrl = dd->sendctrl;
 
-	if (op & QIB_SENDCTRL_FLUSH)
+	if (op & QIB_SENDCTRL_FLUSH) {
 		tmp_dd_sendctrl |= SYM_MASK(SendCtrl, Abort);
+		qib_cdbg(SDMA, "Flushing\n");
+	}
 	if (op & QIB_SENDCTRL_DISARM)
 		tmp_dd_sendctrl |= SYM_MASK(SendCtrl, Disarm) |
 			((op & QIB_7220_SendCtrl_DisarmPIOBuf_RMASK) <<
@@ -3485,7 +3487,7 @@ u32 __iomem *get_7220_link_buf(struct qi
 	    ppd->sdma_state.current_state != qib_sdma_state_s00_hw_down) {
 		qib_cdbg(INIT, "sdma state %u, so set down, no buf\n",
 			ppd->sdma_state.current_state);
-		qib_sdma_process_event(ppd, qib_sdma_event_e00_go_hw_down);
+		__qib_sdma_process_event(ppd, qib_sdma_event_e00_go_hw_down);
 		do_cleanup = 0;
 	} else {
 		do_cleanup = 1;
@@ -3780,6 +3782,14 @@ static int qib_7220_ib_updown(struct qib
 			qib_cdbg(VERBOSE, "Setting RXEQ defaults\n");
 			qib_sd7220_presets(dd);
 			qib_cancel_sends(ppd); /* initial disarm, etc. */
+			spin_lock_irqsave(&ppd->sdma_lock, flags);
+			if (__qib_sdma_running(ppd)) {
+				qib_dbg("IB%u:%u went down, idling sdma\n",
+					 ppd->dd->unit, ppd->port);
+				__qib_sdma_process_event(ppd,
+					qib_sdma_event_e70_go_idle);
+			}
+			spin_unlock_irqrestore(&ppd->sdma_lock, flags);
 		}
 		/* this might better in qib_sd7220_presets() */
 		set_7220_relock_poll(dd, ibup);
@@ -3857,6 +3867,21 @@ static int qib_7220_ib_updown(struct qib
 			    [(ibcs >> IBA7220_LINKWIDTH_SHIFT) & 1];
 
 			set_7220_relock_poll(dd, ibup);
+			spin_lock_irqsave(&ppd->sdma_lock, flags);
+			/*
+			 * Unlike 7322, the 7220 needs this, due to lack of
+			 * interrupt in some cases when we have sdma active
+			 * when the link goes down.
+			 */
+			if (ppd->sdma_state.current_state !=
+			    qib_sdma_state_s20_idle) {
+				qib_dbg("IB%u:%u up; sdma state %u; go down\n",
+					 ppd->dd->unit, ppd->port,
+					 ppd->sdma_state.current_state);
+				__qib_sdma_process_event(ppd,
+					qib_sdma_event_e00_go_hw_down);
+			}
+			spin_unlock_irqrestore(&ppd->sdma_lock, flags);
 		}
 	}
 
diff -up a/drivers/infiniband/hw/qib/qib_iba7322.c b/drivers/infiniband/hw/qib/qib_iba7322.c
--- a/drivers/infiniband/hw/qib/qib_iba7322.c	2010-03-09 11:37:41.000000000 -0800
+++ b/drivers/infiniband/hw/qib/qib_iba7322.c	2010-03-09 12:14:22.000000000 -0800
@@ -5578,8 +5578,17 @@ static int qib_7322_ib_updown(struct qib
 		if (!(ppd->lflags & (QIBL_IB_AUTONEG_FAILED |
 				     QIBL_IB_AUTONEG_INPROG)))
 			set_7322_ibspeed_fast(ppd, ppd->link_speed_enabled);
-		if (!(ppd->lflags & QIBL_IB_AUTONEG_INPROG))
+		if (!(ppd->lflags & QIBL_IB_AUTONEG_INPROG)) {
 			qib_cancel_sends(ppd);
+			spin_lock_irqsave(&ppd->sdma_lock, flags);
+			if (__qib_sdma_running(ppd)) {
+				qib_dbg("IB%u:%u went down, idling sdma\n",
+					 ppd->dd->unit, ppd->port);
+				__qib_sdma_process_event(ppd,
+					qib_sdma_event_e70_go_idle);
+			}
+			spin_unlock_irqrestore(&ppd->sdma_lock, flags);
+		}
 		clr = read_7322_creg32_port(ppd, crp_iblinkdown);
 		if (clr == ppd->cpspec->iblnkdownsnap)
 			ppd->cpspec->iblnkdowndelta++;
@@ -7885,7 +7894,8 @@ static int setup_qmh_params(const char *
 				port = 2;
 			}
 			list_for_each_entry(dd, &qib_dev_list, list) {
-				if (!IS_QMH(dd))
+				if (dd->deviceid != PCI_DEVICE_ID_QLOGIC_IB_7322
+				    || !IS_QMH(dd))
 					continue; /* only for QMH cards */
 				if (dd->pcidev->bus->number == bus) {
 					found++;
@@ -7996,7 +8006,8 @@ static int setup_qme_params(const char *
 		if (++nf == N_QME_FIELDS) {
 			list_for_each_entry(dd, &qib_dev_list, list) {
 				int pidx, i;
-				if (!IS_QME(dd))
+				if (dd->deviceid != PCI_DEVICE_ID_QLOGIC_IB_7322
+				    || !IS_QME(dd))
 					continue; /* only for QME cards */
 				for (pidx = 0; pidx < dd->num_pports; ++pidx) {
 					struct qib_pportdata *ppd;
diff -up a/drivers/infiniband/hw/qib/qib_init.c b/drivers/infiniband/hw/qib/qib_init.c
--- a/drivers/infiniband/hw/qib/qib_init.c	2010-03-09 11:37:41.000000000 -0800
+++ b/drivers/infiniband/hw/qib/qib_init.c	2010-03-09 15:12:21.000000000 -0800
@@ -205,6 +205,10 @@ void qib_init_pportdata(struct qib_pport
 	spin_lock_init(&ppd->sdma_lock);
 	spin_lock_init(&ppd->lflags_lock);
 	init_waitqueue_head(&ppd->state_wait);
+
+	init_timer(&ppd->symerr_clear_timer);
+	ppd->symerr_clear_timer.function = clear_symerror_on_linkup;
+	ppd->symerr_clear_timer.data = (unsigned long)ppd;
 }
 
 static int init_pioavailregs(struct qib_devdata *dd)
@@ -714,6 +718,8 @@ static void qib_stop_timers(struct qib_d
 			del_timer_sync(&ppd->led_override_timer);
 			atomic_set(&ppd->led_override_timer_active, 0);
 		}
+		if (ppd->symerr_clear_timer.data)
+			del_timer_sync(&ppd->symerr_clear_timer);
 	}
 }
 
diff -up a/drivers/infiniband/hw/qib/qib_intr.c b/drivers/infiniband/hw/qib/qib_intr.c
--- a/drivers/infiniband/hw/qib/qib_intr.c	2010-03-09 11:37:41.000000000 -0800
+++ b/drivers/infiniband/hw/qib/qib_intr.c	2010-03-09 15:12:21.000000000 -0800
@@ -127,11 +127,15 @@ void handle_e_ibstatuschanged(struct qib
 					QIBL_LINKDOWN | QIBL_LINKACTIVE);
 			}
 			spin_unlock_irqrestore(&ppd->lflags_lock, flags);
+			/* start a 75msec timer to clear symbol errors */
+			mod_timer(&ppd->symerr_clear_timer,
+				  msecs_to_jiffies(75));
 		} else if (ltstate == IB_PHYSPORTSTATE_LINKUP) {
 			/* active, but not active defered */
 			qib_hol_up(ppd); /* useful only for 6120 now */
 			*ppd->statusp |=
 				QIB_STATUS_IB_READY | QIB_STATUS_IB_CONF;
+			clear_symerror_on_linkup((unsigned long)ppd);
 			spin_lock_irqsave(&ppd->lflags_lock, flags);
 			ppd->lflags |= QIBL_LINKACTIVE | QIBL_LINKV;
 			ppd->lflags &= ~(QIBL_LINKINIT |
@@ -159,6 +163,18 @@ skip_ibchange:
 	return;
 }
 
+void clear_symerror_on_linkup(unsigned long opaque)
+{
+	struct qib_pportdata *ppd = (struct qib_pportdata *)opaque;
+
+	if (ppd->lflags & QIBL_LINKACTIVE)
+		return;
+
+	qib_cdbg(VERB, "Resetting IBSymError count after LinkUP\n");
+	ppd->ibport_data.z_symbol_error_counter =
+		ppd->dd->f_portcntr(ppd, QIBPORTCNTR_IBSYMBOLERR);
+}
+
 /*
  * Handle receive interrupts for user ctxts; this means a user
  * process was waiting for a packet to arrive, and didn't want
