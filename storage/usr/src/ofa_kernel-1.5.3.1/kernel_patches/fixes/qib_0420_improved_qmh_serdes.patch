diff --git a/drivers/infiniband/hw/qib/qib_iba7322.c b/drivers/infiniband/hw/qib/qib_iba7322.c
index b397dc6..4e3a621 100644
--- a/drivers/infiniband/hw/qib/qib_iba7322.c
+++ b/drivers/infiniband/hw/qib/qib_iba7322.c
@@ -634,6 +634,7 @@ struct qib_chippport_specific {
 	struct qib_qsfp_data qsfp_data;
 	char epmsgbuf[192]; /* for port error interrupt msg buffer */
 	char sdmamsgbuf[192]; /* for per-port sdma error messages */
+	u8 bounced;
 };
 
 static struct {
@@ -1834,6 +1835,8 @@ static void handle_serdes_issues(struct qib_pportdata *ppd, u64 ibcst)
 	}
 }
 
+static int qib_7322_set_ib_cfg(struct qib_pportdata *, int, u32);
+
 /*
  * This is per-pport error handling.
  * will likely get it's own MSIx interrupt (one for each port,
@@ -1998,7 +2001,24 @@ static noinline void handle_7322_p_errors(struct qib_pportdata *ppd)
 		    IB_PHYSPORTSTATE_DISABLED)
 			qib_set_ib_7322_lstate(ppd, 0,
 			       QLOGIC_IB_IBCC_LINKINITCMD_DISABLE);
-		else
+		else {
+			u32 lstate;
+			/*
+			 * We need the current logical link state before lflags are
+			 * set in handle_e_ibstatuschanged.
+			 */
+			lstate = qib_7322_iblink_state(ibcs[0]);
+
+			if (IS_QMH(dd) && !ppd->cpspec->bounced &&
+			    ltstate == IB_PHYSPORTSTATE_LINKUP &&
+			    (lstate >= IB_PORT_INIT && lstate <= IB_PORT_ACTIVE)) {
+				qib_cdbg(LINKVERB, "IB%u:%u artificially bouncing link\n",
+					 dd->unit, ppd->port);
+				ppd->cpspec->bounced = 1;
+				qib_7322_set_ib_cfg(ppd, QIB_IB_CFG_LSTATE,
+						    IB_LINKCMD_DOWN | IB_LINKINITCMD_POLL);
+			}
+
 			/*
 			 * Since going into a recovery state causes the link
 			 * state to go down and since recovery is transitory,
@@ -2012,6 +2032,7 @@ static noinline void handle_7322_p_errors(struct qib_pportdata *ppd)
 			    ltstate != IB_PHYSPORTSTATE_RECOVERY_WAITRMT &&
 			    ltstate != IB_PHYSPORTSTATE_RECOVERY_IDLE)
 				handle_e_ibstatuschanged(ppd, ibcs[0]);
+		}
 	}
 	if (*msg && iserr)
 		qib_dev_porterr(dd, ppd->port, "%s error\n", msg);
@@ -7898,8 +7919,8 @@ static void ibsd_wr_allchans(struct qib_pportdata *ppd, int addr, unsigned data,
 static void serdes_7322_los_enable(struct qib_pportdata *ppd, int enable)
 {
 	u64 data = qib_read_kreg_port(ppd, krp_serdesctrl);
-	qib_cdbg(LINKVERB, "Turning LOS %s for port %d\n",
-		 (enable ? "on" : "off"), ppd->port);
+	qib_cdbg(LINKVERB, "IB%u:%u Turning LOS %s\n",
+		 ppd->dd->unit, ppd->port, (enable ? "on" : "off"));
 	if (enable)
 		data |= SYM_MASK(IBSerdesCtrl_0, RXLOSEN);
 	else
@@ -8212,8 +8233,6 @@ static int serdes_7322_init_new(struct qib_pportdata *ppd)
 	/* VGA output common mode */
 	ibsd_wr_allchans(ppd, 12, (3 << 2), BMASK(3, 2));
 
-	/* Add a delay to allow the SERDES to init */
-	msleep(3000);
 	return 0;
 }
 
