From 90733afdcde1b4b7b28bf533840e8a8ee2d68e39 Mon Sep 17 00:00:00 2001
From: Eli Cohen <eli@mellanox.co.il>
Date: Wed, 6 Jan 2010 11:42:33 +0200
Subject: [PATCH 11/12] mlx4: support allocation of counters

CX devices support sets of counters that can be used to count packets and data
octets in receive and transmit. This patch queries the device to check support
for counters, either basic or extended, and initializes a bitmap allocator to
control allocations.

Signed-off-by: Eli Cohen <eli@mellanox.co.il>
---
 drivers/net/mlx4/fw.c       |   14 +++++++-
 drivers/net/mlx4/fw.h       |    3 ++
 drivers/net/mlx4/main.c     |   83 ++++++++++++++++++++++++++++++++++++++++++-
 drivers/net/mlx4/mlx4.h     |    1 +
 include/linux/mlx4/device.h |   12 ++++++
 5 files changed, 111 insertions(+), 2 deletions(-)

Index: ofed_kernel-fixes/drivers/net/mlx4/fw.c
===================================================================
--- ofed_kernel-fixes.orig/drivers/net/mlx4/fw.c	2010-03-18 10:39:42.000000000 +0200
+++ ofed_kernel-fixes/drivers/net/mlx4/fw.c	2010-03-18 10:43:04.000000000 +0200
@@ -101,7 +101,9 @@ static void dump_dev_cap_flags(struct ml
 		[21] = "UD multicast support",
 		[24] = "Demand paging support",
 		[25] = "Router support",
-		[30] = "RoCEE support"
+		[30] = "RoCEE support",
+		[48] = "Basic counters support",
+		[49] = "Extended counters support",
 	};
 	int i;
 
@@ -218,6 +220,8 @@ int mlx4_QUERY_DEV_CAP(struct mlx4_dev *
 #define QUERY_DEV_CAP_BMME_FLAGS_OFFSET		0x94
 #define QUERY_DEV_CAP_RSVD_LKEY_OFFSET		0x98
 #define QUERY_DEV_CAP_MAX_ICM_SZ_OFFSET		0xa0
+#define QUERY_DEV_CAP_MAX_BASIC_CNT_OFFSET	0x68
+#define QUERY_DEV_CAP_MAX_EXT_CNT_OFFSET	0x6c
 
 	mailbox = mlx4_alloc_cmd_mailbox(dev);
 	if (IS_ERR(mailbox))
@@ -362,6 +366,10 @@ int mlx4_QUERY_DEV_CAP(struct mlx4_dev *
 		 QUERY_DEV_CAP_RSVD_LKEY_OFFSET);
 	MLX4_GET(dev_cap->max_icm_sz, outbox,
 		 QUERY_DEV_CAP_MAX_ICM_SZ_OFFSET);
+	MLX4_GET(dev_cap->max_basic_counters, outbox,
+		 QUERY_DEV_CAP_MAX_BASIC_CNT_OFFSET);
+	MLX4_GET(dev_cap->max_ext_counters, outbox,
+		 QUERY_DEV_CAP_MAX_EXT_CNT_OFFSET);
 
 	if (dev->flags & MLX4_FLAG_OLD_PORT_CMDS) {
 		for (i = 1; i <= dev_cap->num_ports; ++i) {
@@ -806,6 +814,10 @@ int mlx4_INIT_HCA(struct mlx4_dev *dev, 
 	if (enable_qos)
 		*(inbox + INIT_HCA_FLAGS_OFFSET / 4) |= cpu_to_be32(1 << 2);
 
+	/* counters mode */
+	*(inbox + INIT_HCA_FLAGS_OFFSET / 4) |=
+		cpu_to_be32(dev->caps.counters_mode << 4);
+
 	/* QPC/EEC/CQC/EQC/RDMARC attributes */
 
 	MLX4_PUT(inbox, param->qpc_base,      INIT_HCA_QPC_BASE_OFFSET);
Index: ofed_kernel-fixes/drivers/net/mlx4/fw.h
===================================================================
--- ofed_kernel-fixes.orig/drivers/net/mlx4/fw.h	2010-03-18 10:39:42.000000000 +0200
+++ ofed_kernel-fixes/drivers/net/mlx4/fw.h	2010-03-18 10:43:23.000000000 +0200
@@ -79,7 +79,7 @@ struct mlx4_dev_cap {
 	u64 trans_code[MLX4_MAX_PORTS + 1];
 	u16 stat_rate_support;
 	int loopback_support;
-	u32 flags;
+	u64 flags;
 	int reserved_uars;
 	int uar_size;
 	int min_page_sz;
@@ -115,6 +115,8 @@ struct mlx4_dev_cap {
 	u8  supported_port_types[MLX4_MAX_PORTS + 1];
 	u8  log_max_macs[MLX4_MAX_PORTS + 1];
 	u8  log_max_vlans[MLX4_MAX_PORTS + 1];
+	u32 max_basic_counters;
+	u32 max_ext_counters;
 };
 
 struct mlx4_adapter {
@@ -144,6 +146,7 @@ struct mlx4_init_hca_param {
 	u8  log_mc_table_sz;
 	u8  log_mpt_sz;
 	u8  log_uar_sz;
+	u8  counter_mode;
 };
 
 struct mlx4_init_ib_param {
Index: ofed_kernel-fixes/drivers/net/mlx4/main.c
===================================================================
--- ofed_kernel-fixes.orig/drivers/net/mlx4/main.c	2010-03-18 10:39:42.000000000 +0200
+++ ofed_kernel-fixes/drivers/net/mlx4/main.c	2010-03-18 10:43:05.000000000 +0200
@@ -220,6 +220,19 @@ static void mlx4_set_port_mask(struct ml
 		dev->caps.port_mask[i] = dev->caps.port_type[i];
 }
 
+static u8 get_counters_mode(u64 flags)
+{
+	switch (flags >> 48 & 3) {
+	case 2:
+	case 3:
+		return MLX4_CUNTERS_EXT;
+	case 1:
+		return MLX4_CUNTERS_BASIC;
+	default:
+		return MLX4_CUNTERS_DISABLED;
+	}
+}
+
 static int mlx4_dev_cap(struct mlx4_dev *dev, struct mlx4_dev_cap *dev_cap)
 {
 	int err;
@@ -340,6 +353,10 @@ static int mlx4_dev_cap(struct mlx4_dev 
 		}
 	}
 
+	dev->caps.counters_mode = get_counters_mode(dev_cap->flags);
+	dev->caps.max_basic_counters = 1 << ilog2(dev_cap->max_basic_counters);
+	dev->caps.max_ext_counters = 1 << ilog2(dev_cap->max_ext_counters);
+
 	dev->caps.reserved_qps_cnt[MLX4_QP_REGION_FW] = dev_cap->reserved_qps;
 	dev->caps.reserved_qps_cnt[MLX4_QP_REGION_ETH_ADDR] =
 		dev->caps.reserved_qps_cnt[MLX4_QP_REGION_FC_ADDR] =
@@ -911,7 +928,6 @@ static int mlx4_init_hca(struct mlx4_dev
 	}
 
 	mlx4_set_port_mask(dev);
-
 	icm_size = mlx4_make_profile(dev, &profile, &dev_cap, &init_hca);
 	if ((long long) icm_size < 0) {
 		err = icm_size;
@@ -954,6 +970,59 @@ err_stop_fw:
 	return err;
 }
 
+static int mlx4_init_counters_table(struct mlx4_dev *dev)
+{
+	struct mlx4_priv *priv = mlx4_priv(dev);
+	int err;
+	int nent;
+
+	switch (dev->caps.counters_mode) {
+	case MLX4_CUNTERS_BASIC:
+		nent = dev->caps.max_basic_counters;
+		break;
+	case MLX4_CUNTERS_EXT:
+		nent = dev->caps.max_ext_counters;
+		break;
+	default:
+		return -ENOENT;
+	}
+	err = mlx4_bitmap_init(&priv->counters_bitmap, nent, nent - 1, 0, 0);
+	if (err)
+		return err;
+
+	return 0;
+}
+
+static void mlx4_cleanup_counters_table(struct mlx4_dev *dev)
+{
+	switch (dev->caps.counters_mode) {
+	case MLX4_CUNTERS_BASIC:
+	case MLX4_CUNTERS_EXT:
+		mlx4_bitmap_cleanup(&mlx4_priv(dev)->counters_bitmap);
+		break;
+	default:
+		break;
+	}
+}
+
+int mlx4_counter_alloc(struct mlx4_dev *dev, u32 *idx)
+{
+	struct mlx4_priv *priv = mlx4_priv(dev);
+
+	*idx = mlx4_bitmap_alloc(&priv->counters_bitmap);
+	if (*idx == -1)
+		return -ENOMEM;
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(mlx4_counter_alloc);
+
+void mlx4_counter_free(struct mlx4_dev *dev, u32 idx)
+{
+	mlx4_bitmap_free(&mlx4_priv(dev)->counters_bitmap, idx);
+}
+EXPORT_SYMBOL_GPL(mlx4_counter_free);
+
 static int mlx4_setup_hca(struct mlx4_dev *dev)
 {
 	struct mlx4_priv *priv = mlx4_priv(dev);
@@ -1065,6 +1134,12 @@ static int mlx4_setup_hca(struct mlx4_de
 		goto err_qp_table_free;
 	}
 
+	err = mlx4_init_counters_table(dev);
+	if (err && err != -ENOENT) {
+		mlx4_err(dev, "Failed to initialize counters table, aborting.\n");
+		goto err_mcg_table_free;
+	}
+
 	for (port = 1; port <= dev->caps.num_ports; port++) {
 		ib_port_default_caps = 0;
 		err = mlx4_get_port_ib_caps(dev, port, &ib_port_default_caps);
@@ -1077,12 +1152,15 @@ static int mlx4_setup_hca(struct mlx4_de
 		if (err) {
 			mlx4_err(dev, "Failed to set port %d, aborting\n",
 				port);
-			goto err_mcg_table_free;
+			goto err_counters_table_free;
 		}
 	}
 
 	return 0;
 
+err_counters_table_free:
+	mlx4_cleanup_counters_table(dev);
+
 err_mcg_table_free:
 	mlx4_cleanup_mcg_table(dev);
 
@@ -1359,6 +1437,7 @@ err_port:
 	for (--port; port >= 1; --port)
 		mlx4_cleanup_port_info(&priv->port[port]);
 
+	mlx4_cleanup_counters_table(dev);
 	mlx4_cleanup_mcg_table(dev);
 	mlx4_cleanup_qp_table(dev);
 	mlx4_cleanup_srq_table(dev);
@@ -1426,6 +1505,7 @@ static void mlx4_remove_one(struct pci_d
 			mlx4_CLOSE_PORT(dev, p);
 		}
 
+                mlx4_cleanup_counters_table(dev);
 		mlx4_cleanup_mcg_table(dev);
 		mlx4_cleanup_qp_table(dev);
 		mlx4_cleanup_srq_table(dev);
Index: ofed_kernel-fixes/drivers/net/mlx4/mlx4.h
===================================================================
--- ofed_kernel-fixes.orig/drivers/net/mlx4/mlx4.h	2010-03-18 10:39:41.000000000 +0200
+++ ofed_kernel-fixes/drivers/net/mlx4/mlx4.h	2010-03-18 10:43:04.000000000 +0200
@@ -308,6 +308,7 @@ struct mlx4_priv {
 	struct mlx4_srq_table	srq_table;
 	struct mlx4_qp_table	qp_table;
 	struct mlx4_mcg_table	mcg_table;
+	struct mlx4_bitmap	counters_bitmap;
 
 	struct mlx4_catas_err	catas_err;
 
Index: ofed_kernel-fixes/include/linux/mlx4/device.h
===================================================================
--- ofed_kernel-fixes.orig/include/linux/mlx4/device.h	2010-03-18 10:39:42.000000000 +0200
+++ ofed_kernel-fixes/include/linux/mlx4/device.h	2010-03-18 10:43:05.000000000 +0200
@@ -172,6 +172,12 @@ enum mlx4_special_vlan_idx {
 };
 #define MLX4_LEAST_ATTACHED_VECTOR	0xffffffff
 
+enum {
+	MLX4_CUNTERS_DISABLED,
+	MLX4_CUNTERS_BASIC,
+	MLX4_CUNTERS_EXT
+};
+
 static inline u64 mlx4_fw_ver(u64 major, u64 minor, u64 subminor)
 {
 	return (major << 32) | (minor << 16) | subminor;
@@ -249,6 +255,9 @@ struct mlx4_caps {
 	u8			supported_type[MLX4_MAX_PORTS + 1];
 	enum mlx4_port_type	port_mask[MLX4_MAX_PORTS + 1];
 	enum mlx4_port_type	possible_type[MLX4_MAX_PORTS + 1];
+	u8			counters_mode;
+	u32			max_basic_counters;
+	u32			max_ext_counters;
 };
 
 struct mlx4_buf_list {
@@ -545,4 +554,7 @@ int mlx4_test_interrupts(struct mlx4_dev
 
 void mlx4_get_fc_t11_settings(struct mlx4_dev *dev, int *enable_pre_t11, int *t11_supported);
 
+int mlx4_counter_alloc(struct mlx4_dev *dev, u32 *idx);
+void mlx4_counter_free(struct mlx4_dev *dev, u32 idx);
+
 #endif /* MLX4_DEVICE_H */
