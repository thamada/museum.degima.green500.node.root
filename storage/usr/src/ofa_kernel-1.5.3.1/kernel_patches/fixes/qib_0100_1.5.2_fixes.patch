diff -up a/drivers/infiniband/hw/qib/qib_common.h b/drivers/infiniband/hw/qib/qib_common.h
--- a/drivers/infiniband/hw/qib/qib_common.h	2010-04-14 16:15:00.000000000 -0700
+++ b/drivers/infiniband/hw/qib/qib_common.h	2010-04-14 16:27:04.000000000 -0700
@@ -109,6 +109,7 @@ enum qib_ureg {
 #define QIB_RUNTIME_FORCE_WC_ORDER      0x0004
 #define QIB_RUNTIME_RCVHDR_COPY         0x0008
 #define QIB_RUNTIME_MASTER              0x0010
+#define QIB_RUNTIME_RCHK                0x0020
 #define QIB_RUNTIME_NODMA_RTAIL         0x0080
 #define QIB_RUNTIME_SPECIAL_TRIGGER     0x0100
 #define QIB_RUNTIME_SDMA                0x0200
diff -up a/drivers/infiniband/hw/qib/qib_cq.c b/drivers/infiniband/hw/qib/qib_cq.c
--- a/drivers/infiniband/hw/qib/qib_cq.c	2010-04-14 16:15:00.000000000 -0700
+++ b/drivers/infiniband/hw/qib/qib_cq.c	2010-04-14 16:26:52.000000000 -0700
@@ -106,7 +106,7 @@ void qib_cq_enter(struct qib_cq *cq, str
 		 * This will cause send_complete() to be called in
 		 * another thread.
 		 */
-		tasklet_hi_schedule(&cq->comptask);
+		queue_work(qib_wq, &cq->comptask);
 	}
 
 	spin_unlock_irqrestore(&cq->lock, flags);
@@ -161,14 +161,14 @@ bail:
 	return npolled;
 }
 
-static void send_complete(unsigned long data)
+static void send_complete(struct work_struct *work)
 {
-	struct qib_cq *cq = (struct qib_cq *)data;
+	struct qib_cq *cq = container_of(work, struct qib_cq, comptask);
 
 	/*
 	 * The completion handler will most likely rearm the notification
 	 * and poll for all pending entries.  If a new completion entry
-	 * is added while we are in this routine, tasklet_hi_schedule()
+	 * is added while we are in this routine, queue_work()
 	 * won't call us again until we return so we check triggered to
 	 * see if we need to call the handler again.
 	 */
@@ -289,7 +289,7 @@ struct ib_cq *qib_create_cq(struct ib_de
 	cq->notify = IB_CQ_NONE;
 	cq->triggered = 0;
 	spin_lock_init(&cq->lock);
-	tasklet_init(&cq->comptask, send_complete, (unsigned long)cq);
+	INIT_WORK(&cq->comptask, send_complete);
 	wc->head = 0;
 	wc->tail = 0;
 	cq->queue = wc;
@@ -321,7 +321,7 @@ int qib_destroy_cq(struct ib_cq *ibcq)
 	struct qib_ibdev *dev = to_idev(ibcq->device);
 	struct qib_cq *cq = to_icq(ibcq);
 
-	tasklet_kill(&cq->comptask);
+	flush_work(&cq->comptask);
 	spin_lock(&dev->n_cqs_lock);
 	dev->n_cqs_allocated--;
 	spin_unlock(&dev->n_cqs_lock);
diff -up a/drivers/infiniband/hw/qib/qib_iba6120.c b/drivers/infiniband/hw/qib/qib_iba6120.c
--- a/drivers/infiniband/hw/qib/qib_iba6120.c	2010-04-14 16:15:00.000000000 -0700
+++ b/drivers/infiniband/hw/qib/qib_iba6120.c	2010-04-14 16:27:04.000000000 -0700
@@ -1944,7 +1944,7 @@ bail:
 /**
  * qib_6120_put_tid - write a TID in chip
  * @dd: the qlogic_ib device
- * @tidptr: pointer to the expected TID (in chip) to udpate
+ * @tidptr: pointer to the expected TID (in chip) to update
  * @tidtype: RCVHQ_RCV_TYPE_EAGER (1) for eager, RCVHQ_RCV_TYPE_EXPECTED (0)
  * for expected
  * @pa: physical address of in memory buffer; tidinvalid if freeing
@@ -2011,7 +2011,7 @@ static void qib_6120_put_tid(struct qib_
 /**
  * qib_6120_put_tid_2 - write a TID in chip, Revision 2 or higher
  * @dd: the qlogic_ib device
- * @tidptr: pointer to the expected TID (in chip) to udpate
+ * @tidptr: pointer to the expected TID (in chip) to update
  * @tidtype: RCVHQ_RCV_TYPE_EAGER (1) for eager, RCVHQ_RCV_TYPE_EXPECTED (0)
  * for expected
  * @pa: physical address of in memory buffer; tidinvalid if freeing
diff -up a/drivers/infiniband/hw/qib/qib_iba7220.c b/drivers/infiniband/hw/qib/qib_iba7220.c
--- a/drivers/infiniband/hw/qib/qib_iba7220.c	2010-04-14 16:15:00.000000000 -0700
+++ b/drivers/infiniband/hw/qib/qib_iba7220.c	2010-04-14 16:27:04.000000000 -0700
@@ -2283,7 +2283,7 @@ bail:
 /**
  * qib_7220_put_tid - write a TID to the chip
  * @dd: the qlogic_ib device
- * @tidptr: pointer to the expected TID (in chip) to udpate
+ * @tidptr: pointer to the expected TID (in chip) to update
  * @tidtype: 0 for eager, 1 for expected
  * @pa: physical address of in memory buffer; tidinvalid if freeing
  */
diff -up a/drivers/infiniband/hw/qib/qib_iba7322.c b/drivers/infiniband/hw/qib/qib_iba7322.c
--- a/drivers/infiniband/hw/qib/qib_iba7322.c	2010-04-14 16:15:00.000000000 -0700
+++ b/drivers/infiniband/hw/qib/qib_iba7322.c	2010-04-14 16:31:04.000000000 -0700
@@ -75,6 +75,14 @@ static void qib_7322_mini_pcs_reset(stru
 
 static u32 ahb_mod(struct qib_devdata *, int, int, int, u32, u32);
 static void ibsd_wr_allchans(struct qib_pportdata *, int, unsigned, unsigned);
+
+#define BMASK(msb, lsb) (((1 << ((msb) + 1 - (lsb))) - 1) << (lsb))
+
+/* LE2 serdes values for different cases */
+#define LE2_DEFAULT 5
+#define LE2_5m 4
+#define LE2_QME 0
+
 /* Below is special-purpose, so only really works for the IB SerDes blocks. */
 #define IBSD(hw_pidx) (hw_pidx + 2)
 
@@ -474,8 +482,8 @@ static const u8 qib_7322_physportstate[0
 		IB_PHYSPORTSTATE_LINK_ERR_RECOVER,
 	[IB_7322_LT_STATE_RECOVERIDLE] =
 		IB_PHYSPORTSTATE_LINK_ERR_RECOVER,
-	[0x10] = IB_PHYSPORTSTATE_CFG_ENH,
-	[0x11] = IB_PHYSPORTSTATE_CFG_TRAIN,
+	[IB_7322_LT_STATE_CFGENH] = IB_PHYSPORTSTATE_CFG_ENH,
+	[IB_7322_LT_STATE_CFGTEST] = IB_PHYSPORTSTATE_CFG_TRAIN,
 	[0x12] = IB_PHYSPORTSTATE_CFG_TRAIN,
 	[0x13] = IB_PHYSPORTSTATE_CFG_WAIT_ENH,
 	[0x14] = IB_PHYSPORTSTATE_CFG_TRAIN,
@@ -549,23 +557,15 @@ struct vendor_txdds_ent {
 #define H1_FORCE_QME 1 /*  may be overridden via setup_qme_params() */
 #define H1_FORCE_QMH 7 /*  may be overridden via setup_qmh_params() */
 
-/*
- * Set RxEQ adaptation on or off, possibly different taps differently.
- * Applied to all channels.
- * D9 is disable_rxenagain (gain, aka H0)
- * D8 is disable_rxenale (LE1,2)
- * D7..0 are disable_rxenadfe for H1-H8
- * bits and shifts are same for all speeds.
- */
-#define RXENALE_LSB \
-	SYM_LSB(ADAPT_DISABLE_STATIC_SDR_0, static_disable_rxenale_sdr_ch0)
-#define RXENAGAIN_LSB \
-	SYM_LSB(ADAPT_DISABLE_STATIC_SDR_0, static_disable_rxenagain_sdr_ch0)
 /* The static and dynamic registers are paired, and the pairs indexed by spd */
 #define krp_static_adapt_dis(spd) (KREG_IBPORT_IDX(ADAPT_DISABLE_STATIC_SDR) \
 	+ ((spd) * 2))
 
 #define QDR_DFE_DISABLE_DELAY 4000 /* msec after LINKUP */
+#define QDR_STATIC_ADAPT_DOWN 0xf0f0f0f0ULL /* link down, H1-H4 QDR adapts */
+#define QDR_STATIC_ADAPT_DOWN_R1 0ULL /* r1 link down, H1-H4 QDR adapts */
+#define QDR_STATIC_ADAPT_INIT 0xffffffffffULL /* up, disable H0,H1-8, LE */
+#define QDR_STATIC_ADAPT_INIT_R1 0xf0ffffffffULL /* r1 up, disable H0,H1-8 */
 
 static const struct txdds_ent qmh_sdr_txdds =  { 11, 0,  5,  6 };
 static const struct txdds_ent qmh_ddr_txdds =  {  7, 0,  2,  8 };
@@ -619,7 +619,6 @@ struct qib_chippport_specific {
 	u8 mainv[SERDES_CHANS];
 	u8 post[SERDES_CHANS];
 	u8 ipg_tries;
-	u8 switch_port;
 	u8 ibmalfusesnap;
 	struct qib_qsfp_data qsfp_data;
 	char epmsgbuf[192]; /* for port error interrupt msg buffer */
@@ -1374,6 +1373,7 @@ static void err_decode(char *msg, size_t
 			(unsigned long long) errs);
 }
 
+/* only called if r1 set */
 static void flush_fifo(struct qib_pportdata *ppd)
 {
 	struct qib_devdata *dd = ppd->dd;
@@ -1405,7 +1405,6 @@ static void flush_fifo(struct qib_pportd
 	piobuf = qib_7322_getsendbuf(ppd, pbc, &bufn);
 	if (!piobuf) {
 		qib_dbg("IB%u:%u: no VL15 buffer\n", dd->unit, ppd->port);
-		/* XXX set SendCtrl_0:TxeDrainLaFifo? */
 		return;
 	}
 	writeq(pbc, piobuf);
@@ -1489,7 +1488,7 @@ static void qib_7322_sdma_sendctrl(struc
 
 	spin_unlock(&dd->sendctrl_lock);
 
-	if (op & QIB_SDMA_SENDCTRL_OP_DRAIN)
+	if ((op & QIB_SDMA_SENDCTRL_OP_DRAIN) && ppd->dd->cspec->r1)
 		flush_fifo(ppd);
 }
 
@@ -1794,8 +1793,11 @@ static void handle_serdes_issues(struct
 	    ibclt <= IB_7322_LT_STATE_SLEEPQUIET) {
 		ppd->cpspec->qdr_dfe_on = 1;
 		ppd->cpspec->qdr_dfe_time = 0;
-		/* On link down, reenable all QDR adaptation */
-		qib_write_kreg_port(ppd, krp_static_adapt_dis(2), 0ULL);
+		/* On link down, reenable QDR adaptation */
+		qib_write_kreg_port(ppd, krp_static_adapt_dis(2),
+			ppd->dd->cspec->r1 ?
+				    QDR_STATIC_ADAPT_DOWN_R1 :
+				    QDR_STATIC_ADAPT_DOWN);
 		qib_cdbg(LINKVERB, "IB%u:%u re-enabled QDR adaptation "
 			 "ibclt %x\n", ppd->dd->unit, ppd->port, ibclt);
 	}
@@ -2509,7 +2511,8 @@ static void qib_7322_mini_quiet_serdes(s
 	spin_unlock_irqrestore(&ppd->lflags_lock, flags);
 	wake_up(&ppd->cpspec->autoneg_wait);
 	cancel_delayed_work(&ppd->cpspec->autoneg_work);
-	cancel_delayed_work(&ppd->cpspec->ipg_work);
+	if (ppd->dd->cspec->r1)
+		cancel_delayed_work(&ppd->cpspec->ipg_work);
 	flush_scheduled_work();
 
 	ppd->cpspec->chase_end = 0;
@@ -3562,10 +3565,10 @@ static unsigned qib_7322_boardname(struc
 		 dd->majrev, dd->minrev,
 		 (unsigned)SYM_FIELD(dd->revision, Revision_R, SW));
 
-	if (features == DUAL_PORT_CAP && qib_singleport) {
+	if (qib_singleport && (features >> PORT_SPD_CAP_SHIFT) & PORT_SPD_CAP) {
 		qib_devinfo(dd->pcidev, "IB%u: Forced to single port mode"
 			    " by module parameter\n", dd->unit);
-		features = PORT_SPD_CAP;
+		features &= PORT_SPD_CAP;
 	}
 
 	return features;
@@ -3719,7 +3722,7 @@ bail:
 /**
  * qib_7322_put_tid - write a TID to the chip
  * @dd: the qlogic_ib device
- * @tidptr: pointer to the expected TID (in chip) to udpate
+ * @tidptr: pointer to the expected TID (in chip) to update
  * @tidtype: 0 for eager, 1 for expected
  * @pa: physical address of in memory buffer; tidinvalid if freeing
  */
@@ -3834,6 +3837,8 @@ static int qib_7322_get_base_info(struct
 	kinfo->spi_runtime_flags |= QIB_RUNTIME_CTXT_MSB_IN_QP |
 		QIB_RUNTIME_PCIE | QIB_RUNTIME_NODMA_RTAIL |
 		QIB_RUNTIME_HDRSUPP | QIB_RUNTIME_SDMA;
+	if (rcd->dd->cspec->r1)
+		kinfo->spi_runtime_flags |= QIB_RUNTIME_RCHK;
 	if (rcd->dd->flags & QIB_USE_SPCL_TRIG)
 		kinfo->spi_runtime_flags |= QIB_RUNTIME_SPECIAL_TRIGGER;
 
@@ -4269,11 +4274,12 @@ static int qib_7322_set_ib_cfg(struct qi
 
 	case QIB_IB_CFG_PORT:
 		/* val is the port number of the switch we are connected to. */
-		ppd->cpspec->switch_port = val;
-		qib_dbg("IB%u:%u switch port %u\n", dd->unit,
+		qib_cdbg(LINKVERB, "IB%u:%u switch port %u\n", dd->unit,
 			ppd->port, val);
-		cancel_delayed_work(&ppd->cpspec->ipg_work);
-		ppd->cpspec->ipg_tries = 0;
+		if (ppd->dd->cspec->r1) {
+			cancel_delayed_work(&ppd->cpspec->ipg_work);
+			ppd->cpspec->ipg_tries = 0;
+		}
 		goto bail;
 
 	default:
@@ -5131,9 +5137,10 @@ static void qib_get_7322_faststats(unsig
 
 			qib_cdbg(LINKVERB, "IB%u:%u Disable QDR DFE, gain\n",
 				ppd->dd->unit, ppd->port);
-			/* disable all DFE bits, and gain (H0), not LE */
 			qib_write_kreg_port(ppd, krp_static_adapt_dis(2),
-				0xf0ffffffffULL);
+					    ppd->dd->cspec->r1 ?
+					    QDR_STATIC_ADAPT_INIT_R1 :
+					    QDR_STATIC_ADAPT_INIT);
 			force_h1(ppd);
 		}
 	}
@@ -5423,6 +5430,7 @@ done:
 
 /*
  * This routine is used to request IPG set in the QLogic switch.
+ * Only called if r1.
  */
 static void try_7322_ipg(struct qib_pportdata *ppd)
 {
@@ -5433,8 +5441,6 @@ static void try_7322_ipg(struct qib_ppor
 	unsigned delay;
 	int ret;
 
-	if (!ppd->dd->cspec->r1)
-		return;
 	agent = ibp->send_agent;
 	if (!agent)
 		goto retry;
@@ -5487,6 +5493,7 @@ retry:
 
 /*
  * Timeout handler for setting IPG.
+ * Only called if r1.
  */
 static void ipg_7322_work(struct work_struct *work)
 {
@@ -5603,7 +5610,7 @@ static int qib_7322_ib_updown(struct qib
 		    !(ppd->lflags & (QIBL_IB_AUTONEG_FAILED |
 				     QIBL_IB_AUTONEG_INPROG)) &&
 		    ppd->link_speed_active == QIB_IB_SDR &&
-		    (ppd->link_speed_enabled & (ppd->link_speed_enabled - 1))
+		    (ppd->link_speed_enabled & QIB_IB_DDR)
 		    && ppd->cpspec->autoneg_tries < AUTONEG_TRIES) {
 			/* we are SDR, and auto-negotiation enabled */
 			++ppd->cpspec->autoneg_tries;
@@ -5664,7 +5671,7 @@ static int qib_7322_ib_updown(struct qib
 		}
 		if (!(ppd->lflags & QIBL_IB_AUTONEG_INPROG)) {
 			symadj = 1;
-			if (ppd->cpspec->ipg_tries <= 10)
+			if (ppd->dd->cspec->r1 && ppd->cpspec->ipg_tries <= 10)
 				try_7322_ipg(ppd);
 			if (!ppd->cpspec->recovery_init)
 				setup_7322_link_recovery(ppd, 0);
@@ -5976,6 +5983,7 @@ static void qsfp_7322_event(struct work_
 	struct qib_pportdata *ppd;
 	u64 pwrup;
 	int ret;
+	u32 le2;
 
 	qd = container_of(work, struct qib_qsfp_data, work);
 	ppd = qd->ppd;
@@ -6000,6 +6008,11 @@ static void qsfp_7322_event(struct work_
 	}
 	qib_qsfp_short_msg(qd);
 	init_txdds_table(ppd);
+
+	le2 = (qd->cache.len >= 5 && !ppd->dd->cspec->r1 &&
+		QSFP_IS_CU(qd->cache.tech)) ? LE2_5m :
+		(IS_QME(ppd->dd) ? LE2_QME : LE2_DEFAULT);
+	ibsd_wr_allchans(ppd, 13, (le2 << 7), BMASK(9, 7));
 }
 
 /*
@@ -6135,8 +6148,8 @@ static void write_7322_init_portregs(str
 	qib_write_kreg_port(ppd, krp_senddmabufmask0, 0);
 	qib_write_kreg_port(ppd, krp_senddmabufmask1, 0);
 	qib_write_kreg_port(ppd, krp_senddmabufmask2, 0);
-
-	ppd->p_sendctrl |= SYM_MASK(SendCtrl_0, ForceCreditUpToDate);
+	if (ppd->dd->cspec->r1)
+		ppd->p_sendctrl |= SYM_MASK(SendCtrl_0, ForceCreditUpToDate);
 }
 
 /*
@@ -6414,7 +6427,8 @@ static int qib_init_7322_variables(struc
 		init_waitqueue_head(&cp->autoneg_wait);
 		INIT_DELAYED_WORK(&cp->autoneg_work,
 				  autoneg_7322_work);
-		INIT_DELAYED_WORK(&cp->ipg_work, ipg_7322_work);
+		if (ppd->dd->cspec->r1)
+			INIT_DELAYED_WORK(&cp->ipg_work, ipg_7322_work);
 
 		if (IS_QMH(ppd->dd) || IS_QME(ppd->dd)) {
 			int i;
@@ -6547,6 +6561,7 @@ static int qib_init_7322_variables(struc
 bail:
 	if (!dd->ctxtcnt)
 		dd->ctxtcnt = 1; /* for other initialization code */
+
 	return ret;
 }
 
@@ -7597,8 +7612,6 @@ static void ibsd_wr_allchans(struct qib_
 	}
 }
 
-#define BMASK(msb, lsb) (((1 << ((msb) + 1 - (lsb))) - 1) << (lsb))
-
 static int serdes_7322_init(struct qib_pportdata *ppd)
 {
 	u64 data;
@@ -7613,10 +7626,11 @@ static int serdes_7322_init(struct qib_p
 
 	/* Termination: rxtermctrl_r2d addr 11 bits [12:11] = 1 */
 	ibsd_wr_allchans(ppd, 11, (1 << 11), BMASK(12, 11));
-	/* Enable LE2: rxle2en_r2a addr 13 bit [6] = 1, with value 5 */
+	/* Enable LE2: rxle2en_r2a addr 13 bit [6] = 1 */
 	ibsd_wr_allchans(ppd, 13, (1 << 6), (1 << 6));
-	/* set LE2 to 5 for all but QME, which is 0 */
-	le_val = IS_QME(ppd->dd) ? 0 : 5;
+
+	/* usually overridden in qsfp_7322_event */
+	le_val = IS_QME(ppd->dd) ? LE2_QME : LE2_DEFAULT;
 	ibsd_wr_allchans(ppd, 13, (le_val << 7), BMASK(9, 7));
 
 	/* enable LE1 adaptation for all but QME, which is disabled */
@@ -7646,7 +7660,9 @@ static int serdes_7322_init(struct qib_p
 	ahb_mod(ppd->dd, IBSD(ppd->hw_pidx), 5, 9, 1 << 15, 1 << 15);
 
 	/* LoS target data = 2 */
-	ibsd_wr_allchans(ppd, 14, (2 << 3), BMASK(5, 3));
+	ibsd_wr_allchans(ppd, 14, (2 << 3), BMASK(5, 3)); /* QDR */
+	ibsd_wr_allchans(ppd, 20, (2 << 10), BMASK(12, 10)); /* DDR */
+	ibsd_wr_allchans(ppd, 20, (2 << 13), BMASK(15, 13)); /* SDR */
 
 	data = qib_read_kreg_port(ppd, krp_serdesctrl);
 	qib_write_kreg_port(ppd, krp_serdesctrl, data |
@@ -7655,19 +7671,22 @@ static int serdes_7322_init(struct qib_p
 	/* rxbistena; set 0 to avoid effects of it switch later */
 	ibsd_wr_allchans(ppd, 9, 0 << 15, 1 << 15);
 
-	/* Configure for 4 tap DFE, and only H2 adapt */
-	ibsd_wr_allchans(ppd, 16, (0 << 0), BMASK(1, 0));
-	/* gain: hi stop 32 (6:1) lo stop 13 (10:7) target 22 (15:11) */
-	ibsd_wr_allchans(ppd, 21, 0xb6c0, 0xfffe);
+	/* Configure 4 DFE taps, and only they adapt */
+	ibsd_wr_allchans(ppd, 16, 0 << 0, BMASK(1, 0));
+
+	/* gain hi stop 32 (22) (6:1) lo stop 7 (10:7) target 22 (13) (15:11) */
+	le_val = ppd->dd->cspec->r1 ? 0xb6c0 : 0x6bac;
+	ibsd_wr_allchans(ppd, 21, le_val, 0xfffe);
 
 	/*
 	 * Set receive adaptation mode.  SDR and DDR adaptation are
-	 * always on, and QDR is enabled until a few seconds after link
-	 * reaches LINKUP
+	 * always on, and QDR is initially enabled; later disabled.
 	 */
 	qib_write_kreg_port(ppd, krp_static_adapt_dis(0), 0ULL);
 	qib_write_kreg_port(ppd, krp_static_adapt_dis(1), 0ULL);
-	qib_write_kreg_port(ppd, krp_static_adapt_dis(2), 0ULL);
+	qib_write_kreg_port(ppd, krp_static_adapt_dis(2),
+			    ppd->dd->cspec->r1 ?
+			    QDR_STATIC_ADAPT_DOWN_R1 : QDR_STATIC_ADAPT_DOWN);
 	ppd->cpspec->qdr_dfe_on = 1;
 
 	/* (FLoop LOS gate: PPM filter  enabled */
@@ -7676,6 +7695,11 @@ static int serdes_7322_init(struct qib_p
 	/* rx offset center enabled */
 	ibsd_wr_allchans(ppd, 12, 1 << 4, 1 << 4);
 
+	if (!ppd->dd->cspec->r1) {
+		ibsd_wr_allchans(ppd, 12, 1 << 12, 1 << 12);
+		ibsd_wr_allchans(ppd, 12, 2 << 8, 0x0f << 8);
+	}
+
 	/* Set the frequency loop bandwidth to 15 */
 	ibsd_wr_allchans(ppd, 2, 15 << 5, BMASK(8, 5));
 
@@ -7783,11 +7807,14 @@ static void adj_tx_serdes(struct qib_ppo
 	qib_write_kreg_port(ppd, krp_tx_deemph_override, deemph);
 }
 
-/* set QDR forced value for H1 */
+/* set QDR forced value for H1, if needed */
 static void force_h1(struct qib_pportdata *ppd)
 {
 	int chan;
 
+	ppd->cpspec->qdr_reforce = 0;
+	if (!ppd->dd->cspec->r1)
+		return;
 	qib_cdbg(LINKVERB, "IB%u:%u Force H1 value to %u\n", ppd->dd->unit,
 		 ppd->port, ppd->cpspec->h1_val);
 
@@ -7797,7 +7824,6 @@ static void force_h1(struct qib_pportdat
 		clock_man(ppd, chan);
 		set_man_mode_h1(ppd, chan, 0, 0);
 	}
-	ppd->cpspec->qdr_reforce = 0;
 }
 
 /*
diff -up a/drivers/infiniband/hw/qib/qib_intr.c b/drivers/infiniband/hw/qib/qib_intr.c
--- a/drivers/infiniband/hw/qib/qib_intr.c	2010-04-14 16:15:00.000000000 -0700
+++ b/drivers/infiniband/hw/qib/qib_intr.c	2010-04-14 16:26:43.000000000 -0700
@@ -86,6 +86,7 @@ void handle_e_ibstatuschanged(struct qib
 	unsigned long flags;
 	u32 lstate;
 	u8 ltstate;
+	enum ib_event_type ev = 0;
 
 	lstate = dd->f_iblink_state(ibcs); /* linkstate */
 	ltstate = dd->f_ibphys_portstate(ibcs);
@@ -115,7 +116,7 @@ void handle_e_ibstatuschanged(struct qib
 		if (lstate != IB_PORT_ACTIVE) {
 			*ppd->statusp &= ~QIB_STATUS_IB_READY;
 			if (ppd->lflags & QIBL_LINKACTIVE)
-				signal_ib_event(ppd, IB_EVENT_PORT_ERR);
+				ev = IB_EVENT_PORT_ERR;
 			spin_lock_irqsave(&ppd->lflags_lock, flags);
 			if (lstate == IB_PORT_ARMED) {
 				ppd->lflags |= QIBL_LINKARMED | QIBL_LINKV;
@@ -144,12 +145,12 @@ void handle_e_ibstatuschanged(struct qib
 			if (dd->flags & QIB_HAS_SEND_DMA)
 				qib_sdma_process_event(ppd,
 					qib_sdma_event_e30_go_running);
-			signal_ib_event(ppd, IB_EVENT_PORT_ACTIVE);
+			ev = IB_EVENT_PORT_ACTIVE;
 			dd->f_setextled(ppd, 1);
 		}
 	} else { /* down */
 		if (ppd->lflags & QIBL_LINKACTIVE)
-			signal_ib_event(ppd, IB_EVENT_PORT_ERR);
+			ev = IB_EVENT_PORT_ERR;
 		spin_lock_irqsave(&ppd->lflags_lock, flags);
 		ppd->lflags |= QIBL_LINKDOWN | QIBL_LINKV;
 		ppd->lflags &= ~(QIBL_LINKINIT |
@@ -160,6 +161,8 @@ void handle_e_ibstatuschanged(struct qib
 
 skip_ibchange:
 	ppd->lastibcstat = ibcs;
+	if (ev)
+		signal_ib_event(ppd, ev);
 	return;
 }
 
diff -up a/drivers/infiniband/hw/qib/qib_verbs.c b/drivers/infiniband/hw/qib/qib_verbs.c
--- a/drivers/infiniband/hw/qib/qib_verbs.c	2010-04-14 16:15:00.000000000 -0700
+++ b/drivers/infiniband/hw/qib/qib_verbs.c	2010-04-14 16:26:58.000000000 -0700
@@ -1926,6 +1926,7 @@ static struct ib_ah *qib_create_ah(struc
 	struct qib_ah *ah;
 	struct ib_ah *ret;
 	struct qib_ibdev *dev = to_idev(pd->device);
+	unsigned long flags;
 
 	/* A multicast address requires a GRH (see ch. 8.4.1). */
 	if (ah_attr->dlid >= QIB_MULTICAST_LID_BASE &&
@@ -1945,16 +1946,16 @@ static struct ib_ah *qib_create_ah(struc
 		goto bail;
 	}
 
-	spin_lock(&dev->n_ahs_lock);
+	spin_lock_irqsave(&dev->n_ahs_lock, flags);
 	if (dev->n_ahs_allocated == ib_qib_max_ahs) {
-		spin_unlock(&dev->n_ahs_lock);
+		spin_unlock_irqrestore(&dev->n_ahs_lock, flags);
 		kfree(ah);
 		ret = ERR_PTR(-ENOMEM);
 		goto bail;
 	}
 
 	dev->n_ahs_allocated++;
-	spin_unlock(&dev->n_ahs_lock);
+	spin_unlock_irqrestore(&dev->n_ahs_lock, flags);
 
 	/* ib_create_ah() will initialize ah->ibah. */
 	ah->attr = *ah_attr;
@@ -1976,15 +1977,16 @@ static int qib_destroy_ah(struct ib_ah *
 {
 	struct qib_ibdev *dev = to_idev(ibah->device);
 	struct qib_ah *ah = to_iah(ibah);
+	unsigned long flags;
 
 	if (atomic_read(&ah->refcount) != 0) {
 		qib_dbg("AH busy (cnt %u)\n", atomic_read(&ah->refcount));
 		return -EBUSY;
 	}
 
-	spin_lock(&dev->n_ahs_lock);
+	spin_lock_irqsave(&dev->n_ahs_lock, flags);
 	dev->n_ahs_allocated--;
-	spin_unlock(&dev->n_ahs_lock);
+	spin_unlock_irqrestore(&dev->n_ahs_lock, flags);
 
 	kfree(ah);
 
diff -up a/drivers/infiniband/hw/qib/qib_verbs.h b/drivers/infiniband/hw/qib/qib_verbs.h
--- a/drivers/infiniband/hw/qib/qib_verbs.h	2010-04-14 16:15:00.000000000 -0700
+++ b/drivers/infiniband/hw/qib/qib_verbs.h	2010-04-14 16:26:52.000000000 -0700
@@ -266,7 +266,7 @@ struct qib_cq_wc {
  */
 struct qib_cq {
 	struct ib_cq ibcq;
-	struct tasklet_struct comptask;
+	struct work_struct comptask;
 	spinlock_t lock; /* protect changes in this struct */
 	u8 notify;
 	u8 triggered;
