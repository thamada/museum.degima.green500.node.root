diff --git a/drivers/infiniband/hw/ipath/Kconfig b/drivers/infiniband/hw/ipath/Kconfig
index 3c7968f..1d9bb11 100644
--- a/drivers/infiniband/hw/ipath/Kconfig
+++ b/drivers/infiniband/hw/ipath/Kconfig
@@ -1,9 +1,11 @@
 config INFINIBAND_IPATH
-	tristate "QLogic InfiniPath Driver"
-	depends on 64BIT && NET
+	tristate "QLogic HTX HCA support"
+	depends on 64BIT && NET && HT_IRQ
 	---help---
-	This is a driver for QLogic InfiniPath host channel adapters,
+	This is a driver for the obsolete QLogic Hyper-Transport
+	IB host channel adapter (model QHT7140),
 	including InfiniBand verbs support.  This driver allows these
 	devices to be used with both kernel upper level protocols such
 	as IP-over-InfiniBand as well as with userspace applications
 	(in conjunction with InfiniBand userspace access).
+	For QLogic PCIe QLE based cards, use the QIB driver instead.
diff --git a/drivers/infiniband/hw/ipath/Makefile b/drivers/infiniband/hw/ipath/Makefile
index bf94500..fa3df82 100644
--- a/drivers/infiniband/hw/ipath/Makefile
+++ b/drivers/infiniband/hw/ipath/Makefile
@@ -29,13 +29,9 @@ ib_ipath-y := \
 	ipath_user_pages.o \
 	ipath_user_sdma.o \
 	ipath_verbs_mcast.o \
-	ipath_verbs.o \
-	ipath_iba7220.o \
-	ipath_sd7220.o \
-	ipath_sd7220_img.o
+	ipath_verbs.o
 
 ib_ipath-$(CONFIG_HT_IRQ) += ipath_iba6110.o
-ib_ipath-$(CONFIG_PCI_MSI) += ipath_iba6120.o
 
 ib_ipath-$(CONFIG_X86_64) += ipath_wc_x86_64.o
 ib_ipath-$(CONFIG_PPC64) += ipath_wc_ppc64.o
diff --git a/drivers/infiniband/hw/ipath/ipath_7220.h b/drivers/infiniband/hw/ipath/ipath_7220.h
deleted file mode 100644
index 74fa5cc..0000000
--- a/drivers/infiniband/hw/ipath/ipath_7220.h
+++ /dev/null
@@ -1,57 +0,0 @@
-#ifndef _IPATH_7220_H
-#define _IPATH_7220_H
-/*
- * Copyright (c) 2007 QLogic Corporation. All rights reserved.
- *
- * This software is available to you under a choice of one of two
- * licenses.  You may choose to be licensed under the terms of the GNU
- * General Public License (GPL) Version 2, available from the file
- * COPYING in the main directory of this source tree, or the
- * OpenIB.org BSD license below:
- *
- *     Redistribution and use in source and binary forms, with or
- *     without modification, are permitted provided that the following
- *     conditions are met:
- *
- *      - Redistributions of source code must retain the above
- *        copyright notice, this list of conditions and the following
- *        disclaimer.
- *
- *      - Redistributions in binary form must reproduce the above
- *        copyright notice, this list of conditions and the following
- *        disclaimer in the documentation and/or other materials
- *        provided with the distribution.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
- * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
- * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
- * SOFTWARE.
- */
-
-/*
- * This header file provides the declarations and common definitions
- * for (mostly) manipulation of the SerDes blocks within the IBA7220.
- * the functions declared should only be called from within other
- * 7220-related files such as ipath_iba7220.c or ipath_sd7220.c.
- */
-int ipath_sd7220_presets(struct ipath_devdata *dd);
-int ipath_sd7220_init(struct ipath_devdata *dd, int was_reset);
-int ipath_sd7220_prog_ld(struct ipath_devdata *dd, int sdnum, u8 *img,
-	int len, int offset);
-int ipath_sd7220_prog_vfy(struct ipath_devdata *dd, int sdnum, const u8 *img,
-	int len, int offset);
-/*
- * Below used for sdnum parameter, selecting one of the two sections
- * used for PCIe, or the single SerDes used for IB, which is the
- * only one currently used
- */
-#define IB_7220_SERDES 2
-
-int ipath_sd7220_ib_load(struct ipath_devdata *dd);
-int ipath_sd7220_ib_vfy(struct ipath_devdata *dd);
-
-#endif /* _IPATH_7220_H */
diff --git a/drivers/infiniband/hw/ipath/ipath_driver.c b/drivers/infiniband/hw/ipath/ipath_driver.c
index 04e88b6..37f8573 100644
--- a/drivers/infiniband/hw/ipath/ipath_driver.c
+++ b/drivers/infiniband/hw/ipath/ipath_driver.c
@@ -129,18 +129,13 @@ static int __devinit ipath_init_one(struct pci_dev *,
 
 /* Only needed for registration, nothing else needs this info */
 #define PCI_VENDOR_ID_PATHSCALE 0x1fc1
-#define PCI_VENDOR_ID_QLOGIC 0x1077
 #define PCI_DEVICE_ID_INFINIPATH_HT 0xd
-#define PCI_DEVICE_ID_INFINIPATH_PE800 0x10
-#define PCI_DEVICE_ID_INFINIPATH_7220 0x7220
 
 /* Number of seconds before our card status check...  */
 #define STATUS_TIMEOUT 60
 
 static const struct pci_device_id ipath_pci_tbl[] = {
 	{ PCI_DEVICE(PCI_VENDOR_ID_PATHSCALE, PCI_DEVICE_ID_INFINIPATH_HT) },
-	{ PCI_DEVICE(PCI_VENDOR_ID_PATHSCALE, PCI_DEVICE_ID_INFINIPATH_PE800) },
-	{ PCI_DEVICE(PCI_VENDOR_ID_QLOGIC, PCI_DEVICE_ID_INFINIPATH_7220) },
 	{ 0, }
 };
 
@@ -518,30 +513,9 @@ static int __devinit ipath_init_one(struct pci_dev *pdev,
 	/* setup the chip-specific functions, as early as possible. */
 	switch (ent->device) {
 	case PCI_DEVICE_ID_INFINIPATH_HT:
-#ifdef CONFIG_HT_IRQ
 		ipath_init_iba6110_funcs(dd);
 		break;
-#else
-		ipath_dev_err(dd, "QLogic HT device 0x%x cannot work if "
-			      "CONFIG_HT_IRQ is not enabled\n", ent->device);
-		return -ENODEV;
-#endif
-	case PCI_DEVICE_ID_INFINIPATH_PE800:
-#ifdef CONFIG_PCI_MSI
-		ipath_init_iba6120_funcs(dd);
-		break;
-#else
-		ipath_dev_err(dd, "QLogic PCIE device 0x%x cannot work if "
-			      "CONFIG_PCI_MSI is not enabled\n", ent->device);
-		return -ENODEV;
-#endif
-	case PCI_DEVICE_ID_INFINIPATH_7220:
-#ifndef CONFIG_PCI_MSI
-		ipath_dbg("CONFIG_PCI_MSI is not enabled, "
-			  "using INTx for unit %u\n", dd->ipath_unit);
-#endif
-		ipath_init_iba7220_funcs(dd);
-		break;
+
 	default:
 		ipath_dev_err(dd, "Found unknown QLogic deviceid 0x%x, "
 			      "failing\n", ent->device);
diff --git a/drivers/infiniband/hw/ipath/ipath_iba6120.c b/drivers/infiniband/hw/ipath/ipath_iba6120.c
deleted file mode 100644
index fbf8c53..0000000
--- a/drivers/infiniband/hw/ipath/ipath_iba6120.c
+++ /dev/null
@@ -1,1862 +0,0 @@
-/*
- * Copyright (c) 2006, 2007, 2008 QLogic Corporation. All rights reserved.
- * Copyright (c) 2003, 2004, 2005, 2006 PathScale, Inc. All rights reserved.
- *
- * This software is available to you under a choice of one of two
- * licenses.  You may choose to be licensed under the terms of the GNU
- * General Public License (GPL) Version 2, available from the file
- * COPYING in the main directory of this source tree, or the
- * OpenIB.org BSD license below:
- *
- *     Redistribution and use in source and binary forms, with or
- *     without modification, are permitted provided that the following
- *     conditions are met:
- *
- *      - Redistributions of source code must retain the above
- *        copyright notice, this list of conditions and the following
- *        disclaimer.
- *
- *      - Redistributions in binary form must reproduce the above
- *        copyright notice, this list of conditions and the following
- *        disclaimer in the documentation and/or other materials
- *        provided with the distribution.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
- * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
- * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
- * SOFTWARE.
- */
-/*
- * This file contains all of the code that is specific to the
- * InfiniPath PCIe chip.
- */
-
-#include <linux/interrupt.h>
-#include <linux/pci.h>
-#include <linux/delay.h>
-#include <rdma/ib_verbs.h>
-
-#include "ipath_kernel.h"
-#include "ipath_registers.h"
-
-static void ipath_setup_pe_setextled(struct ipath_devdata *, u64, u64);
-
-/*
- * This file contains all the chip-specific register information and
- * access functions for the QLogic InfiniPath PCI-Express chip.
- *
- * This lists the InfiniPath registers, in the actual chip layout.
- * This structure should never be directly accessed.
- */
-struct _infinipath_do_not_use_kernel_regs {
-	unsigned long long Revision;
-	unsigned long long Control;
-	unsigned long long PageAlign;
-	unsigned long long PortCnt;
-	unsigned long long DebugPortSelect;
-	unsigned long long Reserved0;
-	unsigned long long SendRegBase;
-	unsigned long long UserRegBase;
-	unsigned long long CounterRegBase;
-	unsigned long long Scratch;
-	unsigned long long Reserved1;
-	unsigned long long Reserved2;
-	unsigned long long IntBlocked;
-	unsigned long long IntMask;
-	unsigned long long IntStatus;
-	unsigned long long IntClear;
-	unsigned long long ErrorMask;
-	unsigned long long ErrorStatus;
-	unsigned long long ErrorClear;
-	unsigned long long HwErrMask;
-	unsigned long long HwErrStatus;
-	unsigned long long HwErrClear;
-	unsigned long long HwDiagCtrl;
-	unsigned long long MDIO;
-	unsigned long long IBCStatus;
-	unsigned long long IBCCtrl;
-	unsigned long long ExtStatus;
-	unsigned long long ExtCtrl;
-	unsigned long long GPIOOut;
-	unsigned long long GPIOMask;
-	unsigned long long GPIOStatus;
-	unsigned long long GPIOClear;
-	unsigned long long RcvCtrl;
-	unsigned long long RcvBTHQP;
-	unsigned long long RcvHdrSize;
-	unsigned long long RcvHdrCnt;
-	unsigned long long RcvHdrEntSize;
-	unsigned long long RcvTIDBase;
-	unsigned long long RcvTIDCnt;
-	unsigned long long RcvEgrBase;
-	unsigned long long RcvEgrCnt;
-	unsigned long long RcvBufBase;
-	unsigned long long RcvBufSize;
-	unsigned long long RxIntMemBase;
-	unsigned long long RxIntMemSize;
-	unsigned long long RcvPartitionKey;
-	unsigned long long Reserved3;
-	unsigned long long RcvPktLEDCnt;
-	unsigned long long Reserved4[8];
-	unsigned long long SendCtrl;
-	unsigned long long SendPIOBufBase;
-	unsigned long long SendPIOSize;
-	unsigned long long SendPIOBufCnt;
-	unsigned long long SendPIOAvailAddr;
-	unsigned long long TxIntMemBase;
-	unsigned long long TxIntMemSize;
-	unsigned long long Reserved5;
-	unsigned long long PCIeRBufTestReg0;
-	unsigned long long PCIeRBufTestReg1;
-	unsigned long long Reserved51[6];
-	unsigned long long SendBufferError;
-	unsigned long long SendBufferErrorCONT1;
-	unsigned long long Reserved6SBE[6];
-	unsigned long long RcvHdrAddr0;
-	unsigned long long RcvHdrAddr1;
-	unsigned long long RcvHdrAddr2;
-	unsigned long long RcvHdrAddr3;
-	unsigned long long RcvHdrAddr4;
-	unsigned long long Reserved7RHA[11];
-	unsigned long long RcvHdrTailAddr0;
-	unsigned long long RcvHdrTailAddr1;
-	unsigned long long RcvHdrTailAddr2;
-	unsigned long long RcvHdrTailAddr3;
-	unsigned long long RcvHdrTailAddr4;
-	unsigned long long Reserved8RHTA[11];
-	unsigned long long Reserved9SW[8];
-	unsigned long long SerdesConfig0;
-	unsigned long long SerdesConfig1;
-	unsigned long long SerdesStatus;
-	unsigned long long XGXSConfig;
-	unsigned long long IBPLLCfg;
-	unsigned long long Reserved10SW2[3];
-	unsigned long long PCIEQ0SerdesConfig0;
-	unsigned long long PCIEQ0SerdesConfig1;
-	unsigned long long PCIEQ0SerdesStatus;
-	unsigned long long Reserved11;
-	unsigned long long PCIEQ1SerdesConfig0;
-	unsigned long long PCIEQ1SerdesConfig1;
-	unsigned long long PCIEQ1SerdesStatus;
-	unsigned long long Reserved12;
-};
-
-struct _infinipath_do_not_use_counters {
-	__u64 LBIntCnt;
-	__u64 LBFlowStallCnt;
-	__u64 Reserved1;
-	__u64 TxUnsupVLErrCnt;
-	__u64 TxDataPktCnt;
-	__u64 TxFlowPktCnt;
-	__u64 TxDwordCnt;
-	__u64 TxLenErrCnt;
-	__u64 TxMaxMinLenErrCnt;
-	__u64 TxUnderrunCnt;
-	__u64 TxFlowStallCnt;
-	__u64 TxDroppedPktCnt;
-	__u64 RxDroppedPktCnt;
-	__u64 RxDataPktCnt;
-	__u64 RxFlowPktCnt;
-	__u64 RxDwordCnt;
-	__u64 RxLenErrCnt;
-	__u64 RxMaxMinLenErrCnt;
-	__u64 RxICRCErrCnt;
-	__u64 RxVCRCErrCnt;
-	__u64 RxFlowCtrlErrCnt;
-	__u64 RxBadFormatCnt;
-	__u64 RxLinkProblemCnt;
-	__u64 RxEBPCnt;
-	__u64 RxLPCRCErrCnt;
-	__u64 RxBufOvflCnt;
-	__u64 RxTIDFullErrCnt;
-	__u64 RxTIDValidErrCnt;
-	__u64 RxPKeyMismatchCnt;
-	__u64 RxP0HdrEgrOvflCnt;
-	__u64 RxP1HdrEgrOvflCnt;
-	__u64 RxP2HdrEgrOvflCnt;
-	__u64 RxP3HdrEgrOvflCnt;
-	__u64 RxP4HdrEgrOvflCnt;
-	__u64 RxP5HdrEgrOvflCnt;
-	__u64 RxP6HdrEgrOvflCnt;
-	__u64 RxP7HdrEgrOvflCnt;
-	__u64 RxP8HdrEgrOvflCnt;
-	__u64 Reserved6;
-	__u64 Reserved7;
-	__u64 IBStatusChangeCnt;
-	__u64 IBLinkErrRecoveryCnt;
-	__u64 IBLinkDownedCnt;
-	__u64 IBSymbolErrCnt;
-};
-
-#define IPATH_KREG_OFFSET(field) (offsetof( \
-	struct _infinipath_do_not_use_kernel_regs, field) / sizeof(u64))
-#define IPATH_CREG_OFFSET(field) (offsetof( \
-	struct _infinipath_do_not_use_counters, field) / sizeof(u64))
-
-static const struct ipath_kregs ipath_pe_kregs = {
-	.kr_control = IPATH_KREG_OFFSET(Control),
-	.kr_counterregbase = IPATH_KREG_OFFSET(CounterRegBase),
-	.kr_debugportselect = IPATH_KREG_OFFSET(DebugPortSelect),
-	.kr_errorclear = IPATH_KREG_OFFSET(ErrorClear),
-	.kr_errormask = IPATH_KREG_OFFSET(ErrorMask),
-	.kr_errorstatus = IPATH_KREG_OFFSET(ErrorStatus),
-	.kr_extctrl = IPATH_KREG_OFFSET(ExtCtrl),
-	.kr_extstatus = IPATH_KREG_OFFSET(ExtStatus),
-	.kr_gpio_clear = IPATH_KREG_OFFSET(GPIOClear),
-	.kr_gpio_mask = IPATH_KREG_OFFSET(GPIOMask),
-	.kr_gpio_out = IPATH_KREG_OFFSET(GPIOOut),
-	.kr_gpio_status = IPATH_KREG_OFFSET(GPIOStatus),
-	.kr_hwdiagctrl = IPATH_KREG_OFFSET(HwDiagCtrl),
-	.kr_hwerrclear = IPATH_KREG_OFFSET(HwErrClear),
-	.kr_hwerrmask = IPATH_KREG_OFFSET(HwErrMask),
-	.kr_hwerrstatus = IPATH_KREG_OFFSET(HwErrStatus),
-	.kr_ibcctrl = IPATH_KREG_OFFSET(IBCCtrl),
-	.kr_ibcstatus = IPATH_KREG_OFFSET(IBCStatus),
-	.kr_intblocked = IPATH_KREG_OFFSET(IntBlocked),
-	.kr_intclear = IPATH_KREG_OFFSET(IntClear),
-	.kr_intmask = IPATH_KREG_OFFSET(IntMask),
-	.kr_intstatus = IPATH_KREG_OFFSET(IntStatus),
-	.kr_mdio = IPATH_KREG_OFFSET(MDIO),
-	.kr_pagealign = IPATH_KREG_OFFSET(PageAlign),
-	.kr_partitionkey = IPATH_KREG_OFFSET(RcvPartitionKey),
-	.kr_portcnt = IPATH_KREG_OFFSET(PortCnt),
-	.kr_rcvbthqp = IPATH_KREG_OFFSET(RcvBTHQP),
-	.kr_rcvbufbase = IPATH_KREG_OFFSET(RcvBufBase),
-	.kr_rcvbufsize = IPATH_KREG_OFFSET(RcvBufSize),
-	.kr_rcvctrl = IPATH_KREG_OFFSET(RcvCtrl),
-	.kr_rcvegrbase = IPATH_KREG_OFFSET(RcvEgrBase),
-	.kr_rcvegrcnt = IPATH_KREG_OFFSET(RcvEgrCnt),
-	.kr_rcvhdrcnt = IPATH_KREG_OFFSET(RcvHdrCnt),
-	.kr_rcvhdrentsize = IPATH_KREG_OFFSET(RcvHdrEntSize),
-	.kr_rcvhdrsize = IPATH_KREG_OFFSET(RcvHdrSize),
-	.kr_rcvintmembase = IPATH_KREG_OFFSET(RxIntMemBase),
-	.kr_rcvintmemsize = IPATH_KREG_OFFSET(RxIntMemSize),
-	.kr_rcvtidbase = IPATH_KREG_OFFSET(RcvTIDBase),
-	.kr_rcvtidcnt = IPATH_KREG_OFFSET(RcvTIDCnt),
-	.kr_revision = IPATH_KREG_OFFSET(Revision),
-	.kr_scratch = IPATH_KREG_OFFSET(Scratch),
-	.kr_sendbuffererror = IPATH_KREG_OFFSET(SendBufferError),
-	.kr_sendctrl = IPATH_KREG_OFFSET(SendCtrl),
-	.kr_sendpioavailaddr = IPATH_KREG_OFFSET(SendPIOAvailAddr),
-	.kr_sendpiobufbase = IPATH_KREG_OFFSET(SendPIOBufBase),
-	.kr_sendpiobufcnt = IPATH_KREG_OFFSET(SendPIOBufCnt),
-	.kr_sendpiosize = IPATH_KREG_OFFSET(SendPIOSize),
-	.kr_sendregbase = IPATH_KREG_OFFSET(SendRegBase),
-	.kr_txintmembase = IPATH_KREG_OFFSET(TxIntMemBase),
-	.kr_txintmemsize = IPATH_KREG_OFFSET(TxIntMemSize),
-	.kr_userregbase = IPATH_KREG_OFFSET(UserRegBase),
-	.kr_serdesconfig0 = IPATH_KREG_OFFSET(SerdesConfig0),
-	.kr_serdesconfig1 = IPATH_KREG_OFFSET(SerdesConfig1),
-	.kr_serdesstatus = IPATH_KREG_OFFSET(SerdesStatus),
-	.kr_xgxsconfig = IPATH_KREG_OFFSET(XGXSConfig),
-	.kr_ibpllcfg = IPATH_KREG_OFFSET(IBPLLCfg),
-
-	/*
-	 * These should not be used directly via ipath_write_kreg64(),
-	 * use them with ipath_write_kreg64_port(),
-	 */
-	.kr_rcvhdraddr = IPATH_KREG_OFFSET(RcvHdrAddr0),
-	.kr_rcvhdrtailaddr = IPATH_KREG_OFFSET(RcvHdrTailAddr0),
-
-	/* The rcvpktled register controls one of the debug port signals, so
-	 * a packet activity LED can be connected to it. */
-	.kr_rcvpktledcnt = IPATH_KREG_OFFSET(RcvPktLEDCnt),
-	.kr_pcierbuftestreg0 = IPATH_KREG_OFFSET(PCIeRBufTestReg0),
-	.kr_pcierbuftestreg1 = IPATH_KREG_OFFSET(PCIeRBufTestReg1),
-	.kr_pcieq0serdesconfig0 = IPATH_KREG_OFFSET(PCIEQ0SerdesConfig0),
-	.kr_pcieq0serdesconfig1 = IPATH_KREG_OFFSET(PCIEQ0SerdesConfig1),
-	.kr_pcieq0serdesstatus = IPATH_KREG_OFFSET(PCIEQ0SerdesStatus),
-	.kr_pcieq1serdesconfig0 = IPATH_KREG_OFFSET(PCIEQ1SerdesConfig0),
-	.kr_pcieq1serdesconfig1 = IPATH_KREG_OFFSET(PCIEQ1SerdesConfig1),
-	.kr_pcieq1serdesstatus = IPATH_KREG_OFFSET(PCIEQ1SerdesStatus)
-};
-
-static const struct ipath_cregs ipath_pe_cregs = {
-	.cr_badformatcnt = IPATH_CREG_OFFSET(RxBadFormatCnt),
-	.cr_erricrccnt = IPATH_CREG_OFFSET(RxICRCErrCnt),
-	.cr_errlinkcnt = IPATH_CREG_OFFSET(RxLinkProblemCnt),
-	.cr_errlpcrccnt = IPATH_CREG_OFFSET(RxLPCRCErrCnt),
-	.cr_errpkey = IPATH_CREG_OFFSET(RxPKeyMismatchCnt),
-	.cr_errrcvflowctrlcnt = IPATH_CREG_OFFSET(RxFlowCtrlErrCnt),
-	.cr_err_rlencnt = IPATH_CREG_OFFSET(RxLenErrCnt),
-	.cr_errslencnt = IPATH_CREG_OFFSET(TxLenErrCnt),
-	.cr_errtidfull = IPATH_CREG_OFFSET(RxTIDFullErrCnt),
-	.cr_errtidvalid = IPATH_CREG_OFFSET(RxTIDValidErrCnt),
-	.cr_errvcrccnt = IPATH_CREG_OFFSET(RxVCRCErrCnt),
-	.cr_ibstatuschange = IPATH_CREG_OFFSET(IBStatusChangeCnt),
-	.cr_intcnt = IPATH_CREG_OFFSET(LBIntCnt),
-	.cr_invalidrlencnt = IPATH_CREG_OFFSET(RxMaxMinLenErrCnt),
-	.cr_invalidslencnt = IPATH_CREG_OFFSET(TxMaxMinLenErrCnt),
-	.cr_lbflowstallcnt = IPATH_CREG_OFFSET(LBFlowStallCnt),
-	.cr_pktrcvcnt = IPATH_CREG_OFFSET(RxDataPktCnt),
-	.cr_pktrcvflowctrlcnt = IPATH_CREG_OFFSET(RxFlowPktCnt),
-	.cr_pktsendcnt = IPATH_CREG_OFFSET(TxDataPktCnt),
-	.cr_pktsendflowcnt = IPATH_CREG_OFFSET(TxFlowPktCnt),
-	.cr_portovflcnt = IPATH_CREG_OFFSET(RxP0HdrEgrOvflCnt),
-	.cr_rcvebpcnt = IPATH_CREG_OFFSET(RxEBPCnt),
-	.cr_rcvovflcnt = IPATH_CREG_OFFSET(RxBufOvflCnt),
-	.cr_senddropped = IPATH_CREG_OFFSET(TxDroppedPktCnt),
-	.cr_sendstallcnt = IPATH_CREG_OFFSET(TxFlowStallCnt),
-	.cr_sendunderruncnt = IPATH_CREG_OFFSET(TxUnderrunCnt),
-	.cr_wordrcvcnt = IPATH_CREG_OFFSET(RxDwordCnt),
-	.cr_wordsendcnt = IPATH_CREG_OFFSET(TxDwordCnt),
-	.cr_unsupvlcnt = IPATH_CREG_OFFSET(TxUnsupVLErrCnt),
-	.cr_rxdroppktcnt = IPATH_CREG_OFFSET(RxDroppedPktCnt),
-	.cr_iblinkerrrecovcnt = IPATH_CREG_OFFSET(IBLinkErrRecoveryCnt),
-	.cr_iblinkdowncnt = IPATH_CREG_OFFSET(IBLinkDownedCnt),
-	.cr_ibsymbolerrcnt = IPATH_CREG_OFFSET(IBSymbolErrCnt)
-};
-
-/* kr_control bits */
-#define INFINIPATH_C_RESET 1U
-
-/* kr_intstatus, kr_intclear, kr_intmask bits */
-#define INFINIPATH_I_RCVURG_MASK ((1U<<5)-1)
-#define INFINIPATH_I_RCVURG_SHIFT 0
-#define INFINIPATH_I_RCVAVAIL_MASK ((1U<<5)-1)
-#define INFINIPATH_I_RCVAVAIL_SHIFT 12
-
-/* kr_hwerrclear, kr_hwerrmask, kr_hwerrstatus, bits */
-#define INFINIPATH_HWE_PCIEMEMPARITYERR_MASK  0x000000000000003fULL
-#define INFINIPATH_HWE_PCIEMEMPARITYERR_SHIFT 0
-#define INFINIPATH_HWE_PCIEPOISONEDTLP      0x0000000010000000ULL
-#define INFINIPATH_HWE_PCIECPLTIMEOUT       0x0000000020000000ULL
-#define INFINIPATH_HWE_PCIEBUSPARITYXTLH    0x0000000040000000ULL
-#define INFINIPATH_HWE_PCIEBUSPARITYXADM    0x0000000080000000ULL
-#define INFINIPATH_HWE_PCIEBUSPARITYRADM    0x0000000100000000ULL
-#define INFINIPATH_HWE_COREPLL_FBSLIP       0x0080000000000000ULL
-#define INFINIPATH_HWE_COREPLL_RFSLIP       0x0100000000000000ULL
-#define INFINIPATH_HWE_PCIE1PLLFAILED       0x0400000000000000ULL
-#define INFINIPATH_HWE_PCIE0PLLFAILED       0x0800000000000000ULL
-#define INFINIPATH_HWE_SERDESPLLFAILED      0x1000000000000000ULL
-
-#define IBA6120_IBCS_LINKTRAININGSTATE_MASK 0xf
-#define IBA6120_IBCS_LINKSTATE_SHIFT 4
-
-/* kr_extstatus bits */
-#define INFINIPATH_EXTS_FREQSEL 0x2
-#define INFINIPATH_EXTS_SERDESSEL 0x4
-#define INFINIPATH_EXTS_MEMBIST_ENDTEST     0x0000000000004000
-#define INFINIPATH_EXTS_MEMBIST_FOUND       0x0000000000008000
-
-/* kr_xgxsconfig bits */
-#define INFINIPATH_XGXS_RESET          0x5ULL
-
-#define _IPATH_GPIO_SDA_NUM 1
-#define _IPATH_GPIO_SCL_NUM 0
-
-#define IPATH_GPIO_SDA (1ULL << \
-	(_IPATH_GPIO_SDA_NUM+INFINIPATH_EXTC_GPIOOE_SHIFT))
-#define IPATH_GPIO_SCL (1ULL << \
-	(_IPATH_GPIO_SCL_NUM+INFINIPATH_EXTC_GPIOOE_SHIFT))
-
-#define INFINIPATH_RT_BUFSIZE_MASK 0xe0000000ULL
-#define INFINIPATH_RT_BUFSIZE_SHIFTVAL(tid) \
-	((((tid) & INFINIPATH_RT_BUFSIZE_MASK) >> 29) + 11 - 1)
-#define INFINIPATH_RT_BUFSIZE(tid) (1 << INFINIPATH_RT_BUFSIZE_SHIFTVAL(tid))
-#define INFINIPATH_RT_IS_VALID(tid) \
-	(((tid) & INFINIPATH_RT_BUFSIZE_MASK) && \
-	 ((((tid) & INFINIPATH_RT_BUFSIZE_MASK) != INFINIPATH_RT_BUFSIZE_MASK)))
-#define INFINIPATH_RT_ADDR_MASK 0x1FFFFFFFULL /* 29 bits valid */
-#define INFINIPATH_RT_ADDR_SHIFT 10
-
-#define INFINIPATH_R_INTRAVAIL_SHIFT 16
-#define INFINIPATH_R_TAILUPD_SHIFT 31
-
-/* 6120 specific hardware errors... */
-static const struct ipath_hwerror_msgs ipath_6120_hwerror_msgs[] = {
-	INFINIPATH_HWE_MSG(PCIEPOISONEDTLP, "PCIe Poisoned TLP"),
-	INFINIPATH_HWE_MSG(PCIECPLTIMEOUT, "PCIe completion timeout"),
-	/*
-	 * In practice, it's unlikely wthat we'll see PCIe PLL, or bus
-	 * parity or memory parity error failures, because most likely we
-	 * won't be able to talk to the core of the chip.  Nonetheless, we
-	 * might see them, if they are in parts of the PCIe core that aren't
-	 * essential.
-	 */
-	INFINIPATH_HWE_MSG(PCIE1PLLFAILED, "PCIePLL1"),
-	INFINIPATH_HWE_MSG(PCIE0PLLFAILED, "PCIePLL0"),
-	INFINIPATH_HWE_MSG(PCIEBUSPARITYXTLH, "PCIe XTLH core parity"),
-	INFINIPATH_HWE_MSG(PCIEBUSPARITYXADM, "PCIe ADM TX core parity"),
-	INFINIPATH_HWE_MSG(PCIEBUSPARITYRADM, "PCIe ADM RX core parity"),
-	INFINIPATH_HWE_MSG(RXDSYNCMEMPARITYERR, "Rx Dsync"),
-	INFINIPATH_HWE_MSG(SERDESPLLFAILED, "SerDes PLL"),
-};
-
-#define TXE_PIO_PARITY ((INFINIPATH_HWE_TXEMEMPARITYERR_PIOBUF | \
-		        INFINIPATH_HWE_TXEMEMPARITYERR_PIOPBC) \
-		        << INFINIPATH_HWE_TXEMEMPARITYERR_SHIFT)
-#define RXE_EAGER_PARITY (INFINIPATH_HWE_RXEMEMPARITYERR_EAGERTID \
-			  << INFINIPATH_HWE_RXEMEMPARITYERR_SHIFT)
-
-static void ipath_pe_put_tid_2(struct ipath_devdata *, u64 __iomem *,
-			       u32, unsigned long);
-
-/*
- * On platforms using this chip, and not having ordered WC stores, we
- * can get TXE parity errors due to speculative reads to the PIO buffers,
- * and this, due to a chip bug can result in (many) false parity error
- * reports.  So it's a debug print on those, and an info print on systems
- * where the speculative reads don't occur.
- */
-static void ipath_pe_txe_recover(struct ipath_devdata *dd)
-{
-	if (ipath_unordered_wc())
-		ipath_dbg("Recovering from TXE PIO parity error\n");
-	else {
-		++ipath_stats.sps_txeparity;
-		dev_info(&dd->pcidev->dev,
-			"Recovering from TXE PIO parity error\n");
-	}
-}
-
-
-/**
- * ipath_pe_handle_hwerrors - display hardware errors.
- * @dd: the infinipath device
- * @msg: the output buffer
- * @msgl: the size of the output buffer
- *
- * Use same msg buffer as regular errors to avoid excessive stack
- * use.  Most hardware errors are catastrophic, but for right now,
- * we'll print them and continue.  We reuse the same message buffer as
- * ipath_handle_errors() to avoid excessive stack usage.
- */
-static void ipath_pe_handle_hwerrors(struct ipath_devdata *dd, char *msg,
-				     size_t msgl)
-{
-	ipath_err_t hwerrs;
-	u32 bits, ctrl;
-	int isfatal = 0;
-	char bitsmsg[64];
-	int log_idx;
-
-	hwerrs = ipath_read_kreg64(dd, dd->ipath_kregs->kr_hwerrstatus);
-	if (!hwerrs) {
-		/*
-		 * better than printing cofusing messages
-		 * This seems to be related to clearing the crc error, or
-		 * the pll error during init.
-		 */
-		ipath_cdbg(VERBOSE, "Called but no hardware errors set\n");
-		return;
-	} else if (hwerrs == ~0ULL) {
-		ipath_dev_err(dd, "Read of hardware error status failed "
-			      "(all bits set); ignoring\n");
-		return;
-	}
-	ipath_stats.sps_hwerrs++;
-
-	/* Always clear the error status register, except MEMBISTFAIL,
-	 * regardless of whether we continue or stop using the chip.
-	 * We want that set so we know it failed, even across driver reload.
-	 * We'll still ignore it in the hwerrmask.  We do this partly for
-	 * diagnostics, but also for support */
-	ipath_write_kreg(dd, dd->ipath_kregs->kr_hwerrclear,
-			 hwerrs&~INFINIPATH_HWE_MEMBISTFAILED);
-
-	hwerrs &= dd->ipath_hwerrmask;
-
-	/* We log some errors to EEPROM, check if we have any of those. */
-	for (log_idx = 0; log_idx < IPATH_EEP_LOG_CNT; ++log_idx)
-		if (hwerrs & dd->ipath_eep_st_masks[log_idx].hwerrs_to_log)
-			ipath_inc_eeprom_err(dd, log_idx, 1);
-
-	/*
-	 * make sure we get this much out, unless told to be quiet,
-	 * or it's occurred within the last 5 seconds
-	 */
-	if ((hwerrs & ~(dd->ipath_lasthwerror | TXE_PIO_PARITY |
-			RXE_EAGER_PARITY)) ||
-	    (ipath_debug & __IPATH_VERBDBG))
-		dev_info(&dd->pcidev->dev, "Hardware error: hwerr=0x%llx "
-			 "(cleared)\n", (unsigned long long) hwerrs);
-	dd->ipath_lasthwerror |= hwerrs;
-
-	if (hwerrs & ~dd->ipath_hwe_bitsextant)
-		ipath_dev_err(dd, "hwerror interrupt with unknown errors "
-			      "%llx set\n", (unsigned long long)
-			      (hwerrs & ~dd->ipath_hwe_bitsextant));
-
-	ctrl = ipath_read_kreg32(dd, dd->ipath_kregs->kr_control);
-	if ((ctrl & INFINIPATH_C_FREEZEMODE) && !ipath_diag_inuse) {
-		/*
-		 * parity errors in send memory are recoverable,
-		 * just cancel the send (if indicated in * sendbuffererror),
-		 * count the occurrence, unfreeze (if no other handled
-		 * hardware error bits are set), and continue. They can
-		 * occur if a processor speculative read is done to the PIO
-		 * buffer while we are sending a packet, for example.
-		 */
-		if (hwerrs & TXE_PIO_PARITY) {
-			ipath_pe_txe_recover(dd);
-			hwerrs &= ~TXE_PIO_PARITY;
-		}
-		if (!hwerrs) {
-			static u32 freeze_cnt;
-
-			freeze_cnt++;
-			ipath_dbg("Clearing freezemode on ignored or recovered "
-				  "hardware error (%u)\n", freeze_cnt);
-			ipath_clear_freeze(dd);
-		}
-	}
-
-	*msg = '\0';
-
-	if (hwerrs & INFINIPATH_HWE_MEMBISTFAILED) {
-		strlcat(msg, "[Memory BIST test failed, InfiniPath hardware unusable]",
-			msgl);
-		/* ignore from now on, so disable until driver reloaded */
-		*dd->ipath_statusp |= IPATH_STATUS_HWERROR;
-		dd->ipath_hwerrmask &= ~INFINIPATH_HWE_MEMBISTFAILED;
-		ipath_write_kreg(dd, dd->ipath_kregs->kr_hwerrmask,
-				 dd->ipath_hwerrmask);
-	}
-
-	ipath_format_hwerrors(hwerrs,
-			      ipath_6120_hwerror_msgs,
-			      sizeof(ipath_6120_hwerror_msgs)/
-			      sizeof(ipath_6120_hwerror_msgs[0]),
-			      msg, msgl);
-
-	if (hwerrs & (INFINIPATH_HWE_PCIEMEMPARITYERR_MASK
-		      << INFINIPATH_HWE_PCIEMEMPARITYERR_SHIFT)) {
-		bits = (u32) ((hwerrs >>
-			       INFINIPATH_HWE_PCIEMEMPARITYERR_SHIFT) &
-			      INFINIPATH_HWE_PCIEMEMPARITYERR_MASK);
-		snprintf(bitsmsg, sizeof bitsmsg,
-			 "[PCIe Mem Parity Errs %x] ", bits);
-		strlcat(msg, bitsmsg, msgl);
-	}
-
-#define _IPATH_PLL_FAIL (INFINIPATH_HWE_COREPLL_FBSLIP |	\
-			 INFINIPATH_HWE_COREPLL_RFSLIP )
-
-	if (hwerrs & _IPATH_PLL_FAIL) {
-		snprintf(bitsmsg, sizeof bitsmsg,
-			 "[PLL failed (%llx), InfiniPath hardware unusable]",
-			 (unsigned long long) hwerrs & _IPATH_PLL_FAIL);
-		strlcat(msg, bitsmsg, msgl);
-		/* ignore from now on, so disable until driver reloaded */
-		dd->ipath_hwerrmask &= ~(hwerrs & _IPATH_PLL_FAIL);
-		ipath_write_kreg(dd, dd->ipath_kregs->kr_hwerrmask,
-				 dd->ipath_hwerrmask);
-	}
-
-	if (hwerrs & INFINIPATH_HWE_SERDESPLLFAILED) {
-		/*
-		 * If it occurs, it is left masked since the external
-		 * interface is unused
-		 */
-		dd->ipath_hwerrmask &= ~INFINIPATH_HWE_SERDESPLLFAILED;
-		ipath_write_kreg(dd, dd->ipath_kregs->kr_hwerrmask,
-				 dd->ipath_hwerrmask);
-	}
-
-	if (hwerrs) {
-		/*
-		 * if any set that we aren't ignoring; only
-		 * make the complaint once, in case it's stuck
-		 * or recurring, and we get here multiple
-		 * times.
-		 */
-		ipath_dev_err(dd, "%s hardware error\n", msg);
-		if (dd->ipath_flags & IPATH_INITTED) {
-			ipath_set_linkstate(dd, IPATH_IB_LINKDOWN);
-			ipath_setup_pe_setextled(dd,
-				INFINIPATH_IBCS_L_STATE_DOWN,
-				INFINIPATH_IBCS_LT_STATE_DISABLED);
-			ipath_dev_err(dd, "Fatal Hardware Error (freeze "
-					  "mode), no longer usable, SN %.16s\n",
-					  dd->ipath_serial);
-			isfatal = 1;
-		}
-		*dd->ipath_statusp &= ~IPATH_STATUS_IB_READY;
-		/* mark as having had error */
-		*dd->ipath_statusp |= IPATH_STATUS_HWERROR;
-		/*
-		 * mark as not usable, at a minimum until driver
-		 * is reloaded, probably until reboot, since no
-		 * other reset is possible.
-		 */
-		dd->ipath_flags &= ~IPATH_INITTED;
-	} else
-		*msg = 0; /* recovered from all of them */
-
-	if (isfatal && !ipath_diag_inuse && dd->ipath_freezemsg && msg) {
-		/*
-		 * for /sys status file ; if no trailing brace is copied,
-		 * we'll know it was truncated.
-		 */
-		snprintf(dd->ipath_freezemsg, dd->ipath_freezelen,
-			 "{%s}", msg);
-	}
-}
-
-/**
- * ipath_pe_boardname - fill in the board name
- * @dd: the infinipath device
- * @name: the output buffer
- * @namelen: the size of the output buffer
- *
- * info is based on the board revision register
- */
-static int ipath_pe_boardname(struct ipath_devdata *dd, char *name,
-			      size_t namelen)
-{
-	char *n = NULL;
-	u8 boardrev = dd->ipath_boardrev;
-	int ret;
-
-	switch (boardrev) {
-	case 0:
-		n = "InfiniPath_Emulation";
-		break;
-	case 1:
-		n = "InfiniPath_QLE7140-Bringup";
-		break;
-	case 2:
-		n = "InfiniPath_QLE7140";
-		break;
-	case 3:
-		n = "InfiniPath_QMI7140";
-		break;
-	case 4:
-		n = "InfiniPath_QEM7140";
-		break;
-	case 5:
-		n = "InfiniPath_QMH7140";
-		break;
-	case 6:
-		n = "InfiniPath_QLE7142";
-		break;
-	default:
-		ipath_dev_err(dd,
-			      "Don't yet know about board with ID %u\n",
-			      boardrev);
-		snprintf(name, namelen, "Unknown_InfiniPath_PCIe_%u",
-			 boardrev);
-		break;
-	}
-	if (n)
-		snprintf(name, namelen, "%s", n);
-
-	if (dd->ipath_majrev != 4 || !dd->ipath_minrev || dd->ipath_minrev>2) {
-		ipath_dev_err(dd, "Unsupported InfiniPath hardware revision %u.%u!\n",
-			      dd->ipath_majrev, dd->ipath_minrev);
-		ret = 1;
-	} else {
-		ret = 0;
-		if (dd->ipath_minrev >= 2)
-			dd->ipath_f_put_tid = ipath_pe_put_tid_2;
-	}
-
-	/*
-	 * set here, not in ipath_init_*_funcs because we have to do
-	 * it after we can read chip registers.
-	 */
-	dd->ipath_ureg_align =
-		ipath_read_kreg32(dd, dd->ipath_kregs->kr_pagealign);
-
-	return ret;
-}
-
-/**
- * ipath_pe_init_hwerrors - enable hardware errors
- * @dd: the infinipath device
- *
- * now that we have finished initializing everything that might reasonably
- * cause a hardware error, and cleared those errors bits as they occur,
- * we can enable hardware errors in the mask (potentially enabling
- * freeze mode), and enable hardware errors as errors (along with
- * everything else) in errormask
- */
-static void ipath_pe_init_hwerrors(struct ipath_devdata *dd)
-{
-	ipath_err_t val;
-	u64 extsval;
-
-	extsval = ipath_read_kreg64(dd, dd->ipath_kregs->kr_extstatus);
-
-	if (!(extsval & INFINIPATH_EXTS_MEMBIST_ENDTEST))
-		ipath_dev_err(dd, "MemBIST did not complete!\n");
-	if (extsval & INFINIPATH_EXTS_MEMBIST_FOUND)
-		ipath_dbg("MemBIST corrected\n");
-
-	val = ~0ULL;	/* barring bugs, all hwerrors become interrupts, */
-
-	if (!dd->ipath_boardrev)	// no PLL for Emulator
-		val &= ~INFINIPATH_HWE_SERDESPLLFAILED;
-
-	if (dd->ipath_minrev < 2) {
-		/* workaround bug 9460 in internal interface bus parity
-		 * checking. Fixed (HW bug 9490) in Rev2.
-		 */
-		val &= ~INFINIPATH_HWE_PCIEBUSPARITYRADM;
-	}
-	dd->ipath_hwerrmask = val;
-}
-
-/**
- * ipath_pe_bringup_serdes - bring up the serdes
- * @dd: the infinipath device
- */
-static int ipath_pe_bringup_serdes(struct ipath_devdata *dd)
-{
-	u64 val, config1, prev_val;
-	int ret = 0;
-
-	ipath_dbg("Trying to bringup serdes\n");
-
-	if (ipath_read_kreg64(dd, dd->ipath_kregs->kr_hwerrstatus) &
-	    INFINIPATH_HWE_SERDESPLLFAILED) {
-		ipath_dbg("At start, serdes PLL failed bit set "
-			  "in hwerrstatus, clearing and continuing\n");
-		ipath_write_kreg(dd, dd->ipath_kregs->kr_hwerrclear,
-				 INFINIPATH_HWE_SERDESPLLFAILED);
-	}
-
-	dd->ibdeltainprog = 1;
-	dd->ibsymsnap =
-	     ipath_read_creg32(dd, dd->ipath_cregs->cr_ibsymbolerrcnt);
-	dd->iblnkerrsnap =
-	     ipath_read_creg32(dd, dd->ipath_cregs->cr_iblinkerrrecovcnt);
-
-	val = ipath_read_kreg64(dd, dd->ipath_kregs->kr_serdesconfig0);
-	config1 = ipath_read_kreg64(dd, dd->ipath_kregs->kr_serdesconfig1);
-
-	ipath_cdbg(VERBOSE, "SerDes status config0=%llx config1=%llx, "
-		   "xgxsconfig %llx\n", (unsigned long long) val,
-		   (unsigned long long) config1, (unsigned long long)
-		   ipath_read_kreg64(dd, dd->ipath_kregs->kr_xgxsconfig));
-
-	/*
-	 * Force reset on, also set rxdetect enable.  Must do before reading
-	 * serdesstatus at least for simulation, or some of the bits in
-	 * serdes status will come back as undefined and cause simulation
-	 * failures
-	 */
-	val |= INFINIPATH_SERDC0_RESET_PLL | INFINIPATH_SERDC0_RXDETECT_EN
-		| INFINIPATH_SERDC0_L1PWR_DN;
-	ipath_write_kreg(dd, dd->ipath_kregs->kr_serdesconfig0, val);
-	/* be sure chip saw it */
-	ipath_read_kreg64(dd, dd->ipath_kregs->kr_scratch);
-	udelay(5);		/* need pll reset set at least for a bit */
-	/*
-	 * after PLL is reset, set the per-lane Resets and TxIdle and
-	 * clear the PLL reset and rxdetect (to get falling edge).
-	 * Leave L1PWR bits set (permanently)
-	 */
-	val &= ~(INFINIPATH_SERDC0_RXDETECT_EN | INFINIPATH_SERDC0_RESET_PLL
-		 | INFINIPATH_SERDC0_L1PWR_DN);
-	val |= INFINIPATH_SERDC0_RESET_MASK | INFINIPATH_SERDC0_TXIDLE;
-	ipath_cdbg(VERBOSE, "Clearing pll reset and setting lane resets "
-		   "and txidle (%llx)\n", (unsigned long long) val);
-	ipath_write_kreg(dd, dd->ipath_kregs->kr_serdesconfig0, val);
-	/* be sure chip saw it */
-	ipath_read_kreg64(dd, dd->ipath_kregs->kr_scratch);
-	/* need PLL reset clear for at least 11 usec before lane
-	 * resets cleared; give it a few more to be sure */
-	udelay(15);
-	val &= ~(INFINIPATH_SERDC0_RESET_MASK | INFINIPATH_SERDC0_TXIDLE);
-
-	ipath_cdbg(VERBOSE, "Clearing lane resets and txidle "
-		   "(writing %llx)\n", (unsigned long long) val);
-	ipath_write_kreg(dd, dd->ipath_kregs->kr_serdesconfig0, val);
-	/* be sure chip saw it */
-	val = ipath_read_kreg64(dd, dd->ipath_kregs->kr_scratch);
-
-	val = ipath_read_kreg64(dd, dd->ipath_kregs->kr_xgxsconfig);
-	prev_val = val;
-	if (val & INFINIPATH_XGXS_RESET)
-		val &= ~INFINIPATH_XGXS_RESET;
-	if (((val >> INFINIPATH_XGXS_RX_POL_SHIFT) &
-	     INFINIPATH_XGXS_RX_POL_MASK) != dd->ipath_rx_pol_inv ) {
-		/* need to compensate for Tx inversion in partner */
-		val &= ~(INFINIPATH_XGXS_RX_POL_MASK <<
-		         INFINIPATH_XGXS_RX_POL_SHIFT);
-		val |= dd->ipath_rx_pol_inv <<
-			INFINIPATH_XGXS_RX_POL_SHIFT;
-	}
-	if (val != prev_val)
-		ipath_write_kreg(dd, dd->ipath_kregs->kr_xgxsconfig, val);
-
-	val = ipath_read_kreg64(dd, dd->ipath_kregs->kr_serdesconfig0);
-
-	/* clear current and de-emphasis bits */
-	config1 &= ~0x0ffffffff00ULL;
-	/* set current to 20ma */
-	config1 |= 0x00000000000ULL;
-	/* set de-emphasis to -5.68dB */
-	config1 |= 0x0cccc000000ULL;
-	ipath_write_kreg(dd, dd->ipath_kregs->kr_serdesconfig1, config1);
-
-	ipath_cdbg(VERBOSE, "done: SerDes status config0=%llx "
-		   "config1=%llx, sstatus=%llx xgxs=%llx\n",
-		   (unsigned long long) val, (unsigned long long) config1,
-		   (unsigned long long)
-		   ipath_read_kreg64(dd, dd->ipath_kregs->kr_serdesstatus),
-		   (unsigned long long)
-		   ipath_read_kreg64(dd, dd->ipath_kregs->kr_xgxsconfig));
-
-	return ret;
-}
-
-/**
- * ipath_pe_quiet_serdes - set serdes to txidle
- * @dd: the infinipath device
- * Called when driver is being unloaded
- */
-static void ipath_pe_quiet_serdes(struct ipath_devdata *dd)
-{
-	u64 val = ipath_read_kreg64(dd, dd->ipath_kregs->kr_serdesconfig0);
-
-	if (dd->ibsymdelta || dd->iblnkerrdelta ||
-	    dd->ibdeltainprog) {
-		u64 diagc;
-		/* enable counter writes */
-		diagc = ipath_read_kreg64(dd, dd->ipath_kregs->kr_hwdiagctrl);
-		ipath_write_kreg(dd, dd->ipath_kregs->kr_hwdiagctrl,
-				 diagc | INFINIPATH_DC_COUNTERWREN);
-
-		if (dd->ibsymdelta || dd->ibdeltainprog) {
-			val = ipath_read_creg32(dd,
-					dd->ipath_cregs->cr_ibsymbolerrcnt);
-			if (dd->ibdeltainprog)
-				val -= val - dd->ibsymsnap;
-			val -= dd->ibsymdelta;
-			ipath_write_creg(dd,
-				  dd->ipath_cregs->cr_ibsymbolerrcnt, val);
-		}
-		if (dd->iblnkerrdelta || dd->ibdeltainprog) {
-			val = ipath_read_creg32(dd,
-					dd->ipath_cregs->cr_iblinkerrrecovcnt);
-			if (dd->ibdeltainprog)
-				val -= val - dd->iblnkerrsnap;
-			val -= dd->iblnkerrdelta;
-			ipath_write_creg(dd,
-				   dd->ipath_cregs->cr_iblinkerrrecovcnt, val);
-	     }
-
-	     /* and disable counter writes */
-	     ipath_write_kreg(dd, dd->ipath_kregs->kr_hwdiagctrl, diagc);
-	}
-	val |= INFINIPATH_SERDC0_TXIDLE;
-	ipath_dbg("Setting TxIdleEn on serdes (config0 = %llx)\n",
-		  (unsigned long long) val);
-	ipath_write_kreg(dd, dd->ipath_kregs->kr_serdesconfig0, val);
-}
-
-static int ipath_pe_intconfig(struct ipath_devdata *dd)
-{
-	u32 chiprev;
-
-	/*
-	 * If the chip supports added error indication via GPIO pins,
-	 * enable interrupts on those bits so the interrupt routine
-	 * can count the events. Also set flag so interrupt routine
-	 * can know they are expected.
-	 */
-	chiprev = dd->ipath_revision >> INFINIPATH_R_CHIPREVMINOR_SHIFT;
-	if ((chiprev & INFINIPATH_R_CHIPREVMINOR_MASK) > 1) {
-		/* Rev2+ reports extra errors via internal GPIO pins */
-		dd->ipath_flags |= IPATH_GPIO_ERRINTRS;
-		dd->ipath_gpio_mask |= IPATH_GPIO_ERRINTR_MASK;
-		ipath_write_kreg(dd, dd->ipath_kregs->kr_gpio_mask,
-				 dd->ipath_gpio_mask);
-	}
-	return 0;
-}
-
-/**
- * ipath_setup_pe_setextled - set the state of the two external LEDs
- * @dd: the infinipath device
- * @lst: the L state
- * @ltst: the LT state
-
- * These LEDs indicate the physical and logical state of IB link.
- * For this chip (at least with recommended board pinouts), LED1
- * is Yellow (logical state) and LED2 is Green (physical state),
- *
- * Note:  We try to match the Mellanox HCA LED behavior as best
- * we can.  Green indicates physical link state is OK (something is
- * plugged in, and we can train).
- * Amber indicates the link is logically up (ACTIVE).
- * Mellanox further blinks the amber LED to indicate data packet
- * activity, but we have no hardware support for that, so it would
- * require waking up every 10-20 msecs and checking the counters
- * on the chip, and then turning the LED off if appropriate.  That's
- * visible overhead, so not something we will do.
- *
- */
-static void ipath_setup_pe_setextled(struct ipath_devdata *dd, u64 lst,
-				     u64 ltst)
-{
-	u64 extctl;
-	unsigned long flags = 0;
-
-	/* the diags use the LED to indicate diag info, so we leave
-	 * the external LED alone when the diags are running */
-	if (ipath_diag_inuse)
-		return;
-
-	/* Allow override of LED display for, e.g. Locating system in rack */
-	if (dd->ipath_led_override) {
-		ltst = (dd->ipath_led_override & IPATH_LED_PHYS)
-			? INFINIPATH_IBCS_LT_STATE_LINKUP
-			: INFINIPATH_IBCS_LT_STATE_DISABLED;
-		lst = (dd->ipath_led_override & IPATH_LED_LOG)
-			? INFINIPATH_IBCS_L_STATE_ACTIVE
-			: INFINIPATH_IBCS_L_STATE_DOWN;
-	}
-
-	spin_lock_irqsave(&dd->ipath_gpio_lock, flags);
-	extctl = dd->ipath_extctrl & ~(INFINIPATH_EXTC_LED1PRIPORT_ON |
-				       INFINIPATH_EXTC_LED2PRIPORT_ON);
-
-	if (ltst == INFINIPATH_IBCS_LT_STATE_LINKUP)
-		extctl |= INFINIPATH_EXTC_LED2PRIPORT_ON;
-	if (lst == INFINIPATH_IBCS_L_STATE_ACTIVE)
-		extctl |= INFINIPATH_EXTC_LED1PRIPORT_ON;
-	dd->ipath_extctrl = extctl;
-	ipath_write_kreg(dd, dd->ipath_kregs->kr_extctrl, extctl);
-	spin_unlock_irqrestore(&dd->ipath_gpio_lock, flags);
-}
-
-/**
- * ipath_setup_pe_cleanup - clean up any per-chip chip-specific stuff
- * @dd: the infinipath device
- *
- * This is called during driver unload.
- * We do the pci_disable_msi here, not in generic code, because it
- * isn't used for the HT chips. If we do end up needing pci_enable_msi
- * at some point in the future for HT, we'll move the call back
- * into the main init_one code.
- */
-static void ipath_setup_pe_cleanup(struct ipath_devdata *dd)
-{
-	dd->ipath_msi_lo = 0;	/* just in case unload fails */
-	pci_disable_msi(dd->pcidev);
-}
-
-static void ipath_6120_pcie_params(struct ipath_devdata *dd)
-{
-	u16 linkstat, speed;
-	int pos;
-
-	pos = pci_find_capability(dd->pcidev, PCI_CAP_ID_EXP);
-	if (!pos) {
-		ipath_dev_err(dd, "Can't find PCI Express capability!\n");
-		goto bail;
-	}
-
-	pci_read_config_word(dd->pcidev, pos + PCI_EXP_LNKSTA,
-			     &linkstat);
-	/*
-	 * speed is bits 0-4, linkwidth is bits 4-8
-	 * no defines for them in headers
-	 */
-	speed = linkstat & 0xf;
-	linkstat >>= 4;
-	linkstat &= 0x1f;
-	dd->ipath_lbus_width = linkstat;
-
-	switch (speed) {
-	case 1:
-		dd->ipath_lbus_speed = 2500; /* Gen1, 2.5GHz */
-		break;
-	case 2:
-		dd->ipath_lbus_speed = 5000; /* Gen1, 5GHz */
-		break;
-	default: /* not defined, assume gen1 */
-		dd->ipath_lbus_speed = 2500;
-		break;
-	}
-
-	if (linkstat < 8)
-		ipath_dev_err(dd,
-			"PCIe width %u (x8 HCA), performance reduced\n",
-			linkstat);
-	else
-		ipath_cdbg(VERBOSE, "PCIe speed %u width %u (x8 HCA)\n",
-			dd->ipath_lbus_speed, linkstat);
-
-	if (speed != 1)
-		ipath_dev_err(dd,
-			"PCIe linkspeed %u is incorrect; "
-			"should be 1 (2500)!\n", speed);
-bail:
-	/* fill in string, even on errors */
-	snprintf(dd->ipath_lbus_info, sizeof(dd->ipath_lbus_info),
-		"PCIe,%uMHz,x%u\n",
-		dd->ipath_lbus_speed,
-		dd->ipath_lbus_width);
-
-	return;
-}
-
-/**
- * ipath_setup_pe_config - setup PCIe config related stuff
- * @dd: the infinipath device
- * @pdev: the PCI device
- *
- * The pci_enable_msi() call will fail on systems with MSI quirks
- * such as those with AMD8131, even if the device of interest is not
- * attached to that device, (in the 2.6.13 - 2.6.15 kernels, at least, fixed
- * late in 2.6.16).
- * All that can be done is to edit the kernel source to remove the quirk
- * check until that is fixed.
- * We do not need to call enable_msi() for our HyperTransport chip,
- * even though it uses MSI, and we want to avoid the quirk warning, so
- * So we call enable_msi only for PCIe.  If we do end up needing
- * pci_enable_msi at some point in the future for HT, we'll move the
- * call back into the main init_one code.
- * We save the msi lo and hi values, so we can restore them after
- * chip reset (the kernel PCI infrastructure doesn't yet handle that
- * correctly).
- */
-static int ipath_setup_pe_config(struct ipath_devdata *dd,
-				 struct pci_dev *pdev)
-{
-	int pos, ret;
-
-	dd->ipath_msi_lo = 0;	/* used as a flag during reset processing */
-	ret = pci_enable_msi(dd->pcidev);
-	if (ret)
-		ipath_dev_err(dd, "pci_enable_msi failed: %d, "
-			      "interrupts may not work\n", ret);
-	/* continue even if it fails, we may still be OK... */
-	dd->ipath_irq = pdev->irq;
-
-	if ((pos = pci_find_capability(dd->pcidev, PCI_CAP_ID_MSI))) {
-		u16 control;
-		pci_read_config_dword(dd->pcidev, pos + PCI_MSI_ADDRESS_LO,
-				      &dd->ipath_msi_lo);
-		pci_read_config_dword(dd->pcidev, pos + PCI_MSI_ADDRESS_HI,
-				      &dd->ipath_msi_hi);
-		pci_read_config_word(dd->pcidev, pos + PCI_MSI_FLAGS,
-				     &control);
-		/* now save the data (vector) info */
-		pci_read_config_word(dd->pcidev,
-				     pos + ((control & PCI_MSI_FLAGS_64BIT)
-					    ? 12 : 8),
-				     &dd->ipath_msi_data);
-		ipath_cdbg(VERBOSE, "Read msi data 0x%x from config offset "
-			   "0x%x, control=0x%x\n", dd->ipath_msi_data,
-			   pos + ((control & PCI_MSI_FLAGS_64BIT) ? 12 : 8),
-			   control);
-		/* we save the cachelinesize also, although it doesn't
-		 * really matter */
-		pci_read_config_byte(dd->pcidev, PCI_CACHE_LINE_SIZE,
-				     &dd->ipath_pci_cacheline);
-	} else
-		ipath_dev_err(dd, "Can't find MSI capability, "
-			      "can't save MSI settings for reset\n");
-
-	ipath_6120_pcie_params(dd);
-
-	dd->ipath_link_width_supported = IB_WIDTH_1X | IB_WIDTH_4X;
-	dd->ipath_link_speed_supported = IPATH_IB_SDR;
-	dd->ipath_link_width_enabled = IB_WIDTH_4X;
-	dd->ipath_link_speed_enabled = dd->ipath_link_speed_supported;
-	/* these can't change for this chip, so set once */
-	dd->ipath_link_width_active = dd->ipath_link_width_enabled;
-	dd->ipath_link_speed_active = dd->ipath_link_speed_enabled;
-	return 0;
-}
-
-static void ipath_init_pe_variables(struct ipath_devdata *dd)
-{
-	/*
-	 * setup the register offsets, since they are different for each
-	 * chip
-	 */
-	dd->ipath_kregs = &ipath_pe_kregs;
-	dd->ipath_cregs = &ipath_pe_cregs;
-
-	/*
-	 * bits for selecting i2c direction and values,
-	 * used for I2C serial flash
-	 */
-	dd->ipath_gpio_sda_num = _IPATH_GPIO_SDA_NUM;
-	dd->ipath_gpio_scl_num = _IPATH_GPIO_SCL_NUM;
-	dd->ipath_gpio_sda = IPATH_GPIO_SDA;
-	dd->ipath_gpio_scl = IPATH_GPIO_SCL;
-
-	/*
-	 * Fill in data for field-values that change in newer chips.
-	 * We dynamically specify only the mask for LINKTRAININGSTATE
-	 * and only the shift for LINKSTATE, as they are the only ones
-	 * that change.  Also precalculate the 3 link states of interest
-	 * and the combined mask.
-	 */
-	dd->ibcs_ls_shift = IBA6120_IBCS_LINKSTATE_SHIFT;
-	dd->ibcs_lts_mask = IBA6120_IBCS_LINKTRAININGSTATE_MASK;
-	dd->ibcs_mask = (INFINIPATH_IBCS_LINKSTATE_MASK <<
-		dd->ibcs_ls_shift) | dd->ibcs_lts_mask;
-	dd->ib_init = (INFINIPATH_IBCS_LT_STATE_LINKUP <<
-		INFINIPATH_IBCS_LINKTRAININGSTATE_SHIFT) |
-		(INFINIPATH_IBCS_L_STATE_INIT << dd->ibcs_ls_shift);
-	dd->ib_arm = (INFINIPATH_IBCS_LT_STATE_LINKUP <<
-		INFINIPATH_IBCS_LINKTRAININGSTATE_SHIFT) |
-		(INFINIPATH_IBCS_L_STATE_ARM << dd->ibcs_ls_shift);
-	dd->ib_active = (INFINIPATH_IBCS_LT_STATE_LINKUP <<
-		INFINIPATH_IBCS_LINKTRAININGSTATE_SHIFT) |
-		(INFINIPATH_IBCS_L_STATE_ACTIVE << dd->ibcs_ls_shift);
-
-	/*
-	 * Fill in data for ibcc field-values that change in newer chips.
-	 * We dynamically specify only the mask for LINKINITCMD
-	 * and only the shift for LINKCMD and MAXPKTLEN, as they are
-	 * the only ones that change.
-	 */
-	dd->ibcc_lic_mask = INFINIPATH_IBCC_LINKINITCMD_MASK;
-	dd->ibcc_lc_shift = INFINIPATH_IBCC_LINKCMD_SHIFT;
-	dd->ibcc_mpl_shift = INFINIPATH_IBCC_MAXPKTLEN_SHIFT;
-
-	/* Fill in shifts for RcvCtrl. */
-	dd->ipath_r_portenable_shift = INFINIPATH_R_PORTENABLE_SHIFT;
-	dd->ipath_r_intravail_shift = INFINIPATH_R_INTRAVAIL_SHIFT;
-	dd->ipath_r_tailupd_shift = INFINIPATH_R_TAILUPD_SHIFT;
-	dd->ipath_r_portcfg_shift = 0; /* Not on IBA6120 */
-
-	/* variables for sanity checking interrupt and errors */
-	dd->ipath_hwe_bitsextant =
-		(INFINIPATH_HWE_RXEMEMPARITYERR_MASK <<
-		 INFINIPATH_HWE_RXEMEMPARITYERR_SHIFT) |
-		(INFINIPATH_HWE_TXEMEMPARITYERR_MASK <<
-		 INFINIPATH_HWE_TXEMEMPARITYERR_SHIFT) |
-		(INFINIPATH_HWE_PCIEMEMPARITYERR_MASK <<
-		 INFINIPATH_HWE_PCIEMEMPARITYERR_SHIFT) |
-		INFINIPATH_HWE_PCIE1PLLFAILED |
-		INFINIPATH_HWE_PCIE0PLLFAILED |
-		INFINIPATH_HWE_PCIEPOISONEDTLP |
-		INFINIPATH_HWE_PCIECPLTIMEOUT |
-		INFINIPATH_HWE_PCIEBUSPARITYXTLH |
-		INFINIPATH_HWE_PCIEBUSPARITYXADM |
-		INFINIPATH_HWE_PCIEBUSPARITYRADM |
-		INFINIPATH_HWE_MEMBISTFAILED |
-		INFINIPATH_HWE_COREPLL_FBSLIP |
-		INFINIPATH_HWE_COREPLL_RFSLIP |
-		INFINIPATH_HWE_SERDESPLLFAILED |
-		INFINIPATH_HWE_IBCBUSTOSPCPARITYERR |
-		INFINIPATH_HWE_IBCBUSFRSPCPARITYERR;
-	dd->ipath_i_bitsextant =
-		(INFINIPATH_I_RCVURG_MASK << INFINIPATH_I_RCVURG_SHIFT) |
-		(INFINIPATH_I_RCVAVAIL_MASK <<
-		 INFINIPATH_I_RCVAVAIL_SHIFT) |
-		INFINIPATH_I_ERROR | INFINIPATH_I_SPIOSENT |
-		INFINIPATH_I_SPIOBUFAVAIL | INFINIPATH_I_GPIO;
-	dd->ipath_e_bitsextant =
-		INFINIPATH_E_RFORMATERR | INFINIPATH_E_RVCRC |
-		INFINIPATH_E_RICRC | INFINIPATH_E_RMINPKTLEN |
-		INFINIPATH_E_RMAXPKTLEN | INFINIPATH_E_RLONGPKTLEN |
-		INFINIPATH_E_RSHORTPKTLEN | INFINIPATH_E_RUNEXPCHAR |
-		INFINIPATH_E_RUNSUPVL | INFINIPATH_E_REBP |
-		INFINIPATH_E_RIBFLOW | INFINIPATH_E_RBADVERSION |
-		INFINIPATH_E_RRCVEGRFULL | INFINIPATH_E_RRCVHDRFULL |
-		INFINIPATH_E_RBADTID | INFINIPATH_E_RHDRLEN |
-		INFINIPATH_E_RHDR | INFINIPATH_E_RIBLOSTLINK |
-		INFINIPATH_E_SMINPKTLEN | INFINIPATH_E_SMAXPKTLEN |
-		INFINIPATH_E_SUNDERRUN | INFINIPATH_E_SPKTLEN |
-		INFINIPATH_E_SDROPPEDSMPPKT | INFINIPATH_E_SDROPPEDDATAPKT |
-		INFINIPATH_E_SPIOARMLAUNCH | INFINIPATH_E_SUNEXPERRPKTNUM |
-		INFINIPATH_E_SUNSUPVL | INFINIPATH_E_IBSTATUSCHANGED |
-		INFINIPATH_E_INVALIDADDR | INFINIPATH_E_RESET |
-		INFINIPATH_E_HARDWARE;
-
-	dd->ipath_i_rcvavail_mask = INFINIPATH_I_RCVAVAIL_MASK;
-	dd->ipath_i_rcvurg_mask = INFINIPATH_I_RCVURG_MASK;
-	dd->ipath_i_rcvavail_shift = INFINIPATH_I_RCVAVAIL_SHIFT;
-	dd->ipath_i_rcvurg_shift = INFINIPATH_I_RCVURG_SHIFT;
-
-	/*
-	 * EEPROM error log 0 is TXE Parity errors. 1 is RXE Parity.
-	 * 2 is Some Misc, 3 is reserved for future.
-	 */
-	dd->ipath_eep_st_masks[0].hwerrs_to_log =
-		INFINIPATH_HWE_TXEMEMPARITYERR_MASK <<
-		INFINIPATH_HWE_TXEMEMPARITYERR_SHIFT;
-
-	/* Ignore errors in PIO/PBC on systems with unordered write-combining */
-	if (ipath_unordered_wc())
-		dd->ipath_eep_st_masks[0].hwerrs_to_log &= ~TXE_PIO_PARITY;
-
-	dd->ipath_eep_st_masks[1].hwerrs_to_log =
-		INFINIPATH_HWE_RXEMEMPARITYERR_MASK <<
-		INFINIPATH_HWE_RXEMEMPARITYERR_SHIFT;
-
-	dd->ipath_eep_st_masks[2].errs_to_log = INFINIPATH_E_RESET;
-	dd->delay_mult = 2; /* SDR, 4X, can't change */
-}
-
-/* setup the MSI stuff again after a reset.  I'd like to just call
- * pci_enable_msi() and request_irq() again, but when I do that,
- * the MSI enable bit doesn't get set in the command word, and
- * we switch to to a different interrupt vector, which is confusing,
- * so I instead just do it all inline.  Perhaps somehow can tie this
- * into the PCIe hotplug support at some point
- * Note, because I'm doing it all here, I don't call pci_disable_msi()
- * or free_irq() at the start of ipath_setup_pe_reset().
- */
-static int ipath_reinit_msi(struct ipath_devdata *dd)
-{
-	int pos;
-	u16 control;
-	int ret;
-
-	if (!dd->ipath_msi_lo) {
-		dev_info(&dd->pcidev->dev, "Can't restore MSI config, "
-			 "initial setup failed?\n");
-		ret = 0;
-		goto bail;
-	}
-
-	if (!(pos = pci_find_capability(dd->pcidev, PCI_CAP_ID_MSI))) {
-		ipath_dev_err(dd, "Can't find MSI capability, "
-			      "can't restore MSI settings\n");
-		ret = 0;
-		goto bail;
-	}
-	ipath_cdbg(VERBOSE, "Writing msi_lo 0x%x to config offset 0x%x\n",
-		   dd->ipath_msi_lo, pos + PCI_MSI_ADDRESS_LO);
-	pci_write_config_dword(dd->pcidev, pos + PCI_MSI_ADDRESS_LO,
-			       dd->ipath_msi_lo);
-	ipath_cdbg(VERBOSE, "Writing msi_lo 0x%x to config offset 0x%x\n",
-		   dd->ipath_msi_hi, pos + PCI_MSI_ADDRESS_HI);
-	pci_write_config_dword(dd->pcidev, pos + PCI_MSI_ADDRESS_HI,
-			       dd->ipath_msi_hi);
-	pci_read_config_word(dd->pcidev, pos + PCI_MSI_FLAGS, &control);
-	if (!(control & PCI_MSI_FLAGS_ENABLE)) {
-		ipath_cdbg(VERBOSE, "MSI control at off %x was %x, "
-			   "setting MSI enable (%x)\n", pos + PCI_MSI_FLAGS,
-			   control, control | PCI_MSI_FLAGS_ENABLE);
-		control |= PCI_MSI_FLAGS_ENABLE;
-		pci_write_config_word(dd->pcidev, pos + PCI_MSI_FLAGS,
-				      control);
-	}
-	/* now rewrite the data (vector) info */
-	pci_write_config_word(dd->pcidev, pos +
-			      ((control & PCI_MSI_FLAGS_64BIT) ? 12 : 8),
-			      dd->ipath_msi_data);
-	/* we restore the cachelinesize also, although it doesn't really
-	 * matter */
-	pci_write_config_byte(dd->pcidev, PCI_CACHE_LINE_SIZE,
-			      dd->ipath_pci_cacheline);
-	/* and now set the pci master bit again */
-	pci_set_master(dd->pcidev);
-	ret = 1;
-
-bail:
-	return ret;
-}
-
-/* This routine sleeps, so it can only be called from user context, not
- * from interrupt context.  If we need interrupt context, we can split
- * it into two routines.
-*/
-static int ipath_setup_pe_reset(struct ipath_devdata *dd)
-{
-	u64 val;
-	int i;
-	int ret;
-	u16 cmdval;
-
-	pci_read_config_word(dd->pcidev, PCI_COMMAND, &cmdval);
-
-	/* Use ERROR so it shows up in logs, etc. */
-	ipath_dev_err(dd, "Resetting InfiniPath unit %u\n", dd->ipath_unit);
-	/* keep chip from being accessed in a few places */
-	dd->ipath_flags &= ~(IPATH_INITTED|IPATH_PRESENT);
-	val = dd->ipath_control | INFINIPATH_C_RESET;
-	ipath_write_kreg(dd, dd->ipath_kregs->kr_control, val);
-	mb();
-
-	for (i = 1; i <= 5; i++) {
-		int r;
-		/* allow MBIST, etc. to complete; longer on each retry.
-		 * We sometimes get machine checks from bus timeout if no
-		 * response, so for now, make it *really* long.
-		 */
-		msleep(1000 + (1 + i) * 2000);
-		if ((r =
-		     pci_write_config_dword(dd->pcidev, PCI_BASE_ADDRESS_0,
-					    dd->ipath_pcibar0)))
-			ipath_dev_err(dd, "rewrite of BAR0 failed: %d\n",
-				      r);
-		if ((r =
-		     pci_write_config_dword(dd->pcidev, PCI_BASE_ADDRESS_1,
-					    dd->ipath_pcibar1)))
-			ipath_dev_err(dd, "rewrite of BAR1 failed: %d\n",
-				      r);
-		/* now re-enable memory access */
-		pci_write_config_word(dd->pcidev, PCI_COMMAND, cmdval);
-		if ((r = pci_enable_device(dd->pcidev)))
-			ipath_dev_err(dd, "pci_enable_device failed after "
-				      "reset: %d\n", r);
-		/*
-		 * whether it fully enabled or not, mark as present,
-		 * again (but not INITTED)
-		 */
-		dd->ipath_flags |= IPATH_PRESENT;
-		val = ipath_read_kreg64(dd, dd->ipath_kregs->kr_revision);
-		if (val == dd->ipath_revision) {
-			ipath_cdbg(VERBOSE, "Got matching revision "
-				   "register %llx on try %d\n",
-				   (unsigned long long) val, i);
-			ret = ipath_reinit_msi(dd);
-			goto bail;
-		}
-		/* Probably getting -1 back */
-		ipath_dbg("Didn't get expected revision register, "
-			  "got %llx, try %d\n", (unsigned long long) val,
-			  i + 1);
-	}
-	ret = 0; /* failed */
-
-bail:
-	if (ret)
-		ipath_6120_pcie_params(dd);
-	return ret;
-}
-
-/**
- * ipath_pe_put_tid - write a TID in chip
- * @dd: the infinipath device
- * @tidptr: pointer to the expected TID (in chip) to udpate
- * @tidtype: RCVHQ_RCV_TYPE_EAGER (1) for eager, RCVHQ_RCV_TYPE_EXPECTED (0) for expected
- * @pa: physical address of in memory buffer; ipath_tidinvalid if freeing
- *
- * This exists as a separate routine to allow for special locking etc.
- * It's used for both the full cleanup on exit, as well as the normal
- * setup and teardown.
- */
-static void ipath_pe_put_tid(struct ipath_devdata *dd, u64 __iomem *tidptr,
-			     u32 type, unsigned long pa)
-{
-	u32 __iomem *tidp32 = (u32 __iomem *)tidptr;
-	unsigned long flags = 0; /* keep gcc quiet */
-	int tidx;
-	spinlock_t *tidlockp;
-
-	if (!dd->ipath_kregbase)
-		return;
-
-	if (pa != dd->ipath_tidinvalid) {
-		if (pa & ((1U << 11) - 1)) {
-			dev_info(&dd->pcidev->dev, "BUG: physaddr %lx "
-				 "not 2KB aligned!\n", pa);
-			return;
-		}
-		pa >>= 11;
-		/* paranoia check */
-		if (pa & ~INFINIPATH_RT_ADDR_MASK)
-			ipath_dev_err(dd,
-				      "BUG: Physical page address 0x%lx "
-				      "has bits set in 31-29\n", pa);
-
-		if (type == RCVHQ_RCV_TYPE_EAGER)
-			pa |= dd->ipath_tidtemplate;
-		else /* for now, always full 4KB page */
-			pa |= 2 << 29;
-	}
-
-	/*
-	 * Workaround chip bug 9437 by writing the scratch register
-	 * before and after the TID, and with an io write barrier.
-	 * We use a spinlock around the writes, so they can't intermix
-	 * with other TID (eager or expected) writes (the chip bug
-	 * is triggered by back to back TID writes). Unfortunately, this
-	 * call can be done from interrupt level for the port 0 eager TIDs,
-	 * so we have to use irqsave locks.
-	 */
-	/*
-	 * Assumes tidptr always > ipath_egrtidbase
-	 * if type == RCVHQ_RCV_TYPE_EAGER.
-	 */
-	tidx = tidptr - dd->ipath_egrtidbase;
-
-	tidlockp = (type == RCVHQ_RCV_TYPE_EAGER && tidx < dd->ipath_rcvegrcnt)
-		? &dd->ipath_kernel_tid_lock : &dd->ipath_user_tid_lock;
-	spin_lock_irqsave(tidlockp, flags);
-	ipath_write_kreg(dd, dd->ipath_kregs->kr_scratch, 0xfeeddeaf);
-	writel(pa, tidp32);
-	ipath_write_kreg(dd, dd->ipath_kregs->kr_scratch, 0xdeadbeef);
-	mmiowb();
-	spin_unlock_irqrestore(tidlockp, flags);
-}
-
-/**
- * ipath_pe_put_tid_2 - write a TID in chip, Revision 2 or higher
- * @dd: the infinipath device
- * @tidptr: pointer to the expected TID (in chip) to udpate
- * @tidtype: RCVHQ_RCV_TYPE_EAGER (1) for eager, RCVHQ_RCV_TYPE_EXPECTED (0) for expected
- * @pa: physical address of in memory buffer; ipath_tidinvalid if freeing
- *
- * This exists as a separate routine to allow for selection of the
- * appropriate "flavor". The static calls in cleanup just use the
- * revision-agnostic form, as they are not performance critical.
- */
-static void ipath_pe_put_tid_2(struct ipath_devdata *dd, u64 __iomem *tidptr,
-			     u32 type, unsigned long pa)
-{
-	u32 __iomem *tidp32 = (u32 __iomem *)tidptr;
-	u32 tidx;
-
-	if (!dd->ipath_kregbase)
-		return;
-
-	if (pa != dd->ipath_tidinvalid) {
-		if (pa & ((1U << 11) - 1)) {
-			dev_info(&dd->pcidev->dev, "BUG: physaddr %lx "
-				 "not 2KB aligned!\n", pa);
-			return;
-		}
-		pa >>= 11;
-		/* paranoia check */
-		if (pa & ~INFINIPATH_RT_ADDR_MASK)
-			ipath_dev_err(dd,
-				      "BUG: Physical page address 0x%lx "
-				      "has bits set in 31-29\n", pa);
-
-		if (type == RCVHQ_RCV_TYPE_EAGER)
-			pa |= dd->ipath_tidtemplate;
-		else /* for now, always full 4KB page */
-			pa |= 2 << 29;
-	}
-	tidx = tidptr - dd->ipath_egrtidbase;
-	writel(pa, tidp32);
-	mmiowb();
-}
-
-
-/**
- * ipath_pe_clear_tid - clear all TID entries for a port, expected and eager
- * @dd: the infinipath device
- * @port: the port
- *
- * clear all TID entries for a port, expected and eager.
- * Used from ipath_close().  On this chip, TIDs are only 32 bits,
- * not 64, but they are still on 64 bit boundaries, so tidbase
- * is declared as u64 * for the pointer math, even though we write 32 bits
- */
-static void ipath_pe_clear_tids(struct ipath_devdata *dd, unsigned port)
-{
-	u64 __iomem *tidbase;
-	unsigned long tidinv;
-	int i;
-
-	if (!dd->ipath_kregbase)
-		return;
-
-	ipath_cdbg(VERBOSE, "Invalidate TIDs for port %u\n", port);
-
-	tidinv = dd->ipath_tidinvalid;
-	tidbase = (u64 __iomem *)
-		((char __iomem *)(dd->ipath_kregbase) +
-		 dd->ipath_rcvtidbase +
-		 port * dd->ipath_rcvtidcnt * sizeof(*tidbase));
-
-	for (i = 0; i < dd->ipath_rcvtidcnt; i++)
-		dd->ipath_f_put_tid(dd, &tidbase[i], RCVHQ_RCV_TYPE_EXPECTED,
-				 tidinv);
-
-	tidbase = (u64 __iomem *)
-		((char __iomem *)(dd->ipath_kregbase) +
-		 dd->ipath_rcvegrbase +
-		 port * dd->ipath_rcvegrcnt * sizeof(*tidbase));
-
-	for (i = 0; i < dd->ipath_rcvegrcnt; i++)
-		dd->ipath_f_put_tid(dd, &tidbase[i], RCVHQ_RCV_TYPE_EAGER,
-				 tidinv);
-}
-
-/**
- * ipath_pe_tidtemplate - setup constants for TID updates
- * @dd: the infinipath device
- *
- * We setup stuff that we use a lot, to avoid calculating each time
- */
-static void ipath_pe_tidtemplate(struct ipath_devdata *dd)
-{
-	u32 egrsize = dd->ipath_rcvegrbufsize;
-
-	/* For now, we always allocate 4KB buffers (at init) so we can
-	 * receive max size packets.  We may want a module parameter to
-	 * specify 2KB or 4KB and/or make be per port instead of per device
-	 * for those who want to reduce memory footprint.  Note that the
-	 * ipath_rcvhdrentsize size must be large enough to hold the largest
-	 * IB header (currently 96 bytes) that we expect to handle (plus of
-	 * course the 2 dwords of RHF).
-	 */
-	if (egrsize == 2048)
-		dd->ipath_tidtemplate = 1U << 29;
-	else if (egrsize == 4096)
-		dd->ipath_tidtemplate = 2U << 29;
-	else {
-		egrsize = 4096;
-		dev_info(&dd->pcidev->dev, "BUG: unsupported egrbufsize "
-			 "%u, using %u\n", dd->ipath_rcvegrbufsize,
-			 egrsize);
-		dd->ipath_tidtemplate = 2U << 29;
-	}
-	dd->ipath_tidinvalid = 0;
-}
-
-static int ipath_pe_early_init(struct ipath_devdata *dd)
-{
-	dd->ipath_flags |= IPATH_4BYTE_TID;
-	if (ipath_unordered_wc())
-		dd->ipath_flags |= IPATH_PIO_FLUSH_WC;
-
-	/*
-	 * For openfabrics, we need to be able to handle an IB header of
-	 * 24 dwords.  HT chip has arbitrary sized receive buffers, so we
-	 * made them the same size as the PIO buffers.  This chip does not
-	 * handle arbitrary size buffers, so we need the header large enough
-	 * to handle largest IB header, but still have room for a 2KB MTU
-	 * standard IB packet.
-	 */
-	dd->ipath_rcvhdrentsize = 24;
-	dd->ipath_rcvhdrsize = IPATH_DFLT_RCVHDRSIZE;
-	dd->ipath_rhf_offset = 0;
-	dd->ipath_egrtidbase = (u64 __iomem *)
-		((char __iomem *) dd->ipath_kregbase + dd->ipath_rcvegrbase);
-
-	dd->ipath_rcvegrbufsize = ipath_mtu4096 ? 4096 : 2048;
-	/*
-	 * the min() check here is currently a nop, but it may not always
-	 * be, depending on just how we do ipath_rcvegrbufsize
-	 */
-	dd->ipath_ibmaxlen = min(ipath_mtu4096 ? dd->ipath_piosize4k :
-				 dd->ipath_piosize2k,
-				 dd->ipath_rcvegrbufsize +
-				 (dd->ipath_rcvhdrentsize << 2));
-	dd->ipath_init_ibmaxlen = dd->ipath_ibmaxlen;
-
-	/*
-	 * We can request a receive interrupt for 1 or
-	 * more packets from current offset.  For now, we set this
-	 * up for a single packet.
-	 */
-	dd->ipath_rhdrhead_intr_off = 1ULL<<32;
-
-	ipath_get_eeprom_info(dd);
-
-	return 0;
-}
-
-int __attribute__((weak)) ipath_unordered_wc(void)
-{
-	return 0;
-}
-
-/**
- * ipath_init_pe_get_base_info - set chip-specific flags for user code
- * @pd: the infinipath port
- * @kbase: ipath_base_info pointer
- *
- * We set the PCIE flag because the lower bandwidth on PCIe vs
- * HyperTransport can affect some user packet algorithms.
- */
-static int ipath_pe_get_base_info(struct ipath_portdata *pd, void *kbase)
-{
-	struct ipath_base_info *kinfo = kbase;
-	struct ipath_devdata *dd;
-
-	if (ipath_unordered_wc()) {
-		kinfo->spi_runtime_flags |= IPATH_RUNTIME_FORCE_WC_ORDER;
-		ipath_cdbg(PROC, "Intel processor, forcing WC order\n");
-	}
-	else
-		ipath_cdbg(PROC, "Not Intel processor, WC ordered\n");
-
-	if (pd == NULL)
-		goto done;
-
-	dd = pd->port_dd;
-
-done:
-	kinfo->spi_runtime_flags |= IPATH_RUNTIME_PCIE |
-		IPATH_RUNTIME_FORCE_PIOAVAIL | IPATH_RUNTIME_PIO_REGSWAPPED;
-	return 0;
-}
-
-static void ipath_pe_free_irq(struct ipath_devdata *dd)
-{
-	free_irq(dd->ipath_irq, dd);
-	dd->ipath_irq = 0;
-}
-
-
-static struct ipath_message_header *
-ipath_pe_get_msgheader(struct ipath_devdata *dd, __le32 *rhf_addr)
-{
-	return (struct ipath_message_header *)
-		&rhf_addr[sizeof(u64) / sizeof(u32)];
-}
-
-static void ipath_pe_config_ports(struct ipath_devdata *dd, ushort cfgports)
-{
-	dd->ipath_portcnt =
-		ipath_read_kreg32(dd, dd->ipath_kregs->kr_portcnt);
-	dd->ipath_p0_rcvegrcnt =
-		ipath_read_kreg32(dd, dd->ipath_kregs->kr_rcvegrcnt);
-}
-
-static void ipath_pe_read_counters(struct ipath_devdata *dd,
-				   struct infinipath_counters *cntrs)
-{
-	cntrs->LBIntCnt =
-		ipath_snap_cntr(dd, IPATH_CREG_OFFSET(LBIntCnt));
-	cntrs->LBFlowStallCnt =
-		ipath_snap_cntr(dd, IPATH_CREG_OFFSET(LBFlowStallCnt));
-	cntrs->TxSDmaDescCnt = 0;
-	cntrs->TxUnsupVLErrCnt =
-		ipath_snap_cntr(dd, IPATH_CREG_OFFSET(TxUnsupVLErrCnt));
-	cntrs->TxDataPktCnt =
-		ipath_snap_cntr(dd, IPATH_CREG_OFFSET(TxDataPktCnt));
-	cntrs->TxFlowPktCnt =
-		ipath_snap_cntr(dd, IPATH_CREG_OFFSET(TxFlowPktCnt));
-	cntrs->TxDwordCnt =
-		ipath_snap_cntr(dd, IPATH_CREG_OFFSET(TxDwordCnt));
-	cntrs->TxLenErrCnt =
-		ipath_snap_cntr(dd, IPATH_CREG_OFFSET(TxLenErrCnt));
-	cntrs->TxMaxMinLenErrCnt =
-		ipath_snap_cntr(dd, IPATH_CREG_OFFSET(TxMaxMinLenErrCnt));
-	cntrs->TxUnderrunCnt =
-		ipath_snap_cntr(dd, IPATH_CREG_OFFSET(TxUnderrunCnt));
-	cntrs->TxFlowStallCnt =
-		ipath_snap_cntr(dd, IPATH_CREG_OFFSET(TxFlowStallCnt));
-	cntrs->TxDroppedPktCnt =
-		ipath_snap_cntr(dd, IPATH_CREG_OFFSET(TxDroppedPktCnt));
-	cntrs->RxDroppedPktCnt =
-		ipath_snap_cntr(dd, IPATH_CREG_OFFSET(RxDroppedPktCnt));
-	cntrs->RxDataPktCnt =
-		ipath_snap_cntr(dd, IPATH_CREG_OFFSET(RxDataPktCnt));
-	cntrs->RxFlowPktCnt =
-		ipath_snap_cntr(dd, IPATH_CREG_OFFSET(RxFlowPktCnt));
-	cntrs->RxDwordCnt =
-		ipath_snap_cntr(dd, IPATH_CREG_OFFSET(RxDwordCnt));
-	cntrs->RxLenErrCnt =
-		ipath_snap_cntr(dd, IPATH_CREG_OFFSET(RxLenErrCnt));
-	cntrs->RxMaxMinLenErrCnt =
-		ipath_snap_cntr(dd, IPATH_CREG_OFFSET(RxMaxMinLenErrCnt));
-	cntrs->RxICRCErrCnt =
-		ipath_snap_cntr(dd, IPATH_CREG_OFFSET(RxICRCErrCnt));
-	cntrs->RxVCRCErrCnt =
-		ipath_snap_cntr(dd, IPATH_CREG_OFFSET(RxVCRCErrCnt));
-	cntrs->RxFlowCtrlErrCnt =
-		ipath_snap_cntr(dd, IPATH_CREG_OFFSET(RxFlowCtrlErrCnt));
-	cntrs->RxBadFormatCnt =
-		ipath_snap_cntr(dd, IPATH_CREG_OFFSET(RxBadFormatCnt));
-	cntrs->RxLinkProblemCnt =
-		ipath_snap_cntr(dd, IPATH_CREG_OFFSET(RxLinkProblemCnt));
-	cntrs->RxEBPCnt =
-		ipath_snap_cntr(dd, IPATH_CREG_OFFSET(RxEBPCnt));
-	cntrs->RxLPCRCErrCnt =
-		ipath_snap_cntr(dd, IPATH_CREG_OFFSET(RxLPCRCErrCnt));
-	cntrs->RxBufOvflCnt =
-		ipath_snap_cntr(dd, IPATH_CREG_OFFSET(RxBufOvflCnt));
-	cntrs->RxTIDFullErrCnt =
-		ipath_snap_cntr(dd, IPATH_CREG_OFFSET(RxTIDFullErrCnt));
-	cntrs->RxTIDValidErrCnt =
-		ipath_snap_cntr(dd, IPATH_CREG_OFFSET(RxTIDValidErrCnt));
-	cntrs->RxPKeyMismatchCnt =
-		ipath_snap_cntr(dd, IPATH_CREG_OFFSET(RxPKeyMismatchCnt));
-	cntrs->RxP0HdrEgrOvflCnt =
-		ipath_snap_cntr(dd, IPATH_CREG_OFFSET(RxP0HdrEgrOvflCnt));
-	cntrs->RxP1HdrEgrOvflCnt =
-		ipath_snap_cntr(dd, IPATH_CREG_OFFSET(RxP1HdrEgrOvflCnt));
-	cntrs->RxP2HdrEgrOvflCnt =
-		ipath_snap_cntr(dd, IPATH_CREG_OFFSET(RxP2HdrEgrOvflCnt));
-	cntrs->RxP3HdrEgrOvflCnt =
-		ipath_snap_cntr(dd, IPATH_CREG_OFFSET(RxP3HdrEgrOvflCnt));
-	cntrs->RxP4HdrEgrOvflCnt =
-		ipath_snap_cntr(dd, IPATH_CREG_OFFSET(RxP4HdrEgrOvflCnt));
-	cntrs->RxP5HdrEgrOvflCnt = 0;
-	cntrs->RxP6HdrEgrOvflCnt = 0;
-	cntrs->RxP7HdrEgrOvflCnt = 0;
-	cntrs->RxP8HdrEgrOvflCnt = 0;
-	cntrs->RxP9HdrEgrOvflCnt = 0;
-	cntrs->RxP10HdrEgrOvflCnt = 0;
-	cntrs->RxP11HdrEgrOvflCnt = 0;
-	cntrs->RxP12HdrEgrOvflCnt = 0;
-	cntrs->RxP13HdrEgrOvflCnt = 0;
-	cntrs->RxP14HdrEgrOvflCnt = 0;
-	cntrs->RxP15HdrEgrOvflCnt = 0;
-	cntrs->RxP16HdrEgrOvflCnt = 0;
-	cntrs->IBStatusChangeCnt =
-		ipath_snap_cntr(dd, IPATH_CREG_OFFSET(IBStatusChangeCnt));
-	cntrs->IBLinkErrRecoveryCnt =
-		ipath_snap_cntr(dd, IPATH_CREG_OFFSET(IBLinkErrRecoveryCnt));
-	cntrs->IBLinkDownedCnt =
-		ipath_snap_cntr(dd, IPATH_CREG_OFFSET(IBLinkDownedCnt));
-	cntrs->IBSymbolErrCnt =
-		ipath_snap_cntr(dd, IPATH_CREG_OFFSET(IBSymbolErrCnt));
-	cntrs->RxVL15DroppedPktCnt = 0;
-	cntrs->RxOtherLocalPhyErrCnt = 0;
-	cntrs->PcieRetryBufDiagQwordCnt = 0;
-	cntrs->ExcessBufferOvflCnt = dd->ipath_overrun_thresh_errs;
-	cntrs->LocalLinkIntegrityErrCnt = dd->ipath_lli_errs;
-	cntrs->RxVlErrCnt = 0;
-	cntrs->RxDlidFltrCnt = 0;
-}
-
-
-/* no interrupt fallback for these chips */
-static int ipath_pe_nointr_fallback(struct ipath_devdata *dd)
-{
-	return 0;
-}
-
-
-/*
- * reset the XGXS (between serdes and IBC).  Slightly less intrusive
- * than resetting the IBC or external link state, and useful in some
- * cases to cause some retraining.  To do this right, we reset IBC
- * as well.
- */
-static void ipath_pe_xgxs_reset(struct ipath_devdata *dd)
-{
-	u64 val, prev_val;
-
-	prev_val = ipath_read_kreg64(dd, dd->ipath_kregs->kr_xgxsconfig);
-	val = prev_val | INFINIPATH_XGXS_RESET;
-	prev_val &= ~INFINIPATH_XGXS_RESET; /* be sure */
-	ipath_write_kreg(dd, dd->ipath_kregs->kr_control,
-			 dd->ipath_control & ~INFINIPATH_C_LINKENABLE);
-	ipath_write_kreg(dd, dd->ipath_kregs->kr_xgxsconfig, val);
-	ipath_read_kreg32(dd, dd->ipath_kregs->kr_scratch);
-	ipath_write_kreg(dd, dd->ipath_kregs->kr_xgxsconfig, prev_val);
-	ipath_write_kreg(dd, dd->ipath_kregs->kr_control,
-			 dd->ipath_control);
-}
-
-
-static int ipath_pe_get_ib_cfg(struct ipath_devdata *dd, int which)
-{
-	int ret;
-
-	switch (which) {
-	case IPATH_IB_CFG_LWID:
-		ret = dd->ipath_link_width_active;
-		break;
-	case IPATH_IB_CFG_SPD:
-		ret = dd->ipath_link_speed_active;
-		break;
-	case IPATH_IB_CFG_LWID_ENB:
-		ret = dd->ipath_link_width_enabled;
-		break;
-	case IPATH_IB_CFG_SPD_ENB:
-		ret = dd->ipath_link_speed_enabled;
-		break;
-	default:
-		ret =  -ENOTSUPP;
-		break;
-	}
-	return ret;
-}
-
-
-/* we assume range checking is already done, if needed */
-static int ipath_pe_set_ib_cfg(struct ipath_devdata *dd, int which, u32 val)
-{
-	int ret = 0;
-
-	if (which == IPATH_IB_CFG_LWID_ENB)
-		dd->ipath_link_width_enabled = val;
-	else if (which == IPATH_IB_CFG_SPD_ENB)
-		dd->ipath_link_speed_enabled = val;
-	else
-		ret = -ENOTSUPP;
-	return ret;
-}
-
-static void ipath_pe_config_jint(struct ipath_devdata *dd, u16 a, u16 b)
-{
-}
-
-
-static int ipath_pe_ib_updown(struct ipath_devdata *dd, int ibup, u64 ibcs)
-{
-	if (ibup) {
-		if (dd->ibdeltainprog) {
-			dd->ibdeltainprog = 0;
-			dd->ibsymdelta +=
-				ipath_read_creg32(dd,
-				  dd->ipath_cregs->cr_ibsymbolerrcnt) -
-				dd->ibsymsnap;
-			dd->iblnkerrdelta +=
-				ipath_read_creg32(dd,
-				  dd->ipath_cregs->cr_iblinkerrrecovcnt) -
-				dd->iblnkerrsnap;
-		}
-	} else {
-		dd->ipath_lli_counter = 0;
-		if (!dd->ibdeltainprog) {
-			dd->ibdeltainprog = 1;
-			dd->ibsymsnap =
-				ipath_read_creg32(dd,
-				  dd->ipath_cregs->cr_ibsymbolerrcnt);
-			dd->iblnkerrsnap =
-				ipath_read_creg32(dd,
-				  dd->ipath_cregs->cr_iblinkerrrecovcnt);
-		}
-	}
-
-	ipath_setup_pe_setextled(dd, ipath_ib_linkstate(dd, ibcs),
-		ipath_ib_linktrstate(dd, ibcs));
-	return 0;
-}
-
-
-/**
- * ipath_init_iba6120_funcs - set up the chip-specific function pointers
- * @dd: the infinipath device
- *
- * This is global, and is called directly at init to set up the
- * chip-specific function pointers for later use.
- */
-void ipath_init_iba6120_funcs(struct ipath_devdata *dd)
-{
-	dd->ipath_f_intrsetup = ipath_pe_intconfig;
-	dd->ipath_f_bus = ipath_setup_pe_config;
-	dd->ipath_f_reset = ipath_setup_pe_reset;
-	dd->ipath_f_get_boardname = ipath_pe_boardname;
-	dd->ipath_f_init_hwerrors = ipath_pe_init_hwerrors;
-	dd->ipath_f_early_init = ipath_pe_early_init;
-	dd->ipath_f_handle_hwerrors = ipath_pe_handle_hwerrors;
-	dd->ipath_f_quiet_serdes = ipath_pe_quiet_serdes;
-	dd->ipath_f_bringup_serdes = ipath_pe_bringup_serdes;
-	dd->ipath_f_clear_tids = ipath_pe_clear_tids;
-	/*
-	 * _f_put_tid may get changed after we read the chip revision,
-	 * but we start with the safe version for all revs
-	 */
-	dd->ipath_f_put_tid = ipath_pe_put_tid;
-	dd->ipath_f_cleanup = ipath_setup_pe_cleanup;
-	dd->ipath_f_setextled = ipath_setup_pe_setextled;
-	dd->ipath_f_get_base_info = ipath_pe_get_base_info;
-	dd->ipath_f_free_irq = ipath_pe_free_irq;
-	dd->ipath_f_tidtemplate = ipath_pe_tidtemplate;
-	dd->ipath_f_intr_fallback = ipath_pe_nointr_fallback;
-	dd->ipath_f_xgxs_reset = ipath_pe_xgxs_reset;
-	dd->ipath_f_get_msgheader = ipath_pe_get_msgheader;
-	dd->ipath_f_config_ports = ipath_pe_config_ports;
-	dd->ipath_f_read_counters = ipath_pe_read_counters;
-	dd->ipath_f_get_ib_cfg = ipath_pe_get_ib_cfg;
-	dd->ipath_f_set_ib_cfg = ipath_pe_set_ib_cfg;
-	dd->ipath_f_config_jint = ipath_pe_config_jint;
-	dd->ipath_f_ib_updown = ipath_pe_ib_updown;
-
-
-	/* initialize chip-specific variables */
-	ipath_init_pe_variables(dd);
-}
-
diff --git a/drivers/infiniband/hw/ipath/ipath_iba7220.c b/drivers/infiniband/hw/ipath/ipath_iba7220.c
deleted file mode 100644
index b2a9d4c..0000000
--- a/drivers/infiniband/hw/ipath/ipath_iba7220.c
+++ /dev/null
@@ -1,2630 +0,0 @@
-/*
- * Copyright (c) 2006, 2007, 2008 QLogic Corporation. All rights reserved.
- * Copyright (c) 2003, 2004, 2005, 2006 PathScale, Inc. All rights reserved.
- *
- * This software is available to you under a choice of one of two
- * licenses.  You may choose to be licensed under the terms of the GNU
- * General Public License (GPL) Version 2, available from the file
- * COPYING in the main directory of this source tree, or the
- * OpenIB.org BSD license below:
- *
- *     Redistribution and use in source and binary forms, with or
- *     without modification, are permitted provided that the following
- *     conditions are met:
- *
- *      - Redistributions of source code must retain the above
- *        copyright notice, this list of conditions and the following
- *        disclaimer.
- *
- *      - Redistributions in binary form must reproduce the above
- *        copyright notice, this list of conditions and the following
- *        disclaimer in the documentation and/or other materials
- *        provided with the distribution.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
- * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
- * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
- * SOFTWARE.
- */
-/*
- * This file contains all of the code that is specific to the
- * InfiniPath 7220 chip (except that specific to the SerDes)
- */
-
-#include <linux/interrupt.h>
-#include <linux/pci.h>
-#include <linux/delay.h>
-#include <linux/io.h>
-#include <rdma/ib_verbs.h>
-
-#include "ipath_kernel.h"
-#include "ipath_registers.h"
-#include "ipath_7220.h"
-
-static void ipath_setup_7220_setextled(struct ipath_devdata *, u64, u64);
-
-static unsigned ipath_compat_ddr_negotiate = 1;
-
-module_param_named(compat_ddr_negotiate, ipath_compat_ddr_negotiate, uint,
-			S_IWUSR | S_IRUGO);
-MODULE_PARM_DESC(compat_ddr_negotiate,
-		"Attempt pre-IBTA 1.2 DDR speed negotiation");
-
-static unsigned ipath_sdma_fetch_arb = 1;
-module_param_named(fetch_arb, ipath_sdma_fetch_arb, uint, S_IRUGO);
-MODULE_PARM_DESC(fetch_arb, "IBA7220: change SDMA descriptor arbitration");
-
-/*
- * This file contains almost all the chip-specific register information and
- * access functions for the QLogic InfiniPath 7220 PCI-Express chip, with the
- * exception of SerDes support, which in in ipath_sd7220.c.
- *
- * This lists the InfiniPath registers, in the actual chip layout.
- * This structure should never be directly accessed.
- */
-struct _infinipath_do_not_use_kernel_regs {
-	unsigned long long Revision;
-	unsigned long long Control;
-	unsigned long long PageAlign;
-	unsigned long long PortCnt;
-	unsigned long long DebugPortSelect;
-	unsigned long long DebugSigsIntSel; /* was Reserved0;*/
-	unsigned long long SendRegBase;
-	unsigned long long UserRegBase;
-	unsigned long long CounterRegBase;
-	unsigned long long Scratch;
-	unsigned long long EEPROMAddrCmd; /* was Reserved1; */
-	unsigned long long EEPROMData; /* was Reserved2; */
-	unsigned long long IntBlocked;
-	unsigned long long IntMask;
-	unsigned long long IntStatus;
-	unsigned long long IntClear;
-	unsigned long long ErrorMask;
-	unsigned long long ErrorStatus;
-	unsigned long long ErrorClear;
-	unsigned long long HwErrMask;
-	unsigned long long HwErrStatus;
-	unsigned long long HwErrClear;
-	unsigned long long HwDiagCtrl;
-	unsigned long long MDIO;
-	unsigned long long IBCStatus;
-	unsigned long long IBCCtrl;
-	unsigned long long ExtStatus;
-	unsigned long long ExtCtrl;
-	unsigned long long GPIOOut;
-	unsigned long long GPIOMask;
-	unsigned long long GPIOStatus;
-	unsigned long long GPIOClear;
-	unsigned long long RcvCtrl;
-	unsigned long long RcvBTHQP;
-	unsigned long long RcvHdrSize;
-	unsigned long long RcvHdrCnt;
-	unsigned long long RcvHdrEntSize;
-	unsigned long long RcvTIDBase;
-	unsigned long long RcvTIDCnt;
-	unsigned long long RcvEgrBase;
-	unsigned long long RcvEgrCnt;
-	unsigned long long RcvBufBase;
-	unsigned long long RcvBufSize;
-	unsigned long long RxIntMemBase;
-	unsigned long long RxIntMemSize;
-	unsigned long long RcvPartitionKey;
-	unsigned long long RcvQPMulticastPort;
-	unsigned long long RcvPktLEDCnt;
-	unsigned long long IBCDDRCtrl;
-	unsigned long long HRTBT_GUID;
-	unsigned long long IB_SDTEST_IF_TX;
-	unsigned long long IB_SDTEST_IF_RX;
-	unsigned long long IBCDDRCtrl2;
-	unsigned long long IBCDDRStatus;
-	unsigned long long JIntReload;
-	unsigned long long IBNCModeCtrl;
-	unsigned long long SendCtrl;
-	unsigned long long SendBufBase;
-	unsigned long long SendBufSize;
-	unsigned long long SendBufCnt;
-	unsigned long long SendAvailAddr;
-	unsigned long long TxIntMemBase;
-	unsigned long long TxIntMemSize;
-	unsigned long long SendDmaBase;
-	unsigned long long SendDmaLenGen;
-	unsigned long long SendDmaTail;
-	unsigned long long SendDmaHead;
-	unsigned long long SendDmaHeadAddr;
-	unsigned long long SendDmaBufMask0;
-	unsigned long long SendDmaBufMask1;
-	unsigned long long SendDmaBufMask2;
-	unsigned long long SendDmaStatus;
-	unsigned long long SendBufferError;
-	unsigned long long SendBufferErrorCONT1;
-	unsigned long long SendBufErr2; /* was Reserved6SBE[0/6] */
-	unsigned long long Reserved6L[2];
-	unsigned long long AvailUpdCount;
-	unsigned long long RcvHdrAddr0;
-	unsigned long long RcvHdrAddrs[16]; /* Why enumerate? */
-	unsigned long long Reserved7hdtl; /* Align next to 300 */
-	unsigned long long RcvHdrTailAddr0; /* 300, like others */
-	unsigned long long RcvHdrTailAddrs[16];
-	unsigned long long Reserved9SW[7]; /* was [8]; we have 17 ports */
-	unsigned long long IbsdEpbAccCtl; /* IB Serdes EPB access control */
-	unsigned long long IbsdEpbTransReg; /* IB Serdes EPB Transaction */
-	unsigned long long Reserved10sds; /* was SerdesStatus on */
-	unsigned long long XGXSConfig;
-	unsigned long long IBSerDesCtrl; /* Was IBPLLCfg on Monty */
-	unsigned long long EEPCtlStat; /* for "boot" EEPROM/FLASH */
-	unsigned long long EEPAddrCmd;
-	unsigned long long EEPData;
-	unsigned long long PcieEpbAccCtl;
-	unsigned long long PcieEpbTransCtl;
-	unsigned long long EfuseCtl; /* E-Fuse control */
-	unsigned long long EfuseData[4];
-	unsigned long long ProcMon;
-	/* this chip moves following two from previous 200, 208 */
-	unsigned long long PCIeRBufTestReg0;
-	unsigned long long PCIeRBufTestReg1;
-	/* added for this chip */
-	unsigned long long PCIeRBufTestReg2;
-	unsigned long long PCIeRBufTestReg3;
-	/* added for this chip, debug only */
-	unsigned long long SPC_JTAG_ACCESS_REG;
-	unsigned long long LAControlReg;
-	unsigned long long GPIODebugSelReg;
-	unsigned long long DebugPortValueReg;
-	/* added for this chip, DMA */
-	unsigned long long SendDmaBufUsed[3];
-	unsigned long long SendDmaReqTagUsed;
-	/*
-	 * added for this chip, EFUSE: note that these program 64-bit
-	 * words 2 and 3 */
-	unsigned long long efuse_pgm_data[2];
-	unsigned long long Reserved11LAalign[10]; /* Skip 4B0..4F8 */
-	/* we have 30 regs for DDS and RXEQ in IB SERDES */
-	unsigned long long SerDesDDSRXEQ[30];
-	unsigned long long Reserved12LAalign[2]; /* Skip 5F0, 5F8 */
-	/* added for LA debug support */
-	unsigned long long LAMemory[32];
-};
-
-struct _infinipath_do_not_use_counters {
-	__u64 LBIntCnt;
-	__u64 LBFlowStallCnt;
-	__u64 TxSDmaDescCnt;	/* was Reserved1 */
-	__u64 TxUnsupVLErrCnt;
-	__u64 TxDataPktCnt;
-	__u64 TxFlowPktCnt;
-	__u64 TxDwordCnt;
-	__u64 TxLenErrCnt;
-	__u64 TxMaxMinLenErrCnt;
-	__u64 TxUnderrunCnt;
-	__u64 TxFlowStallCnt;
-	__u64 TxDroppedPktCnt;
-	__u64 RxDroppedPktCnt;
-	__u64 RxDataPktCnt;
-	__u64 RxFlowPktCnt;
-	__u64 RxDwordCnt;
-	__u64 RxLenErrCnt;
-	__u64 RxMaxMinLenErrCnt;
-	__u64 RxICRCErrCnt;
-	__u64 RxVCRCErrCnt;
-	__u64 RxFlowCtrlErrCnt;
-	__u64 RxBadFormatCnt;
-	__u64 RxLinkProblemCnt;
-	__u64 RxEBPCnt;
-	__u64 RxLPCRCErrCnt;
-	__u64 RxBufOvflCnt;
-	__u64 RxTIDFullErrCnt;
-	__u64 RxTIDValidErrCnt;
-	__u64 RxPKeyMismatchCnt;
-	__u64 RxP0HdrEgrOvflCnt;
-	__u64 RxP1HdrEgrOvflCnt;
-	__u64 RxP2HdrEgrOvflCnt;
-	__u64 RxP3HdrEgrOvflCnt;
-	__u64 RxP4HdrEgrOvflCnt;
-	__u64 RxP5HdrEgrOvflCnt;
-	__u64 RxP6HdrEgrOvflCnt;
-	__u64 RxP7HdrEgrOvflCnt;
-	__u64 RxP8HdrEgrOvflCnt;
-	__u64 RxP9HdrEgrOvflCnt;	/* was Reserved6 */
-	__u64 RxP10HdrEgrOvflCnt;	/* was Reserved7 */
-	__u64 RxP11HdrEgrOvflCnt;	/* new for IBA7220 */
-	__u64 RxP12HdrEgrOvflCnt;	/* new for IBA7220 */
-	__u64 RxP13HdrEgrOvflCnt;	/* new for IBA7220 */
-	__u64 RxP14HdrEgrOvflCnt;	/* new for IBA7220 */
-	__u64 RxP15HdrEgrOvflCnt;	/* new for IBA7220 */
-	__u64 RxP16HdrEgrOvflCnt;	/* new for IBA7220 */
-	__u64 IBStatusChangeCnt;
-	__u64 IBLinkErrRecoveryCnt;
-	__u64 IBLinkDownedCnt;
-	__u64 IBSymbolErrCnt;
-	/* The following are new for IBA7220 */
-	__u64 RxVL15DroppedPktCnt;
-	__u64 RxOtherLocalPhyErrCnt;
-	__u64 PcieRetryBufDiagQwordCnt;
-	__u64 ExcessBufferOvflCnt;
-	__u64 LocalLinkIntegrityErrCnt;
-	__u64 RxVlErrCnt;
-	__u64 RxDlidFltrCnt;
-	__u64 Reserved8[7];
-	__u64 PSStat;
-	__u64 PSStart;
-	__u64 PSInterval;
-	__u64 PSRcvDataCount;
-	__u64 PSRcvPktsCount;
-	__u64 PSXmitDataCount;
-	__u64 PSXmitPktsCount;
-	__u64 PSXmitWaitCount;
-};
-
-#define IPATH_KREG_OFFSET(field) (offsetof( \
-	struct _infinipath_do_not_use_kernel_regs, field) / sizeof(u64))
-#define IPATH_CREG_OFFSET(field) (offsetof( \
-	struct _infinipath_do_not_use_counters, field) / sizeof(u64))
-
-static const struct ipath_kregs ipath_7220_kregs = {
-	.kr_control = IPATH_KREG_OFFSET(Control),
-	.kr_counterregbase = IPATH_KREG_OFFSET(CounterRegBase),
-	.kr_debugportselect = IPATH_KREG_OFFSET(DebugPortSelect),
-	.kr_errorclear = IPATH_KREG_OFFSET(ErrorClear),
-	.kr_errormask = IPATH_KREG_OFFSET(ErrorMask),
-	.kr_errorstatus = IPATH_KREG_OFFSET(ErrorStatus),
-	.kr_extctrl = IPATH_KREG_OFFSET(ExtCtrl),
-	.kr_extstatus = IPATH_KREG_OFFSET(ExtStatus),
-	.kr_gpio_clear = IPATH_KREG_OFFSET(GPIOClear),
-	.kr_gpio_mask = IPATH_KREG_OFFSET(GPIOMask),
-	.kr_gpio_out = IPATH_KREG_OFFSET(GPIOOut),
-	.kr_gpio_status = IPATH_KREG_OFFSET(GPIOStatus),
-	.kr_hwdiagctrl = IPATH_KREG_OFFSET(HwDiagCtrl),
-	.kr_hwerrclear = IPATH_KREG_OFFSET(HwErrClear),
-	.kr_hwerrmask = IPATH_KREG_OFFSET(HwErrMask),
-	.kr_hwerrstatus = IPATH_KREG_OFFSET(HwErrStatus),
-	.kr_ibcctrl = IPATH_KREG_OFFSET(IBCCtrl),
-	.kr_ibcstatus = IPATH_KREG_OFFSET(IBCStatus),
-	.kr_intblocked = IPATH_KREG_OFFSET(IntBlocked),
-	.kr_intclear = IPATH_KREG_OFFSET(IntClear),
-	.kr_intmask = IPATH_KREG_OFFSET(IntMask),
-	.kr_intstatus = IPATH_KREG_OFFSET(IntStatus),
-	.kr_mdio = IPATH_KREG_OFFSET(MDIO),
-	.kr_pagealign = IPATH_KREG_OFFSET(PageAlign),
-	.kr_partitionkey = IPATH_KREG_OFFSET(RcvPartitionKey),
-	.kr_portcnt = IPATH_KREG_OFFSET(PortCnt),
-	.kr_rcvbthqp = IPATH_KREG_OFFSET(RcvBTHQP),
-	.kr_rcvbufbase = IPATH_KREG_OFFSET(RcvBufBase),
-	.kr_rcvbufsize = IPATH_KREG_OFFSET(RcvBufSize),
-	.kr_rcvctrl = IPATH_KREG_OFFSET(RcvCtrl),
-	.kr_rcvegrbase = IPATH_KREG_OFFSET(RcvEgrBase),
-	.kr_rcvegrcnt = IPATH_KREG_OFFSET(RcvEgrCnt),
-	.kr_rcvhdrcnt = IPATH_KREG_OFFSET(RcvHdrCnt),
-	.kr_rcvhdrentsize = IPATH_KREG_OFFSET(RcvHdrEntSize),
-	.kr_rcvhdrsize = IPATH_KREG_OFFSET(RcvHdrSize),
-	.kr_rcvintmembase = IPATH_KREG_OFFSET(RxIntMemBase),
-	.kr_rcvintmemsize = IPATH_KREG_OFFSET(RxIntMemSize),
-	.kr_rcvtidbase = IPATH_KREG_OFFSET(RcvTIDBase),
-	.kr_rcvtidcnt = IPATH_KREG_OFFSET(RcvTIDCnt),
-	.kr_revision = IPATH_KREG_OFFSET(Revision),
-	.kr_scratch = IPATH_KREG_OFFSET(Scratch),
-	.kr_sendbuffererror = IPATH_KREG_OFFSET(SendBufferError),
-	.kr_sendctrl = IPATH_KREG_OFFSET(SendCtrl),
-	.kr_sendpioavailaddr = IPATH_KREG_OFFSET(SendAvailAddr),
-	.kr_sendpiobufbase = IPATH_KREG_OFFSET(SendBufBase),
-	.kr_sendpiobufcnt = IPATH_KREG_OFFSET(SendBufCnt),
-	.kr_sendpiosize = IPATH_KREG_OFFSET(SendBufSize),
-	.kr_sendregbase = IPATH_KREG_OFFSET(SendRegBase),
-	.kr_txintmembase = IPATH_KREG_OFFSET(TxIntMemBase),
-	.kr_txintmemsize = IPATH_KREG_OFFSET(TxIntMemSize),
-	.kr_userregbase = IPATH_KREG_OFFSET(UserRegBase),
-
-	.kr_xgxsconfig = IPATH_KREG_OFFSET(XGXSConfig),
-
-	/* send dma related regs */
-	.kr_senddmabase = IPATH_KREG_OFFSET(SendDmaBase),
-	.kr_senddmalengen = IPATH_KREG_OFFSET(SendDmaLenGen),
-	.kr_senddmatail = IPATH_KREG_OFFSET(SendDmaTail),
-	.kr_senddmahead = IPATH_KREG_OFFSET(SendDmaHead),
-	.kr_senddmaheadaddr = IPATH_KREG_OFFSET(SendDmaHeadAddr),
-	.kr_senddmabufmask0 = IPATH_KREG_OFFSET(SendDmaBufMask0),
-	.kr_senddmabufmask1 = IPATH_KREG_OFFSET(SendDmaBufMask1),
-	.kr_senddmabufmask2 = IPATH_KREG_OFFSET(SendDmaBufMask2),
-	.kr_senddmastatus = IPATH_KREG_OFFSET(SendDmaStatus),
-
-	/* SerDes related regs */
-	.kr_ibserdesctrl = IPATH_KREG_OFFSET(IBSerDesCtrl),
-	.kr_ib_epbacc = IPATH_KREG_OFFSET(IbsdEpbAccCtl),
-	.kr_ib_epbtrans = IPATH_KREG_OFFSET(IbsdEpbTransReg),
-	.kr_pcie_epbacc = IPATH_KREG_OFFSET(PcieEpbAccCtl),
-	.kr_pcie_epbtrans = IPATH_KREG_OFFSET(PcieEpbTransCtl),
-	.kr_ib_ddsrxeq = IPATH_KREG_OFFSET(SerDesDDSRXEQ),
-
-	/*
-	 * These should not be used directly via ipath_read_kreg64(),
-	 * use them with ipath_read_kreg64_port()
-	 */
-	.kr_rcvhdraddr = IPATH_KREG_OFFSET(RcvHdrAddr0),
-	.kr_rcvhdrtailaddr = IPATH_KREG_OFFSET(RcvHdrTailAddr0),
-
-	/*
-	 * The rcvpktled register controls one of the debug port signals, so
-	 * a packet activity LED can be connected to it.
-	 */
-	.kr_rcvpktledcnt = IPATH_KREG_OFFSET(RcvPktLEDCnt),
-	.kr_pcierbuftestreg0 = IPATH_KREG_OFFSET(PCIeRBufTestReg0),
-	.kr_pcierbuftestreg1 = IPATH_KREG_OFFSET(PCIeRBufTestReg1),
-
-	.kr_hrtbt_guid = IPATH_KREG_OFFSET(HRTBT_GUID),
-	.kr_ibcddrctrl = IPATH_KREG_OFFSET(IBCDDRCtrl),
-	.kr_ibcddrstatus = IPATH_KREG_OFFSET(IBCDDRStatus),
-	.kr_jintreload = IPATH_KREG_OFFSET(JIntReload)
-};
-
-static const struct ipath_cregs ipath_7220_cregs = {
-	.cr_badformatcnt = IPATH_CREG_OFFSET(RxBadFormatCnt),
-	.cr_erricrccnt = IPATH_CREG_OFFSET(RxICRCErrCnt),
-	.cr_errlinkcnt = IPATH_CREG_OFFSET(RxLinkProblemCnt),
-	.cr_errlpcrccnt = IPATH_CREG_OFFSET(RxLPCRCErrCnt),
-	.cr_errpkey = IPATH_CREG_OFFSET(RxPKeyMismatchCnt),
-	.cr_errrcvflowctrlcnt = IPATH_CREG_OFFSET(RxFlowCtrlErrCnt),
-	.cr_err_rlencnt = IPATH_CREG_OFFSET(RxLenErrCnt),
-	.cr_errslencnt = IPATH_CREG_OFFSET(TxLenErrCnt),
-	.cr_errtidfull = IPATH_CREG_OFFSET(RxTIDFullErrCnt),
-	.cr_errtidvalid = IPATH_CREG_OFFSET(RxTIDValidErrCnt),
-	.cr_errvcrccnt = IPATH_CREG_OFFSET(RxVCRCErrCnt),
-	.cr_ibstatuschange = IPATH_CREG_OFFSET(IBStatusChangeCnt),
-	.cr_intcnt = IPATH_CREG_OFFSET(LBIntCnt),
-	.cr_invalidrlencnt = IPATH_CREG_OFFSET(RxMaxMinLenErrCnt),
-	.cr_invalidslencnt = IPATH_CREG_OFFSET(TxMaxMinLenErrCnt),
-	.cr_lbflowstallcnt = IPATH_CREG_OFFSET(LBFlowStallCnt),
-	.cr_pktrcvcnt = IPATH_CREG_OFFSET(RxDataPktCnt),
-	.cr_pktrcvflowctrlcnt = IPATH_CREG_OFFSET(RxFlowPktCnt),
-	.cr_pktsendcnt = IPATH_CREG_OFFSET(TxDataPktCnt),
-	.cr_pktsendflowcnt = IPATH_CREG_OFFSET(TxFlowPktCnt),
-	.cr_portovflcnt = IPATH_CREG_OFFSET(RxP0HdrEgrOvflCnt),
-	.cr_rcvebpcnt = IPATH_CREG_OFFSET(RxEBPCnt),
-	.cr_rcvovflcnt = IPATH_CREG_OFFSET(RxBufOvflCnt),
-	.cr_senddropped = IPATH_CREG_OFFSET(TxDroppedPktCnt),
-	.cr_sendstallcnt = IPATH_CREG_OFFSET(TxFlowStallCnt),
-	.cr_sendunderruncnt = IPATH_CREG_OFFSET(TxUnderrunCnt),
-	.cr_wordrcvcnt = IPATH_CREG_OFFSET(RxDwordCnt),
-	.cr_wordsendcnt = IPATH_CREG_OFFSET(TxDwordCnt),
-	.cr_unsupvlcnt = IPATH_CREG_OFFSET(TxUnsupVLErrCnt),
-	.cr_rxdroppktcnt = IPATH_CREG_OFFSET(RxDroppedPktCnt),
-	.cr_iblinkerrrecovcnt = IPATH_CREG_OFFSET(IBLinkErrRecoveryCnt),
-	.cr_iblinkdowncnt = IPATH_CREG_OFFSET(IBLinkDownedCnt),
-	.cr_ibsymbolerrcnt = IPATH_CREG_OFFSET(IBSymbolErrCnt),
-	.cr_vl15droppedpktcnt = IPATH_CREG_OFFSET(RxVL15DroppedPktCnt),
-	.cr_rxotherlocalphyerrcnt =
-		IPATH_CREG_OFFSET(RxOtherLocalPhyErrCnt),
-	.cr_excessbufferovflcnt = IPATH_CREG_OFFSET(ExcessBufferOvflCnt),
-	.cr_locallinkintegrityerrcnt =
-		IPATH_CREG_OFFSET(LocalLinkIntegrityErrCnt),
-	.cr_rxvlerrcnt = IPATH_CREG_OFFSET(RxVlErrCnt),
-	.cr_rxdlidfltrcnt = IPATH_CREG_OFFSET(RxDlidFltrCnt),
-	.cr_psstat = IPATH_CREG_OFFSET(PSStat),
-	.cr_psstart = IPATH_CREG_OFFSET(PSStart),
-	.cr_psinterval = IPATH_CREG_OFFSET(PSInterval),
-	.cr_psrcvdatacount = IPATH_CREG_OFFSET(PSRcvDataCount),
-	.cr_psrcvpktscount = IPATH_CREG_OFFSET(PSRcvPktsCount),
-	.cr_psxmitdatacount = IPATH_CREG_OFFSET(PSXmitDataCount),
-	.cr_psxmitpktscount = IPATH_CREG_OFFSET(PSXmitPktsCount),
-	.cr_psxmitwaitcount = IPATH_CREG_OFFSET(PSXmitWaitCount),
-};
-
-/* kr_control bits */
-#define INFINIPATH_C_RESET (1U<<7)
-
-/* kr_intstatus, kr_intclear, kr_intmask bits */
-#define INFINIPATH_I_RCVURG_MASK ((1ULL<<17)-1)
-#define INFINIPATH_I_RCVURG_SHIFT 32
-#define INFINIPATH_I_RCVAVAIL_MASK ((1ULL<<17)-1)
-#define INFINIPATH_I_RCVAVAIL_SHIFT 0
-#define INFINIPATH_I_SERDESTRIMDONE (1ULL<<27)
-
-/* kr_hwerrclear, kr_hwerrmask, kr_hwerrstatus, bits */
-#define INFINIPATH_HWE_PCIEMEMPARITYERR_MASK  0x00000000000000ffULL
-#define INFINIPATH_HWE_PCIEMEMPARITYERR_SHIFT 0
-#define INFINIPATH_HWE_PCIEPOISONEDTLP      0x0000000010000000ULL
-#define INFINIPATH_HWE_PCIECPLTIMEOUT       0x0000000020000000ULL
-#define INFINIPATH_HWE_PCIEBUSPARITYXTLH    0x0000000040000000ULL
-#define INFINIPATH_HWE_PCIEBUSPARITYXADM    0x0000000080000000ULL
-#define INFINIPATH_HWE_PCIEBUSPARITYRADM    0x0000000100000000ULL
-#define INFINIPATH_HWE_COREPLL_FBSLIP       0x0080000000000000ULL
-#define INFINIPATH_HWE_COREPLL_RFSLIP       0x0100000000000000ULL
-#define INFINIPATH_HWE_PCIE1PLLFAILED       0x0400000000000000ULL
-#define INFINIPATH_HWE_PCIE0PLLFAILED       0x0800000000000000ULL
-#define INFINIPATH_HWE_SERDESPLLFAILED      0x1000000000000000ULL
-/* specific to this chip */
-#define INFINIPATH_HWE_PCIECPLDATAQUEUEERR         0x0000000000000040ULL
-#define INFINIPATH_HWE_PCIECPLHDRQUEUEERR          0x0000000000000080ULL
-#define INFINIPATH_HWE_SDMAMEMREADERR              0x0000000010000000ULL
-#define INFINIPATH_HWE_CLK_UC_PLLNOTLOCKED	   0x2000000000000000ULL
-#define INFINIPATH_HWE_PCIESERDESQ0PCLKNOTDETECT   0x0100000000000000ULL
-#define INFINIPATH_HWE_PCIESERDESQ1PCLKNOTDETECT   0x0200000000000000ULL
-#define INFINIPATH_HWE_PCIESERDESQ2PCLKNOTDETECT   0x0400000000000000ULL
-#define INFINIPATH_HWE_PCIESERDESQ3PCLKNOTDETECT   0x0800000000000000ULL
-#define INFINIPATH_HWE_DDSRXEQMEMORYPARITYERR	   0x0000008000000000ULL
-#define INFINIPATH_HWE_IB_UC_MEMORYPARITYERR	   0x0000004000000000ULL
-#define INFINIPATH_HWE_PCIE_UC_OCT0MEMORYPARITYERR 0x0000001000000000ULL
-#define INFINIPATH_HWE_PCIE_UC_OCT1MEMORYPARITYERR 0x0000002000000000ULL
-
-#define IBA7220_IBCS_LINKTRAININGSTATE_MASK 0x1F
-#define IBA7220_IBCS_LINKSTATE_SHIFT 5
-#define IBA7220_IBCS_LINKSPEED_SHIFT 8
-#define IBA7220_IBCS_LINKWIDTH_SHIFT 9
-
-#define IBA7220_IBCC_LINKINITCMD_MASK 0x7ULL
-#define IBA7220_IBCC_LINKCMD_SHIFT 19
-#define IBA7220_IBCC_MAXPKTLEN_SHIFT 21
-
-/* kr_ibcddrctrl bits */
-#define IBA7220_IBC_DLIDLMC_MASK	0xFFFFFFFFUL
-#define IBA7220_IBC_DLIDLMC_SHIFT	32
-#define IBA7220_IBC_HRTBT_MASK	3
-#define IBA7220_IBC_HRTBT_SHIFT	16
-#define IBA7220_IBC_HRTBT_ENB	0x10000UL
-#define IBA7220_IBC_LANE_REV_SUPPORTED (1<<8)
-#define IBA7220_IBC_LREV_MASK	1
-#define IBA7220_IBC_LREV_SHIFT	8
-#define IBA7220_IBC_RXPOL_MASK	1
-#define IBA7220_IBC_RXPOL_SHIFT	7
-#define IBA7220_IBC_WIDTH_SHIFT	5
-#define IBA7220_IBC_WIDTH_MASK	0x3
-#define IBA7220_IBC_WIDTH_1X_ONLY	(0<<IBA7220_IBC_WIDTH_SHIFT)
-#define IBA7220_IBC_WIDTH_4X_ONLY	(1<<IBA7220_IBC_WIDTH_SHIFT)
-#define IBA7220_IBC_WIDTH_AUTONEG	(2<<IBA7220_IBC_WIDTH_SHIFT)
-#define IBA7220_IBC_SPEED_AUTONEG	(1<<1)
-#define IBA7220_IBC_SPEED_SDR		(1<<2)
-#define IBA7220_IBC_SPEED_DDR		(1<<3)
-#define IBA7220_IBC_SPEED_AUTONEG_MASK  (0x7<<1)
-#define IBA7220_IBC_IBTA_1_2_MASK	(1)
-
-/* kr_ibcddrstatus */
-/* link latency shift is 0, don't bother defining */
-#define IBA7220_DDRSTAT_LINKLAT_MASK    0x3ffffff
-
-/* kr_extstatus bits */
-#define INFINIPATH_EXTS_FREQSEL 0x2
-#define INFINIPATH_EXTS_SERDESSEL 0x4
-#define INFINIPATH_EXTS_MEMBIST_ENDTEST     0x0000000000004000
-#define INFINIPATH_EXTS_MEMBIST_DISABLED    0x0000000000008000
-
-/* kr_xgxsconfig bits */
-#define INFINIPATH_XGXS_RESET          0x5ULL
-#define INFINIPATH_XGXS_FC_SAFE        (1ULL<<63)
-
-/* kr_rcvpktledcnt */
-#define IBA7220_LEDBLINK_ON_SHIFT 32 /* 4ns period on after packet */
-#define IBA7220_LEDBLINK_OFF_SHIFT 0 /* 4ns period off before next on */
-
-#define _IPATH_GPIO_SDA_NUM 1
-#define _IPATH_GPIO_SCL_NUM 0
-
-#define IPATH_GPIO_SDA (1ULL << \
-	(_IPATH_GPIO_SDA_NUM+INFINIPATH_EXTC_GPIOOE_SHIFT))
-#define IPATH_GPIO_SCL (1ULL << \
-	(_IPATH_GPIO_SCL_NUM+INFINIPATH_EXTC_GPIOOE_SHIFT))
-
-#define IBA7220_R_INTRAVAIL_SHIFT 17
-#define IBA7220_R_TAILUPD_SHIFT 35
-#define IBA7220_R_PORTCFG_SHIFT 36
-
-#define INFINIPATH_JINT_PACKETSHIFT 16
-#define INFINIPATH_JINT_DEFAULT_IDLE_TICKS  0
-#define INFINIPATH_JINT_DEFAULT_MAX_PACKETS 0
-
-#define IBA7220_HDRHEAD_PKTINT_SHIFT 32 /* interrupt cnt in upper 32 bits */
-
-/*
- * the size bits give us 2^N, in KB units.  0 marks as invalid,
- * and 7 is reserved.  We currently use only 2KB and 4KB
- */
-#define IBA7220_TID_SZ_SHIFT 37 /* shift to 3bit size selector */
-#define IBA7220_TID_SZ_2K (1UL<<IBA7220_TID_SZ_SHIFT) /* 2KB */
-#define IBA7220_TID_SZ_4K (2UL<<IBA7220_TID_SZ_SHIFT) /* 4KB */
-#define IBA7220_TID_PA_SHIFT 11U /* TID addr in chip stored w/o low bits */
-
-#define IPATH_AUTONEG_TRIES 5 /* sequential retries to negotiate DDR */
-
-static char int_type[16] = "auto";
-module_param_string(interrupt_type, int_type, sizeof(int_type), 0444);
-MODULE_PARM_DESC(int_type, " interrupt_type=auto|force_msi|force_intx");
-
-/* packet rate matching delay; chip has support */
-static u8 rate_to_delay[2][2] = {
-	/* 1x, 4x */
-	{   8, 2 }, /* SDR */
-	{   4, 1 }  /* DDR */
-};
-
-/* 7220 specific hardware errors... */
-static const struct ipath_hwerror_msgs ipath_7220_hwerror_msgs[] = {
-	INFINIPATH_HWE_MSG(PCIEPOISONEDTLP, "PCIe Poisoned TLP"),
-	INFINIPATH_HWE_MSG(PCIECPLTIMEOUT, "PCIe completion timeout"),
-	/*
-	 * In practice, it's unlikely wthat we'll see PCIe PLL, or bus
-	 * parity or memory parity error failures, because most likely we
-	 * won't be able to talk to the core of the chip.  Nonetheless, we
-	 * might see them, if they are in parts of the PCIe core that aren't
-	 * essential.
-	 */
-	INFINIPATH_HWE_MSG(PCIE1PLLFAILED, "PCIePLL1"),
-	INFINIPATH_HWE_MSG(PCIE0PLLFAILED, "PCIePLL0"),
-	INFINIPATH_HWE_MSG(PCIEBUSPARITYXTLH, "PCIe XTLH core parity"),
-	INFINIPATH_HWE_MSG(PCIEBUSPARITYXADM, "PCIe ADM TX core parity"),
-	INFINIPATH_HWE_MSG(PCIEBUSPARITYRADM, "PCIe ADM RX core parity"),
-	INFINIPATH_HWE_MSG(RXDSYNCMEMPARITYERR, "Rx Dsync"),
-	INFINIPATH_HWE_MSG(SERDESPLLFAILED, "SerDes PLL"),
-	INFINIPATH_HWE_MSG(PCIECPLDATAQUEUEERR, "PCIe cpl header queue"),
-	INFINIPATH_HWE_MSG(PCIECPLHDRQUEUEERR, "PCIe cpl data queue"),
-	INFINIPATH_HWE_MSG(SDMAMEMREADERR, "Send DMA memory read"),
-	INFINIPATH_HWE_MSG(CLK_UC_PLLNOTLOCKED, "uC PLL clock not locked"),
-	INFINIPATH_HWE_MSG(PCIESERDESQ0PCLKNOTDETECT,
-		"PCIe serdes Q0 no clock"),
-	INFINIPATH_HWE_MSG(PCIESERDESQ1PCLKNOTDETECT,
-		"PCIe serdes Q1 no clock"),
-	INFINIPATH_HWE_MSG(PCIESERDESQ2PCLKNOTDETECT,
-		"PCIe serdes Q2 no clock"),
-	INFINIPATH_HWE_MSG(PCIESERDESQ3PCLKNOTDETECT,
-		"PCIe serdes Q3 no clock"),
-	INFINIPATH_HWE_MSG(DDSRXEQMEMORYPARITYERR,
-		"DDS RXEQ memory parity"),
-	INFINIPATH_HWE_MSG(IB_UC_MEMORYPARITYERR, "IB uC memory parity"),
-	INFINIPATH_HWE_MSG(PCIE_UC_OCT0MEMORYPARITYERR,
-		"PCIe uC oct0 memory parity"),
-	INFINIPATH_HWE_MSG(PCIE_UC_OCT1MEMORYPARITYERR,
-		"PCIe uC oct1 memory parity"),
-};
-
-static void autoneg_work(struct work_struct *);
-
-/*
- * the offset is different for different configured port numbers, since
- * port0 is fixed in size, but others can vary.   Make it a function to
- * make the issue more obvious.
-*/
-static inline u32 port_egrtid_idx(struct ipath_devdata *dd, unsigned port)
-{
-	 return port ? dd->ipath_p0_rcvegrcnt +
-		 (port-1) * dd->ipath_rcvegrcnt : 0;
-}
-
-static void ipath_7220_txe_recover(struct ipath_devdata *dd)
-{
-	++ipath_stats.sps_txeparity;
-
-	dev_info(&dd->pcidev->dev,
-		"Recovering from TXE PIO parity error\n");
-	ipath_disarm_senderrbufs(dd);
-}
-
-
-/**
- * ipath_7220_handle_hwerrors - display hardware errors.
- * @dd: the infinipath device
- * @msg: the output buffer
- * @msgl: the size of the output buffer
- *
- * Use same msg buffer as regular errors to avoid excessive stack
- * use.  Most hardware errors are catastrophic, but for right now,
- * we'll print them and continue.  We reuse the same message buffer as
- * ipath_handle_errors() to avoid excessive stack usage.
- */
-static void ipath_7220_handle_hwerrors(struct ipath_devdata *dd, char *msg,
-				       size_t msgl)
-{
-	ipath_err_t hwerrs;
-	u32 bits, ctrl;
-	int isfatal = 0;
-	char bitsmsg[64];
-	int log_idx;
-
-	hwerrs = ipath_read_kreg64(dd, dd->ipath_kregs->kr_hwerrstatus);
-	if (!hwerrs) {
-		/*
-		 * better than printing cofusing messages
-		 * This seems to be related to clearing the crc error, or
-		 * the pll error during init.
-		 */
-		ipath_cdbg(VERBOSE, "Called but no hardware errors set\n");
-		goto bail;
-	} else if (hwerrs == ~0ULL) {
-		ipath_dev_err(dd, "Read of hardware error status failed "
-			      "(all bits set); ignoring\n");
-		goto bail;
-	}
-	ipath_stats.sps_hwerrs++;
-
-	/*
-	 * Always clear the error status register, except MEMBISTFAIL,
-	 * regardless of whether we continue or stop using the chip.
-	 * We want that set so we know it failed, even across driver reload.
-	 * We'll still ignore it in the hwerrmask.  We do this partly for
-	 * diagnostics, but also for support.
-	 */
-	ipath_write_kreg(dd, dd->ipath_kregs->kr_hwerrclear,
-			 hwerrs&~INFINIPATH_HWE_MEMBISTFAILED);
-
-	hwerrs &= dd->ipath_hwerrmask;
-
-	/* We log some errors to EEPROM, check if we have any of those. */
-	for (log_idx = 0; log_idx < IPATH_EEP_LOG_CNT; ++log_idx)
-		if (hwerrs & dd->ipath_eep_st_masks[log_idx].hwerrs_to_log)
-			ipath_inc_eeprom_err(dd, log_idx, 1);
-	/*
-	 * Make sure we get this much out, unless told to be quiet,
-	 * or it's occurred within the last 5 seconds.
-	 */
-	if ((hwerrs & ~(dd->ipath_lasthwerror |
-			((INFINIPATH_HWE_TXEMEMPARITYERR_PIOBUF |
-			  INFINIPATH_HWE_TXEMEMPARITYERR_PIOPBC)
-			 << INFINIPATH_HWE_TXEMEMPARITYERR_SHIFT))) ||
-	    (ipath_debug & __IPATH_VERBDBG))
-		dev_info(&dd->pcidev->dev, "Hardware error: hwerr=0x%llx "
-			 "(cleared)\n", (unsigned long long) hwerrs);
-	dd->ipath_lasthwerror |= hwerrs;
-
-	if (hwerrs & ~dd->ipath_hwe_bitsextant)
-		ipath_dev_err(dd, "hwerror interrupt with unknown errors "
-			      "%llx set\n", (unsigned long long)
-			      (hwerrs & ~dd->ipath_hwe_bitsextant));
-
-	if (hwerrs & INFINIPATH_HWE_IB_UC_MEMORYPARITYERR)
-		ipath_sd7220_clr_ibpar(dd);
-
-	ctrl = ipath_read_kreg32(dd, dd->ipath_kregs->kr_control);
-	if ((ctrl & INFINIPATH_C_FREEZEMODE) && !ipath_diag_inuse) {
-		/*
-		 * Parity errors in send memory are recoverable by h/w
-		 * just do housekeeping, exit freeze mode and continue.
-		 */
-		if (hwerrs & ((INFINIPATH_HWE_TXEMEMPARITYERR_PIOBUF |
-			       INFINIPATH_HWE_TXEMEMPARITYERR_PIOPBC)
-			      << INFINIPATH_HWE_TXEMEMPARITYERR_SHIFT)) {
-			ipath_7220_txe_recover(dd);
-			hwerrs &= ~((INFINIPATH_HWE_TXEMEMPARITYERR_PIOBUF |
-				     INFINIPATH_HWE_TXEMEMPARITYERR_PIOPBC)
-				    << INFINIPATH_HWE_TXEMEMPARITYERR_SHIFT);
-		}
-		if (hwerrs) {
-			/*
-			 * If any set that we aren't ignoring only make the
-			 * complaint once, in case it's stuck or recurring,
-			 * and we get here multiple times
-			 * Force link down, so switch knows, and
-			 * LEDs are turned off.
-			 */
-			if (dd->ipath_flags & IPATH_INITTED) {
-				ipath_set_linkstate(dd, IPATH_IB_LINKDOWN);
-				ipath_setup_7220_setextled(dd,
-					INFINIPATH_IBCS_L_STATE_DOWN,
-					INFINIPATH_IBCS_LT_STATE_DISABLED);
-				ipath_dev_err(dd, "Fatal Hardware Error "
-					      "(freeze mode), no longer"
-					      " usable, SN %.16s\n",
-						  dd->ipath_serial);
-				isfatal = 1;
-			}
-			/*
-			 * Mark as having had an error for driver, and also
-			 * for /sys and status word mapped to user programs.
-			 * This marks unit as not usable, until reset.
-			 */
-			*dd->ipath_statusp &= ~IPATH_STATUS_IB_READY;
-			*dd->ipath_statusp |= IPATH_STATUS_HWERROR;
-			dd->ipath_flags &= ~IPATH_INITTED;
-		} else {
-			ipath_dbg("Clearing freezemode on ignored or "
-				"recovered hardware error\n");
-			ipath_clear_freeze(dd);
-		}
-	}
-
-	*msg = '\0';
-
-	if (hwerrs & INFINIPATH_HWE_MEMBISTFAILED) {
-		strlcat(msg, "[Memory BIST test failed, "
-			"InfiniPath hardware unusable]", msgl);
-		/* ignore from now on, so disable until driver reloaded */
-		*dd->ipath_statusp |= IPATH_STATUS_HWERROR;
-		dd->ipath_hwerrmask &= ~INFINIPATH_HWE_MEMBISTFAILED;
-		ipath_write_kreg(dd, dd->ipath_kregs->kr_hwerrmask,
-				 dd->ipath_hwerrmask);
-	}
-
-	ipath_format_hwerrors(hwerrs,
-			      ipath_7220_hwerror_msgs,
-			      ARRAY_SIZE(ipath_7220_hwerror_msgs),
-			      msg, msgl);
-
-	if (hwerrs & (INFINIPATH_HWE_PCIEMEMPARITYERR_MASK
-		      << INFINIPATH_HWE_PCIEMEMPARITYERR_SHIFT)) {
-		bits = (u32) ((hwerrs >>
-			       INFINIPATH_HWE_PCIEMEMPARITYERR_SHIFT) &
-			      INFINIPATH_HWE_PCIEMEMPARITYERR_MASK);
-		snprintf(bitsmsg, sizeof bitsmsg,
-			 "[PCIe Mem Parity Errs %x] ", bits);
-		strlcat(msg, bitsmsg, msgl);
-	}
-
-#define _IPATH_PLL_FAIL (INFINIPATH_HWE_COREPLL_FBSLIP |	\
-			 INFINIPATH_HWE_COREPLL_RFSLIP)
-
-	if (hwerrs & _IPATH_PLL_FAIL) {
-		snprintf(bitsmsg, sizeof bitsmsg,
-			 "[PLL failed (%llx), InfiniPath hardware unusable]",
-			 (unsigned long long) hwerrs & _IPATH_PLL_FAIL);
-		strlcat(msg, bitsmsg, msgl);
-		/* ignore from now on, so disable until driver reloaded */
-		dd->ipath_hwerrmask &= ~(hwerrs & _IPATH_PLL_FAIL);
-		ipath_write_kreg(dd, dd->ipath_kregs->kr_hwerrmask,
-				 dd->ipath_hwerrmask);
-	}
-
-	if (hwerrs & INFINIPATH_HWE_SERDESPLLFAILED) {
-		/*
-		 * If it occurs, it is left masked since the eternal
-		 * interface is unused.
-		 */
-		dd->ipath_hwerrmask &= ~INFINIPATH_HWE_SERDESPLLFAILED;
-		ipath_write_kreg(dd, dd->ipath_kregs->kr_hwerrmask,
-				 dd->ipath_hwerrmask);
-	}
-
-	ipath_dev_err(dd, "%s hardware error\n", msg);
-	/*
-	 * For /sys status file. if no trailing } is copied, we'll
-	 * know it was truncated.
-	 */
-	if (isfatal && !ipath_diag_inuse && dd->ipath_freezemsg)
-		snprintf(dd->ipath_freezemsg, dd->ipath_freezelen,
-			 "{%s}", msg);
-bail:;
-}
-
-/**
- * ipath_7220_boardname - fill in the board name
- * @dd: the infinipath device
- * @name: the output buffer
- * @namelen: the size of the output buffer
- *
- * info is based on the board revision register
- */
-static int ipath_7220_boardname(struct ipath_devdata *dd, char *name,
-	size_t namelen)
-{
-	char *n = NULL;
-	u8 boardrev = dd->ipath_boardrev;
-	int ret;
-
-	if (boardrev == 15) {
-		/*
-		 * Emulator sometimes comes up all-ones, rather than zero.
-		 */
-		boardrev = 0;
-		dd->ipath_boardrev = boardrev;
-	}
-	switch (boardrev) {
-	case 0:
-		n = "InfiniPath_7220_Emulation";
-		break;
-	case 1:
-		n = "InfiniPath_QLE7240";
-		break;
-	case 2:
-		n = "InfiniPath_QLE7280";
-		break;
-	case 3:
-		n = "InfiniPath_QLE7242";
-		break;
-	case 4:
-		n = "InfiniPath_QEM7240";
-		break;
-	case 5:
-		n = "InfiniPath_QMI7240";
-		break;
-	case 6:
-		n = "InfiniPath_QMI7264";
-		break;
-	case 7:
-		n = "InfiniPath_QMH7240";
-		break;
-	case 8:
-		n = "InfiniPath_QME7240";
-		break;
-	case 9:
-		n = "InfiniPath_QLE7250";
-		break;
-	case 10:
-		n = "InfiniPath_QLE7290";
-		break;
-	case 11:
-		n = "InfiniPath_QEM7250";
-		break;
-	case 12:
-		n = "InfiniPath_QLE-Bringup";
-		break;
-	default:
-		ipath_dev_err(dd,
-			      "Don't yet know about board with ID %u\n",
-			      boardrev);
-		snprintf(name, namelen, "Unknown_InfiniPath_PCIe_%u",
-			 boardrev);
-		break;
-	}
-	if (n)
-		snprintf(name, namelen, "%s", n);
-
-	if (dd->ipath_majrev != 5 || !dd->ipath_minrev ||
-		dd->ipath_minrev > 2) {
-		ipath_dev_err(dd, "Unsupported InfiniPath hardware "
-			      "revision %u.%u!\n",
-			      dd->ipath_majrev, dd->ipath_minrev);
-		ret = 1;
-	} else if (dd->ipath_minrev == 1 &&
-		!(dd->ipath_flags & IPATH_INITTED)) {
-		/* Rev1 chips are prototype. Complain at init, but allow use */
-		ipath_dev_err(dd, "Unsupported hardware "
-			      "revision %u.%u, Contact support@qlogic.com\n",
-			      dd->ipath_majrev, dd->ipath_minrev);
-		ret = 0;
-	} else
-		ret = 0;
-
-	/*
-	 * Set here not in ipath_init_*_funcs because we have to do
-	 * it after we can read chip registers.
-	 */
-	dd->ipath_ureg_align = 0x10000;  /* 64KB alignment */
-
-	return ret;
-}
-
-/**
- * ipath_7220_init_hwerrors - enable hardware errors
- * @dd: the infinipath device
- *
- * now that we have finished initializing everything that might reasonably
- * cause a hardware error, and cleared those errors bits as they occur,
- * we can enable hardware errors in the mask (potentially enabling
- * freeze mode), and enable hardware errors as errors (along with
- * everything else) in errormask
- */
-static void ipath_7220_init_hwerrors(struct ipath_devdata *dd)
-{
-	ipath_err_t val;
-	u64 extsval;
-
-	extsval = ipath_read_kreg64(dd, dd->ipath_kregs->kr_extstatus);
-
-	if (!(extsval & (INFINIPATH_EXTS_MEMBIST_ENDTEST |
-			INFINIPATH_EXTS_MEMBIST_DISABLED)))
-		ipath_dev_err(dd, "MemBIST did not complete!\n");
-	if (extsval & INFINIPATH_EXTS_MEMBIST_DISABLED)
-		dev_info(&dd->pcidev->dev, "MemBIST is disabled.\n");
-
-	val = ~0ULL;	/* barring bugs, all hwerrors become interrupts, */
-
-	if (!dd->ipath_boardrev)	/* no PLL for Emulator */
-		val &= ~INFINIPATH_HWE_SERDESPLLFAILED;
-
-	if (dd->ipath_minrev == 1)
-		val &= ~(1ULL << 42); /* TXE LaunchFIFO Parity rev1 issue */
-
-	val &= ~INFINIPATH_HWE_IB_UC_MEMORYPARITYERR;
-	dd->ipath_hwerrmask = val;
-
-	/*
-	 * special trigger "error" is for debugging purposes. It
-	 * works around a processor/chipset problem.  The error
-	 * interrupt allows us to count occurrences, but we don't
-	 * want to pay the overhead for normal use.  Emulation only
-	 */
-	if (!dd->ipath_boardrev)
-		dd->ipath_maskederrs = INFINIPATH_E_SENDSPECIALTRIGGER;
-}
-
-/*
- * All detailed interaction with the SerDes has been moved to ipath_sd7220.c
- *
- * The portion of IBA7220-specific bringup_serdes() that actually deals with
- * registers and memory within the SerDes itself is ipath_sd7220_init().
- */
-
-/**
- * ipath_7220_bringup_serdes - bring up the serdes
- * @dd: the infinipath device
- */
-static int ipath_7220_bringup_serdes(struct ipath_devdata *dd)
-{
-	int ret = 0;
-	u64 val, prev_val, guid;
-	int was_reset;		/* Note whether uC was reset */
-
-	ipath_dbg("Trying to bringup serdes\n");
-
-	if (ipath_read_kreg64(dd, dd->ipath_kregs->kr_hwerrstatus) &
-	    INFINIPATH_HWE_SERDESPLLFAILED) {
-		ipath_dbg("At start, serdes PLL failed bit set "
-			  "in hwerrstatus, clearing and continuing\n");
-		ipath_write_kreg(dd, dd->ipath_kregs->kr_hwerrclear,
-				 INFINIPATH_HWE_SERDESPLLFAILED);
-	}
-
-	dd->ibdeltainprog = 1;
-	dd->ibsymsnap =
-	     ipath_read_creg32(dd, dd->ipath_cregs->cr_ibsymbolerrcnt);
-	dd->iblnkerrsnap =
-	     ipath_read_creg32(dd, dd->ipath_cregs->cr_iblinkerrrecovcnt);
-
-	if (!dd->ipath_ibcddrctrl) {
-		/* not on re-init after reset */
-		dd->ipath_ibcddrctrl =
-			ipath_read_kreg64(dd, dd->ipath_kregs->kr_ibcddrctrl);
-
-		if (dd->ipath_link_speed_enabled ==
-			(IPATH_IB_SDR | IPATH_IB_DDR))
-			dd->ipath_ibcddrctrl |=
-				IBA7220_IBC_SPEED_AUTONEG_MASK |
-				IBA7220_IBC_IBTA_1_2_MASK;
-		else
-			dd->ipath_ibcddrctrl |=
-				dd->ipath_link_speed_enabled == IPATH_IB_DDR
-				?  IBA7220_IBC_SPEED_DDR :
-				IBA7220_IBC_SPEED_SDR;
-		if ((dd->ipath_link_width_enabled & (IB_WIDTH_1X |
-			IB_WIDTH_4X)) == (IB_WIDTH_1X | IB_WIDTH_4X))
-			dd->ipath_ibcddrctrl |= IBA7220_IBC_WIDTH_AUTONEG;
-		else
-			dd->ipath_ibcddrctrl |=
-				dd->ipath_link_width_enabled == IB_WIDTH_4X
-				? IBA7220_IBC_WIDTH_4X_ONLY :
-				IBA7220_IBC_WIDTH_1X_ONLY;
-
-		/* always enable these on driver reload, not sticky */
-		dd->ipath_ibcddrctrl |=
-			IBA7220_IBC_RXPOL_MASK << IBA7220_IBC_RXPOL_SHIFT;
-		dd->ipath_ibcddrctrl |=
-			IBA7220_IBC_HRTBT_MASK << IBA7220_IBC_HRTBT_SHIFT;
-		/*
-		 * automatic lane reversal detection for receive
-		 * doesn't work correctly in rev 1, so disable it
-		 * on that rev, otherwise enable (disabling not
-		 * sticky across reload for >rev1)
-		 */
-		if (dd->ipath_minrev == 1)
-			dd->ipath_ibcddrctrl &=
-			~IBA7220_IBC_LANE_REV_SUPPORTED;
-		else
-			dd->ipath_ibcddrctrl |=
-				IBA7220_IBC_LANE_REV_SUPPORTED;
-	}
-
-	ipath_write_kreg(dd, dd->ipath_kregs->kr_ibcddrctrl,
-			dd->ipath_ibcddrctrl);
-
-	ipath_write_kreg(dd, IPATH_KREG_OFFSET(IBNCModeCtrl), 0Ull);
-
-	/* IBA7220 has SERDES MPU reset in D0 of what _was_ IBPLLCfg */
-	val = ipath_read_kreg64(dd, dd->ipath_kregs->kr_ibserdesctrl);
-	/* remember if uC was in Reset or not, for dactrim */
-	was_reset = (val & 1);
-	ipath_cdbg(VERBOSE, "IBReset %s xgxsconfig %llx\n",
-		   was_reset ? "Asserted" : "Negated", (unsigned long long)
-		   ipath_read_kreg64(dd, dd->ipath_kregs->kr_xgxsconfig));
-
-	if (dd->ipath_boardrev) {
-		/*
-		 * Hardware is not emulator, and may have been reset. Init it.
-		 * Below will release reset, but needs to know if chip was
-		 * originally in reset, to only trim DACs on first time
-		 * after chip reset or powercycle (not driver reload)
-		 */
-		ret = ipath_sd7220_init(dd, was_reset);
-	}
-
-	val = ipath_read_kreg64(dd, dd->ipath_kregs->kr_xgxsconfig);
-	prev_val = val;
-	val |= INFINIPATH_XGXS_FC_SAFE;
-	if (val != prev_val) {
-		ipath_write_kreg(dd, dd->ipath_kregs->kr_xgxsconfig, val);
-		ipath_read_kreg32(dd, dd->ipath_kregs->kr_scratch);
-	}
-	if (val & INFINIPATH_XGXS_RESET)
-		val &= ~INFINIPATH_XGXS_RESET;
-	if (val != prev_val)
-		ipath_write_kreg(dd, dd->ipath_kregs->kr_xgxsconfig, val);
-
-	ipath_cdbg(VERBOSE, "done: xgxs=%llx from %llx\n",
-		   (unsigned long long)
-		   ipath_read_kreg64(dd, dd->ipath_kregs->kr_xgxsconfig),
-		   (unsigned long long) prev_val);
-
-	guid = be64_to_cpu(dd->ipath_guid);
-
-	if (!guid) {
-		/* have to have something, so use likely unique tsc */
-		guid = get_cycles();
-		ipath_dbg("No GUID for heartbeat, faking %llx\n",
-			(unsigned long long)guid);
-	} else
-		ipath_cdbg(VERBOSE, "Wrote %llX to HRTBT_GUID\n",
-			(unsigned long long) guid);
-	ipath_write_kreg(dd, dd->ipath_kregs->kr_hrtbt_guid, guid);
-	return ret;
-}
-
-static void ipath_7220_config_jint(struct ipath_devdata *dd,
-				   u16 idle_ticks, u16 max_packets)
-{
-
-	/*
-	 * We can request a receive interrupt for 1 or more packets
-	 * from current offset.
-	 */
-	if (idle_ticks == 0 || max_packets == 0)
-		/* interrupt after one packet if no mitigation */
-		dd->ipath_rhdrhead_intr_off =
-			1ULL << IBA7220_HDRHEAD_PKTINT_SHIFT;
-	else
-		/* Turn off RcvHdrHead interrupts if using mitigation */
-		dd->ipath_rhdrhead_intr_off = 0ULL;
-
-	/* refresh kernel RcvHdrHead registers... */
-	ipath_write_ureg(dd, ur_rcvhdrhead,
-			 dd->ipath_rhdrhead_intr_off |
-			 dd->ipath_pd[0]->port_head, 0);
-
-	dd->ipath_jint_max_packets = max_packets;
-	dd->ipath_jint_idle_ticks = idle_ticks;
-	ipath_write_kreg(dd, dd->ipath_kregs->kr_jintreload,
-			 ((u64) max_packets << INFINIPATH_JINT_PACKETSHIFT) |
-			 idle_ticks);
-}
-
-/**
- * ipath_7220_quiet_serdes - set serdes to txidle
- * @dd: the infinipath device
- * Called when driver is being unloaded
- */
-static void ipath_7220_quiet_serdes(struct ipath_devdata *dd)
-{
-	u64 val;
-	if (dd->ibsymdelta || dd->iblnkerrdelta ||
-	    dd->ibdeltainprog) {
-		u64 diagc;
-		/* enable counter writes */
-		diagc = ipath_read_kreg64(dd, dd->ipath_kregs->kr_hwdiagctrl);
-		ipath_write_kreg(dd, dd->ipath_kregs->kr_hwdiagctrl,
-				 diagc | INFINIPATH_DC_COUNTERWREN);
-
-		if (dd->ibsymdelta || dd->ibdeltainprog) {
-			val = ipath_read_creg32(dd,
-					dd->ipath_cregs->cr_ibsymbolerrcnt);
-			if (dd->ibdeltainprog)
-				val -= val - dd->ibsymsnap;
-			val -= dd->ibsymdelta;
-			ipath_write_creg(dd,
-				  dd->ipath_cregs->cr_ibsymbolerrcnt, val);
-		}
-		if (dd->iblnkerrdelta || dd->ibdeltainprog) {
-			val = ipath_read_creg32(dd,
-					dd->ipath_cregs->cr_iblinkerrrecovcnt);
-			if (dd->ibdeltainprog)
-				val -= val - dd->iblnkerrsnap;
-			val -= dd->iblnkerrdelta;
-			ipath_write_creg(dd,
-				   dd->ipath_cregs->cr_iblinkerrrecovcnt, val);
-	     }
-
-	     /* and disable counter writes */
-	     ipath_write_kreg(dd, dd->ipath_kregs->kr_hwdiagctrl, diagc);
-	}
-
-	dd->ipath_flags &= ~IPATH_IB_AUTONEG_INPROG;
-	wake_up(&dd->ipath_autoneg_wait);
-	cancel_delayed_work(&dd->ipath_autoneg_work);
-	flush_scheduled_work();
-	ipath_shutdown_relock_poll(dd);
-	val = ipath_read_kreg64(dd, dd->ipath_kregs->kr_xgxsconfig);
-	val |= INFINIPATH_XGXS_RESET;
-	ipath_write_kreg(dd, dd->ipath_kregs->kr_xgxsconfig, val);
-}
-
-static int ipath_7220_intconfig(struct ipath_devdata *dd)
-{
-	ipath_7220_config_jint(dd, dd->ipath_jint_idle_ticks,
-			       dd->ipath_jint_max_packets);
-	return 0;
-}
-
-/**
- * ipath_setup_7220_setextled - set the state of the two external LEDs
- * @dd: the infinipath device
- * @lst: the L state
- * @ltst: the LT state
- *
- * These LEDs indicate the physical and logical state of IB link.
- * For this chip (at least with recommended board pinouts), LED1
- * is Yellow (logical state) and LED2 is Green (physical state),
- *
- * Note:  We try to match the Mellanox HCA LED behavior as best
- * we can.  Green indicates physical link state is OK (something is
- * plugged in, and we can train).
- * Amber indicates the link is logically up (ACTIVE).
- * Mellanox further blinks the amber LED to indicate data packet
- * activity, but we have no hardware support for that, so it would
- * require waking up every 10-20 msecs and checking the counters
- * on the chip, and then turning the LED off if appropriate.  That's
- * visible overhead, so not something we will do.
- *
- */
-static void ipath_setup_7220_setextled(struct ipath_devdata *dd, u64 lst,
-				       u64 ltst)
-{
-	u64 extctl, ledblink = 0;
-	unsigned long flags = 0;
-
-	/* the diags use the LED to indicate diag info, so we leave
-	 * the external LED alone when the diags are running */
-	if (ipath_diag_inuse)
-		return;
-
-	/* Allow override of LED display for, e.g. Locating system in rack */
-	if (dd->ipath_led_override) {
-		ltst = (dd->ipath_led_override & IPATH_LED_PHYS)
-			? INFINIPATH_IBCS_LT_STATE_LINKUP
-			: INFINIPATH_IBCS_LT_STATE_DISABLED;
-		lst = (dd->ipath_led_override & IPATH_LED_LOG)
-			? INFINIPATH_IBCS_L_STATE_ACTIVE
-			: INFINIPATH_IBCS_L_STATE_DOWN;
-	}
-
-	spin_lock_irqsave(&dd->ipath_gpio_lock, flags);
-	extctl = dd->ipath_extctrl & ~(INFINIPATH_EXTC_LED1PRIPORT_ON |
-				       INFINIPATH_EXTC_LED2PRIPORT_ON);
-	if (ltst == INFINIPATH_IBCS_LT_STATE_LINKUP) {
-		extctl |= INFINIPATH_EXTC_LED1PRIPORT_ON;
-		/*
-		 * counts are in chip clock (4ns) periods.
-		 * This is 1/16 sec (66.6ms) on,
-		 * 3/16 sec (187.5 ms) off, with packets rcvd
-		 */
-		ledblink = ((66600*1000UL/4) << IBA7220_LEDBLINK_ON_SHIFT)
-			| ((187500*1000UL/4) << IBA7220_LEDBLINK_OFF_SHIFT);
-	}
-	if (lst == INFINIPATH_IBCS_L_STATE_ACTIVE)
-		extctl |= INFINIPATH_EXTC_LED2PRIPORT_ON;
-	dd->ipath_extctrl = extctl;
-	ipath_write_kreg(dd, dd->ipath_kregs->kr_extctrl, extctl);
-	spin_unlock_irqrestore(&dd->ipath_gpio_lock, flags);
-
-	if (ledblink) /* blink the LED on packet receive */
-		ipath_write_kreg(dd, dd->ipath_kregs->kr_rcvpktledcnt,
-			ledblink);
-}
-
-/*
- * Similar to pci_intx(pdev, 1), except that we make sure
- * msi is off...
- */
-static void ipath_enable_intx(struct pci_dev *pdev)
-{
-	u16 cw, new;
-	int pos;
-
-	/* first, turn on INTx */
-	pci_read_config_word(pdev, PCI_COMMAND, &cw);
-	new = cw & ~PCI_COMMAND_INTX_DISABLE;
-	if (new != cw)
-		pci_write_config_word(pdev, PCI_COMMAND, new);
-
-	/* then turn off MSI */
-	pos = pci_find_capability(pdev, PCI_CAP_ID_MSI);
-	if (pos) {
-		pci_read_config_word(pdev, pos + PCI_MSI_FLAGS, &cw);
-		new = cw & ~PCI_MSI_FLAGS_ENABLE;
-		if (new != cw)
-			pci_write_config_word(pdev, pos + PCI_MSI_FLAGS, new);
-	}
-}
-
-static int ipath_msi_enabled(struct pci_dev *pdev)
-{
-	int pos, ret = 0;
-
-	pos = pci_find_capability(pdev, PCI_CAP_ID_MSI);
-	if (pos) {
-		u16 cw;
-
-		pci_read_config_word(pdev, pos + PCI_MSI_FLAGS, &cw);
-		ret = !!(cw & PCI_MSI_FLAGS_ENABLE);
-	}
-	return ret;
-}
-
-/*
- * disable msi interrupt if enabled, and clear the flag.
- * flag is used primarily for the fallback to INTx, but
- * is also used in reinit after reset as a flag.
- */
-static void ipath_7220_nomsi(struct ipath_devdata *dd)
-{
-	dd->ipath_msi_lo = 0;
-
-	if (ipath_msi_enabled(dd->pcidev)) {
-		/*
-		 * free, but don't zero; later kernels require
-		 * it be freed before disable_msi, so the intx
-		 * setup has to request it again.
-		 */
-		 if (dd->ipath_irq)
-			free_irq(dd->ipath_irq, dd);
-		pci_disable_msi(dd->pcidev);
-	}
-}
-
-/*
- * ipath_setup_7220_cleanup - clean up any per-chip chip-specific stuff
- * @dd: the infinipath device
- *
- * Nothing but msi interrupt cleanup for now.
- *
- * This is called during driver unload.
- */
-static void ipath_setup_7220_cleanup(struct ipath_devdata *dd)
-{
-	ipath_7220_nomsi(dd);
-}
-
-
-static void ipath_7220_pcie_params(struct ipath_devdata *dd, u32 boardrev)
-{
-	u16 linkstat, minwidth, speed;
-	int pos;
-
-	pos = pci_find_capability(dd->pcidev, PCI_CAP_ID_EXP);
-	if (!pos) {
-		ipath_dev_err(dd, "Can't find PCI Express capability!\n");
-		goto bail;
-	}
-
-	pci_read_config_word(dd->pcidev, pos + PCI_EXP_LNKSTA,
-			     &linkstat);
-	/*
-	 * speed is bits 0-4, linkwidth is bits 4-8
-	 * no defines for them in headers
-	 */
-	speed = linkstat & 0xf;
-	linkstat >>= 4;
-	linkstat &= 0x1f;
-	dd->ipath_lbus_width = linkstat;
-	switch (boardrev) {
-	case 0:
-	case 2:
-	case 10:
-	case 12:
-		minwidth = 16; /* x16 capable boards */
-		break;
-	default:
-		minwidth = 8; /* x8 capable boards */
-		break;
-	}
-
-	switch (speed) {
-	case 1:
-		dd->ipath_lbus_speed = 2500; /* Gen1, 2.5GHz */
-		break;
-	case 2:
-		dd->ipath_lbus_speed = 5000; /* Gen1, 5GHz */
-		break;
-	default: /* not defined, assume gen1 */
-		dd->ipath_lbus_speed = 2500;
-		break;
-	}
-
-	if (linkstat < minwidth)
-		ipath_dev_err(dd,
-			"PCIe width %u (x%u HCA), performance "
-			"reduced\n", linkstat, minwidth);
-	else
-		ipath_cdbg(VERBOSE, "PCIe speed %u width %u (x%u HCA)\n",
-			dd->ipath_lbus_speed, linkstat, minwidth);
-
-	if (speed != 1)
-		ipath_dev_err(dd,
-			"PCIe linkspeed %u is incorrect; "
-			"should be 1 (2500)!\n", speed);
-
-bail:
-	/* fill in string, even on errors */
-	snprintf(dd->ipath_lbus_info, sizeof(dd->ipath_lbus_info),
-		"PCIe,%uMHz,x%u\n",
-		dd->ipath_lbus_speed,
-		dd->ipath_lbus_width);
-	return;
-}
-
-
-/**
- * ipath_setup_7220_config - setup PCIe config related stuff
- * @dd: the infinipath device
- * @pdev: the PCI device
- *
- * The pci_enable_msi() call will fail on systems with MSI quirks
- * such as those with AMD8131, even if the device of interest is not
- * attached to that device, (in the 2.6.13 - 2.6.15 kernels, at least, fixed
- * late in 2.6.16).
- * All that can be done is to edit the kernel source to remove the quirk
- * check until that is fixed.
- * We do not need to call enable_msi() for our HyperTransport chip,
- * even though it uses MSI, and we want to avoid the quirk warning, so
- * So we call enable_msi only for PCIe.  If we do end up needing
- * pci_enable_msi at some point in the future for HT, we'll move the
- * call back into the main init_one code.
- * We save the msi lo and hi values, so we can restore them after
- * chip reset (the kernel PCI infrastructure doesn't yet handle that
- * correctly).
- */
-static int ipath_setup_7220_config(struct ipath_devdata *dd,
-				   struct pci_dev *pdev)
-{
-	int pos, ret = -1;
-	u32 boardrev;
-
-	dd->ipath_msi_lo = 0;	/* used as a flag during reset processing */
-
-	pos = pci_find_capability(pdev, PCI_CAP_ID_MSI);
-	if (!strcmp(int_type, "force_msi") || !strcmp(int_type, "auto"))
-		ret = pci_enable_msi(pdev);
-	if (ret) {
-		if (!strcmp(int_type, "force_msi")) {
-			ipath_dev_err(dd, "pci_enable_msi failed: %d, "
-				      "force_msi is on, so not continuing.\n",
-				      ret);
-			return ret;
-		}
-
-		ipath_enable_intx(pdev);
-		if (!strcmp(int_type, "auto"))
-			ipath_dev_err(dd, "pci_enable_msi failed: %d, "
-				      "falling back to INTx\n", ret);
-	} else if (pos) {
-		u16 control;
-		pci_read_config_dword(pdev, pos + PCI_MSI_ADDRESS_LO,
-				      &dd->ipath_msi_lo);
-		pci_read_config_dword(pdev, pos + PCI_MSI_ADDRESS_HI,
-				      &dd->ipath_msi_hi);
-		pci_read_config_word(pdev, pos + PCI_MSI_FLAGS,
-				     &control);
-		/* now save the data (vector) info */
-		pci_read_config_word(pdev,
-				     pos + ((control & PCI_MSI_FLAGS_64BIT)
-					    ? PCI_MSI_DATA_64 :
-					    PCI_MSI_DATA_32),
-				     &dd->ipath_msi_data);
-	} else
-		ipath_dev_err(dd, "Can't find MSI capability, "
-			      "can't save MSI settings for reset\n");
-
-	dd->ipath_irq = pdev->irq;
-
-	/*
-	 * We save the cachelinesize also, although it doesn't
-	 * really matter.
-	 */
-	pci_read_config_byte(pdev, PCI_CACHE_LINE_SIZE,
-			     &dd->ipath_pci_cacheline);
-
-	/*
-	 * this function called early, ipath_boardrev not set yet.  Can't
-	 * use ipath_read_kreg64() yet, too early in init, so use readq()
-	 */
-	boardrev = (readq(&dd->ipath_kregbase[dd->ipath_kregs->kr_revision])
-		 >> INFINIPATH_R_BOARDID_SHIFT) & INFINIPATH_R_BOARDID_MASK;
-
-	ipath_7220_pcie_params(dd, boardrev);
-
-	dd->ipath_flags |= IPATH_NODMA_RTAIL | IPATH_HAS_SEND_DMA |
-		IPATH_HAS_PBC_CNT | IPATH_HAS_THRESH_UPDATE;
-	dd->ipath_pioupd_thresh = 4U; /* set default update threshold */
-	return 0;
-}
-
-static void ipath_init_7220_variables(struct ipath_devdata *dd)
-{
-	/*
-	 * setup the register offsets, since they are different for each
-	 * chip
-	 */
-	dd->ipath_kregs = &ipath_7220_kregs;
-	dd->ipath_cregs = &ipath_7220_cregs;
-
-	/*
-	 * bits for selecting i2c direction and values,
-	 * used for I2C serial flash
-	 */
-	dd->ipath_gpio_sda_num = _IPATH_GPIO_SDA_NUM;
-	dd->ipath_gpio_scl_num = _IPATH_GPIO_SCL_NUM;
-	dd->ipath_gpio_sda = IPATH_GPIO_SDA;
-	dd->ipath_gpio_scl = IPATH_GPIO_SCL;
-
-	/*
-	 * Fill in data for field-values that change in IBA7220.
-	 * We dynamically specify only the mask for LINKTRAININGSTATE
-	 * and only the shift for LINKSTATE, as they are the only ones
-	 * that change.  Also precalculate the 3 link states of interest
-	 * and the combined mask.
-	 */
-	dd->ibcs_ls_shift = IBA7220_IBCS_LINKSTATE_SHIFT;
-	dd->ibcs_lts_mask = IBA7220_IBCS_LINKTRAININGSTATE_MASK;
-	dd->ibcs_mask = (INFINIPATH_IBCS_LINKSTATE_MASK <<
-		dd->ibcs_ls_shift) | dd->ibcs_lts_mask;
-	dd->ib_init = (INFINIPATH_IBCS_LT_STATE_LINKUP <<
-		INFINIPATH_IBCS_LINKTRAININGSTATE_SHIFT) |
-		(INFINIPATH_IBCS_L_STATE_INIT << dd->ibcs_ls_shift);
-	dd->ib_arm = (INFINIPATH_IBCS_LT_STATE_LINKUP <<
-		INFINIPATH_IBCS_LINKTRAININGSTATE_SHIFT) |
-		(INFINIPATH_IBCS_L_STATE_ARM << dd->ibcs_ls_shift);
-	dd->ib_active = (INFINIPATH_IBCS_LT_STATE_LINKUP <<
-		INFINIPATH_IBCS_LINKTRAININGSTATE_SHIFT) |
-		(INFINIPATH_IBCS_L_STATE_ACTIVE << dd->ibcs_ls_shift);
-
-	/*
-	 * Fill in data for ibcc field-values that change in IBA7220.
-	 * We dynamically specify only the mask for LINKINITCMD
-	 * and only the shift for LINKCMD and MAXPKTLEN, as they are
-	 * the only ones that change.
-	 */
-	dd->ibcc_lic_mask = IBA7220_IBCC_LINKINITCMD_MASK;
-	dd->ibcc_lc_shift = IBA7220_IBCC_LINKCMD_SHIFT;
-	dd->ibcc_mpl_shift = IBA7220_IBCC_MAXPKTLEN_SHIFT;
-
-	/* Fill in shifts for RcvCtrl. */
-	dd->ipath_r_portenable_shift = INFINIPATH_R_PORTENABLE_SHIFT;
-	dd->ipath_r_intravail_shift = IBA7220_R_INTRAVAIL_SHIFT;
-	dd->ipath_r_tailupd_shift = IBA7220_R_TAILUPD_SHIFT;
-	dd->ipath_r_portcfg_shift = IBA7220_R_PORTCFG_SHIFT;
-
-	/* variables for sanity checking interrupt and errors */
-	dd->ipath_hwe_bitsextant =
-		(INFINIPATH_HWE_RXEMEMPARITYERR_MASK <<
-		 INFINIPATH_HWE_RXEMEMPARITYERR_SHIFT) |
-		(INFINIPATH_HWE_TXEMEMPARITYERR_MASK <<
-		 INFINIPATH_HWE_TXEMEMPARITYERR_SHIFT) |
-		(INFINIPATH_HWE_PCIEMEMPARITYERR_MASK <<
-		 INFINIPATH_HWE_PCIEMEMPARITYERR_SHIFT) |
-		INFINIPATH_HWE_PCIE1PLLFAILED |
-		INFINIPATH_HWE_PCIE0PLLFAILED |
-		INFINIPATH_HWE_PCIEPOISONEDTLP |
-		INFINIPATH_HWE_PCIECPLTIMEOUT |
-		INFINIPATH_HWE_PCIEBUSPARITYXTLH |
-		INFINIPATH_HWE_PCIEBUSPARITYXADM |
-		INFINIPATH_HWE_PCIEBUSPARITYRADM |
-		INFINIPATH_HWE_MEMBISTFAILED |
-		INFINIPATH_HWE_COREPLL_FBSLIP |
-		INFINIPATH_HWE_COREPLL_RFSLIP |
-		INFINIPATH_HWE_SERDESPLLFAILED |
-		INFINIPATH_HWE_IBCBUSTOSPCPARITYERR |
-		INFINIPATH_HWE_IBCBUSFRSPCPARITYERR |
-		INFINIPATH_HWE_PCIECPLDATAQUEUEERR |
-		INFINIPATH_HWE_PCIECPLHDRQUEUEERR |
-		INFINIPATH_HWE_SDMAMEMREADERR |
-		INFINIPATH_HWE_CLK_UC_PLLNOTLOCKED |
-		INFINIPATH_HWE_PCIESERDESQ0PCLKNOTDETECT |
-		INFINIPATH_HWE_PCIESERDESQ1PCLKNOTDETECT |
-		INFINIPATH_HWE_PCIESERDESQ2PCLKNOTDETECT |
-		INFINIPATH_HWE_PCIESERDESQ3PCLKNOTDETECT |
-		INFINIPATH_HWE_DDSRXEQMEMORYPARITYERR |
-		INFINIPATH_HWE_IB_UC_MEMORYPARITYERR |
-		INFINIPATH_HWE_PCIE_UC_OCT0MEMORYPARITYERR |
-		INFINIPATH_HWE_PCIE_UC_OCT1MEMORYPARITYERR;
-	dd->ipath_i_bitsextant =
-		INFINIPATH_I_SDMAINT | INFINIPATH_I_SDMADISABLED |
-		(INFINIPATH_I_RCVURG_MASK << INFINIPATH_I_RCVURG_SHIFT) |
-		(INFINIPATH_I_RCVAVAIL_MASK <<
-		 INFINIPATH_I_RCVAVAIL_SHIFT) |
-		INFINIPATH_I_ERROR | INFINIPATH_I_SPIOSENT |
-		INFINIPATH_I_SPIOBUFAVAIL | INFINIPATH_I_GPIO |
-		INFINIPATH_I_JINT | INFINIPATH_I_SERDESTRIMDONE;
-	dd->ipath_e_bitsextant =
-		INFINIPATH_E_RFORMATERR | INFINIPATH_E_RVCRC |
-		INFINIPATH_E_RICRC | INFINIPATH_E_RMINPKTLEN |
-		INFINIPATH_E_RMAXPKTLEN | INFINIPATH_E_RLONGPKTLEN |
-		INFINIPATH_E_RSHORTPKTLEN | INFINIPATH_E_RUNEXPCHAR |
-		INFINIPATH_E_RUNSUPVL | INFINIPATH_E_REBP |
-		INFINIPATH_E_RIBFLOW | INFINIPATH_E_RBADVERSION |
-		INFINIPATH_E_RRCVEGRFULL | INFINIPATH_E_RRCVHDRFULL |
-		INFINIPATH_E_RBADTID | INFINIPATH_E_RHDRLEN |
-		INFINIPATH_E_RHDR | INFINIPATH_E_RIBLOSTLINK |
-		INFINIPATH_E_SENDSPECIALTRIGGER |
-		INFINIPATH_E_SDMADISABLED | INFINIPATH_E_SMINPKTLEN |
-		INFINIPATH_E_SMAXPKTLEN | INFINIPATH_E_SUNDERRUN |
-		INFINIPATH_E_SPKTLEN | INFINIPATH_E_SDROPPEDSMPPKT |
-		INFINIPATH_E_SDROPPEDDATAPKT |
-		INFINIPATH_E_SPIOARMLAUNCH | INFINIPATH_E_SUNEXPERRPKTNUM |
-		INFINIPATH_E_SUNSUPVL | INFINIPATH_E_SENDBUFMISUSE |
-		INFINIPATH_E_SDMAGENMISMATCH | INFINIPATH_E_SDMAOUTOFBOUND |
-		INFINIPATH_E_SDMATAILOUTOFBOUND | INFINIPATH_E_SDMABASE |
-		INFINIPATH_E_SDMA1STDESC | INFINIPATH_E_SDMARPYTAG |
-		INFINIPATH_E_SDMADWEN | INFINIPATH_E_SDMAMISSINGDW |
-		INFINIPATH_E_SDMAUNEXPDATA |
-		INFINIPATH_E_IBSTATUSCHANGED | INFINIPATH_E_INVALIDADDR |
-		INFINIPATH_E_RESET | INFINIPATH_E_HARDWARE |
-		INFINIPATH_E_SDMADESCADDRMISALIGN |
-		INFINIPATH_E_INVALIDEEPCMD;
-
-	dd->ipath_i_rcvavail_mask = INFINIPATH_I_RCVAVAIL_MASK;
-	dd->ipath_i_rcvurg_mask = INFINIPATH_I_RCVURG_MASK;
-	dd->ipath_i_rcvavail_shift = INFINIPATH_I_RCVAVAIL_SHIFT;
-	dd->ipath_i_rcvurg_shift = INFINIPATH_I_RCVURG_SHIFT;
-	dd->ipath_flags |= IPATH_INTREG_64 | IPATH_HAS_MULT_IB_SPEED
-		| IPATH_HAS_LINK_LATENCY;
-
-	/*
-	 * EEPROM error log 0 is TXE Parity errors. 1 is RXE Parity.
-	 * 2 is Some Misc, 3 is reserved for future.
-	 */
-	dd->ipath_eep_st_masks[0].hwerrs_to_log =
-		INFINIPATH_HWE_TXEMEMPARITYERR_MASK <<
-		INFINIPATH_HWE_TXEMEMPARITYERR_SHIFT;
-
-	dd->ipath_eep_st_masks[1].hwerrs_to_log =
-		INFINIPATH_HWE_RXEMEMPARITYERR_MASK <<
-		INFINIPATH_HWE_RXEMEMPARITYERR_SHIFT;
-
-	dd->ipath_eep_st_masks[2].errs_to_log = INFINIPATH_E_RESET;
-
-	ipath_linkrecovery = 0;
-
-	init_waitqueue_head(&dd->ipath_autoneg_wait);
-	INIT_DELAYED_WORK(&dd->ipath_autoneg_work,  autoneg_work);
-
-	dd->ipath_link_width_supported = IB_WIDTH_1X | IB_WIDTH_4X;
-	dd->ipath_link_speed_supported = IPATH_IB_SDR | IPATH_IB_DDR;
-
-	dd->ipath_link_width_enabled = dd->ipath_link_width_supported;
-	dd->ipath_link_speed_enabled = dd->ipath_link_speed_supported;
-	/*
-	 * set the initial values to reasonable default, will be set
-	 * for real when link is up.
-	 */
-	dd->ipath_link_width_active = IB_WIDTH_4X;
-	dd->ipath_link_speed_active = IPATH_IB_SDR;
-	dd->delay_mult = rate_to_delay[0][1];
-}
-
-
-/*
- * Setup the MSI stuff again after a reset.  I'd like to just call
- * pci_enable_msi() and request_irq() again, but when I do that,
- * the MSI enable bit doesn't get set in the command word, and
- * we switch to to a different interrupt vector, which is confusing,
- * so I instead just do it all inline.  Perhaps somehow can tie this
- * into the PCIe hotplug support at some point
- * Note, because I'm doing it all here, I don't call pci_disable_msi()
- * or free_irq() at the start of ipath_setup_7220_reset().
- */
-static int ipath_reinit_msi(struct ipath_devdata *dd)
-{
-	int ret = 0;
-
-	int pos;
-	u16 control;
-	if (!dd->ipath_msi_lo) /* Using intX, or init problem */
-		goto bail;
-
-	pos = pci_find_capability(dd->pcidev, PCI_CAP_ID_MSI);
-	if (!pos) {
-		ipath_dev_err(dd, "Can't find MSI capability, "
-			      "can't restore MSI settings\n");
-		goto bail;
-	}
-	ipath_cdbg(VERBOSE, "Writing msi_lo 0x%x to config offset 0x%x\n",
-		   dd->ipath_msi_lo, pos + PCI_MSI_ADDRESS_LO);
-	pci_write_config_dword(dd->pcidev, pos + PCI_MSI_ADDRESS_LO,
-			       dd->ipath_msi_lo);
-	ipath_cdbg(VERBOSE, "Writing msi_lo 0x%x to config offset 0x%x\n",
-		   dd->ipath_msi_hi, pos + PCI_MSI_ADDRESS_HI);
-	pci_write_config_dword(dd->pcidev, pos + PCI_MSI_ADDRESS_HI,
-			       dd->ipath_msi_hi);
-	pci_read_config_word(dd->pcidev, pos + PCI_MSI_FLAGS, &control);
-	if (!(control & PCI_MSI_FLAGS_ENABLE)) {
-		ipath_cdbg(VERBOSE, "MSI control at off %x was %x, "
-			   "setting MSI enable (%x)\n", pos + PCI_MSI_FLAGS,
-			   control, control | PCI_MSI_FLAGS_ENABLE);
-		control |= PCI_MSI_FLAGS_ENABLE;
-		pci_write_config_word(dd->pcidev, pos + PCI_MSI_FLAGS,
-				      control);
-	}
-	/* now rewrite the data (vector) info */
-	pci_write_config_word(dd->pcidev, pos +
-			      ((control & PCI_MSI_FLAGS_64BIT) ? 12 : 8),
-			      dd->ipath_msi_data);
-	ret = 1;
-
-bail:
-	if (!ret) {
-		ipath_dbg("Using INTx, MSI disabled or not configured\n");
-		ipath_enable_intx(dd->pcidev);
-		ret = 1;
-	}
-	/*
-	 * We restore the cachelinesize also, although it doesn't really
-	 * matter.
-	 */
-	pci_write_config_byte(dd->pcidev, PCI_CACHE_LINE_SIZE,
-			      dd->ipath_pci_cacheline);
-	/* and now set the pci master bit again */
-	pci_set_master(dd->pcidev);
-
-	return ret;
-}
-
-/*
- * This routine sleeps, so it can only be called from user context, not
- * from interrupt context.  If we need interrupt context, we can split
- * it into two routines.
- */
-static int ipath_setup_7220_reset(struct ipath_devdata *dd)
-{
-	u64 val;
-	int i;
-	int ret;
-	u16 cmdval;
-
-	pci_read_config_word(dd->pcidev, PCI_COMMAND, &cmdval);
-
-	/* Use dev_err so it shows up in logs, etc. */
-	ipath_dev_err(dd, "Resetting InfiniPath unit %u\n", dd->ipath_unit);
-
-	/* keep chip from being accessed in a few places */
-	dd->ipath_flags &= ~(IPATH_INITTED | IPATH_PRESENT);
-	val = dd->ipath_control | INFINIPATH_C_RESET;
-	ipath_write_kreg(dd, dd->ipath_kregs->kr_control, val);
-	mb();
-
-	for (i = 1; i <= 5; i++) {
-		int r;
-
-		/*
-		 * Allow MBIST, etc. to complete; longer on each retry.
-		 * We sometimes get machine checks from bus timeout if no
-		 * response, so for now, make it *really* long.
-		 */
-		msleep(1000 + (1 + i) * 2000);
-		r = pci_write_config_dword(dd->pcidev, PCI_BASE_ADDRESS_0,
-					   dd->ipath_pcibar0);
-		if (r)
-			ipath_dev_err(dd, "rewrite of BAR0 failed: %d\n", r);
-		r = pci_write_config_dword(dd->pcidev, PCI_BASE_ADDRESS_1,
-					   dd->ipath_pcibar1);
-		if (r)
-			ipath_dev_err(dd, "rewrite of BAR1 failed: %d\n", r);
-		/* now re-enable memory access */
-		pci_write_config_word(dd->pcidev, PCI_COMMAND, cmdval);
-		r = pci_enable_device(dd->pcidev);
-		if (r)
-			ipath_dev_err(dd, "pci_enable_device failed after "
-				      "reset: %d\n", r);
-		/*
-		 * whether it fully enabled or not, mark as present,
-		 * again (but not INITTED)
-		 */
-		dd->ipath_flags |= IPATH_PRESENT;
-		val = ipath_read_kreg64(dd, dd->ipath_kregs->kr_revision);
-		if (val == dd->ipath_revision) {
-			ipath_cdbg(VERBOSE, "Got matching revision "
-				   "register %llx on try %d\n",
-				   (unsigned long long) val, i);
-			ret = ipath_reinit_msi(dd);
-			goto bail;
-		}
-		/* Probably getting -1 back */
-		ipath_dbg("Didn't get expected revision register, "
-			  "got %llx, try %d\n", (unsigned long long) val,
-			  i + 1);
-	}
-	ret = 0; /* failed */
-
-bail:
-	if (ret)
-		ipath_7220_pcie_params(dd, dd->ipath_boardrev);
-
-	return ret;
-}
-
-/**
- * ipath_7220_put_tid - write a TID to the chip
- * @dd: the infinipath device
- * @tidptr: pointer to the expected TID (in chip) to udpate
- * @tidtype: 0 for eager, 1 for expected
- * @pa: physical address of in memory buffer; ipath_tidinvalid if freeing
- *
- * This exists as a separate routine to allow for selection of the
- * appropriate "flavor". The static calls in cleanup just use the
- * revision-agnostic form, as they are not performance critical.
- */
-static void ipath_7220_put_tid(struct ipath_devdata *dd, u64 __iomem *tidptr,
-			     u32 type, unsigned long pa)
-{
-	if (pa != dd->ipath_tidinvalid) {
-		u64 chippa = pa >> IBA7220_TID_PA_SHIFT;
-
-		/* paranoia checks */
-		if (pa != (chippa << IBA7220_TID_PA_SHIFT)) {
-			dev_info(&dd->pcidev->dev, "BUG: physaddr %lx "
-				 "not 2KB aligned!\n", pa);
-			return;
-		}
-		if (chippa >= (1UL << IBA7220_TID_SZ_SHIFT)) {
-			ipath_dev_err(dd,
-				      "BUG: Physical page address 0x%lx "
-				      "larger than supported\n", pa);
-			return;
-		}
-
-		if (type == RCVHQ_RCV_TYPE_EAGER)
-			chippa |= dd->ipath_tidtemplate;
-		else /* for now, always full 4KB page */
-			chippa |= IBA7220_TID_SZ_4K;
-		writeq(chippa, tidptr);
-	} else
-		writeq(pa, tidptr);
-	mmiowb();
-}
-
-/**
- * ipath_7220_clear_tid - clear all TID entries for a port, expected and eager
- * @dd: the infinipath device
- * @port: the port
- *
- * clear all TID entries for a port, expected and eager.
- * Used from ipath_close().  On this chip, TIDs are only 32 bits,
- * not 64, but they are still on 64 bit boundaries, so tidbase
- * is declared as u64 * for the pointer math, even though we write 32 bits
- */
-static void ipath_7220_clear_tids(struct ipath_devdata *dd, unsigned port)
-{
-	u64 __iomem *tidbase;
-	unsigned long tidinv;
-	int i;
-
-	if (!dd->ipath_kregbase)
-		return;
-
-	ipath_cdbg(VERBOSE, "Invalidate TIDs for port %u\n", port);
-
-	tidinv = dd->ipath_tidinvalid;
-	tidbase = (u64 __iomem *)
-		((char __iomem *)(dd->ipath_kregbase) +
-		 dd->ipath_rcvtidbase +
-		 port * dd->ipath_rcvtidcnt * sizeof(*tidbase));
-
-	for (i = 0; i < dd->ipath_rcvtidcnt; i++)
-		ipath_7220_put_tid(dd, &tidbase[i], RCVHQ_RCV_TYPE_EXPECTED,
-				   tidinv);
-
-	tidbase = (u64 __iomem *)
-		((char __iomem *)(dd->ipath_kregbase) +
-		 dd->ipath_rcvegrbase + port_egrtid_idx(dd, port)
-		 * sizeof(*tidbase));
-
-	for (i = port ? dd->ipath_rcvegrcnt : dd->ipath_p0_rcvegrcnt; i; i--)
-		ipath_7220_put_tid(dd, &tidbase[i-1], RCVHQ_RCV_TYPE_EAGER,
-			tidinv);
-}
-
-/**
- * ipath_7220_tidtemplate - setup constants for TID updates
- * @dd: the infinipath device
- *
- * We setup stuff that we use a lot, to avoid calculating each time
- */
-static void ipath_7220_tidtemplate(struct ipath_devdata *dd)
-{
-	/* For now, we always allocate 4KB buffers (at init) so we can
-	 * receive max size packets.  We may want a module parameter to
-	 * specify 2KB or 4KB and/or make be per port instead of per device
-	 * for those who want to reduce memory footprint.  Note that the
-	 * ipath_rcvhdrentsize size must be large enough to hold the largest
-	 * IB header (currently 96 bytes) that we expect to handle (plus of
-	 * course the 2 dwords of RHF).
-	 */
-	if (dd->ipath_rcvegrbufsize == 2048)
-		dd->ipath_tidtemplate = IBA7220_TID_SZ_2K;
-	else if (dd->ipath_rcvegrbufsize == 4096)
-		dd->ipath_tidtemplate = IBA7220_TID_SZ_4K;
-	else {
-		dev_info(&dd->pcidev->dev, "BUG: unsupported egrbufsize "
-			 "%u, using %u\n", dd->ipath_rcvegrbufsize,
-			 4096);
-		dd->ipath_tidtemplate = IBA7220_TID_SZ_4K;
-	}
-	dd->ipath_tidinvalid = 0;
-}
-
-static int ipath_7220_early_init(struct ipath_devdata *dd)
-{
-	u32 i, s;
-
-	if (strcmp(int_type, "auto") &&
-	    strcmp(int_type, "force_msi") &&
-	    strcmp(int_type, "force_intx")) {
-		ipath_dev_err(dd, "Invalid interrupt_type: '%s', expecting "
-			      "auto, force_msi or force_intx\n", int_type);
-		return -EINVAL;
-	}
-
-	/*
-	 * Control[4] has been added to change the arbitration within
-	 * the SDMA engine between favoring data fetches over descriptor
-	 * fetches.  ipath_sdma_fetch_arb==0 gives data fetches priority.
-	 */
-	if (ipath_sdma_fetch_arb && (dd->ipath_minrev > 1))
-		dd->ipath_control |= 1<<4;
-
-	dd->ipath_flags |= IPATH_4BYTE_TID;
-
-	/*
-	 * For openfabrics, we need to be able to handle an IB header of
-	 * 24 dwords.  HT chip has arbitrary sized receive buffers, so we
-	 * made them the same size as the PIO buffers.  This chip does not
-	 * handle arbitrary size buffers, so we need the header large enough
-	 * to handle largest IB header, but still have room for a 2KB MTU
-	 * standard IB packet.
-	 */
-	dd->ipath_rcvhdrentsize = 24;
-	dd->ipath_rcvhdrsize = IPATH_DFLT_RCVHDRSIZE;
-	dd->ipath_rhf_offset =
-		dd->ipath_rcvhdrentsize - sizeof(u64) / sizeof(u32);
-
-	dd->ipath_rcvegrbufsize = ipath_mtu4096 ? 4096 : 2048;
-	/*
-	 * the min() check here is currently a nop, but it may not always
-	 * be, depending on just how we do ipath_rcvegrbufsize
-	 */
-	dd->ipath_ibmaxlen = min(ipath_mtu4096 ? dd->ipath_piosize4k :
-				 dd->ipath_piosize2k,
-				 dd->ipath_rcvegrbufsize +
-				 (dd->ipath_rcvhdrentsize << 2));
-	dd->ipath_init_ibmaxlen = dd->ipath_ibmaxlen;
-
-	ipath_7220_config_jint(dd, INFINIPATH_JINT_DEFAULT_IDLE_TICKS,
-			       INFINIPATH_JINT_DEFAULT_MAX_PACKETS);
-
-	if (dd->ipath_boardrev) /* no eeprom on emulator */
-		ipath_get_eeprom_info(dd);
-
-	/* start of code to check and print procmon */
-	s = ipath_read_kreg32(dd, IPATH_KREG_OFFSET(ProcMon));
-	s &= ~(1U<<31); /* clear done bit */
-	s |= 1U<<14; /* clear counter (write 1 to clear) */
-	ipath_write_kreg(dd, IPATH_KREG_OFFSET(ProcMon), s);
-	/* make sure clear_counter low long enough before start */
-	ipath_read_kreg32(dd, dd->ipath_kregs->kr_scratch);
-	ipath_read_kreg32(dd, dd->ipath_kregs->kr_scratch);
-
-	s &= ~(1U<<14); /* allow counter to count (before starting) */
-	ipath_write_kreg(dd, IPATH_KREG_OFFSET(ProcMon), s);
-	ipath_read_kreg32(dd, dd->ipath_kregs->kr_scratch);
-	ipath_read_kreg32(dd, dd->ipath_kregs->kr_scratch);
-	s = ipath_read_kreg32(dd, IPATH_KREG_OFFSET(ProcMon));
-
-	s |= 1U<<15; /* start the counter */
-	s &= ~(1U<<31); /* clear done bit */
-	s &= ~0x7ffU; /* clear frequency bits */
-	s |= 0xe29; /* set frequency bits, in case cleared */
-	ipath_write_kreg(dd, IPATH_KREG_OFFSET(ProcMon), s);
-
-	s = 0;
-	for (i = 500; i > 0 && !(s&(1ULL<<31)); i--) {
-		ipath_read_kreg32(dd, dd->ipath_kregs->kr_scratch);
-		s = ipath_read_kreg32(dd, IPATH_KREG_OFFSET(ProcMon));
-	}
-	if (!(s&(1U<<31)))
-		ipath_dev_err(dd, "ProcMon register not valid: 0x%x\n", s);
-	else
-		ipath_dbg("ProcMon=0x%x, count=0x%x\n", s, (s>>16)&0x1ff);
-
-	return 0;
-}
-
-/**
- * ipath_init_7220_get_base_info - set chip-specific flags for user code
- * @pd: the infinipath port
- * @kbase: ipath_base_info pointer
- *
- * We set the PCIE flag because the lower bandwidth on PCIe vs
- * HyperTransport can affect some user packet algorithims.
- */
-static int ipath_7220_get_base_info(struct ipath_portdata *pd, void *kbase)
-{
-	struct ipath_base_info *kinfo = kbase;
-
-	kinfo->spi_runtime_flags |=
-		IPATH_RUNTIME_PCIE | IPATH_RUNTIME_NODMA_RTAIL |
-		IPATH_RUNTIME_SDMA;
-
-	return 0;
-}
-
-static void ipath_7220_free_irq(struct ipath_devdata *dd)
-{
-	free_irq(dd->ipath_irq, dd);
-	dd->ipath_irq = 0;
-}
-
-static struct ipath_message_header *
-ipath_7220_get_msgheader(struct ipath_devdata *dd, __le32 *rhf_addr)
-{
-	u32 offset = ipath_hdrget_offset(rhf_addr);
-
-	return (struct ipath_message_header *)
-		(rhf_addr - dd->ipath_rhf_offset + offset);
-}
-
-static void ipath_7220_config_ports(struct ipath_devdata *dd, ushort cfgports)
-{
-	u32 nchipports;
-
-	nchipports = ipath_read_kreg32(dd, dd->ipath_kregs->kr_portcnt);
-	if (!cfgports) {
-		int ncpus = num_online_cpus();
-
-		if (ncpus <= 4)
-			dd->ipath_portcnt = 5;
-		else if (ncpus <= 8)
-			dd->ipath_portcnt = 9;
-		if (dd->ipath_portcnt)
-			ipath_dbg("Auto-configured for %u ports, %d cpus "
-				"online\n", dd->ipath_portcnt, ncpus);
-	} else if (cfgports <= nchipports)
-		dd->ipath_portcnt = cfgports;
-	if (!dd->ipath_portcnt) /* none of the above, set to max */
-		dd->ipath_portcnt = nchipports;
-	/*
-	 * chip can be configured for 5, 9, or 17 ports, and choice
-	 * affects number of eager TIDs per port (1K, 2K, 4K).
-	 */
-	if (dd->ipath_portcnt > 9)
-		dd->ipath_rcvctrl |= 2ULL << IBA7220_R_PORTCFG_SHIFT;
-	else if (dd->ipath_portcnt > 5)
-		dd->ipath_rcvctrl |= 1ULL << IBA7220_R_PORTCFG_SHIFT;
-	/* else configure for default 5 receive ports */
-	ipath_write_kreg(dd, dd->ipath_kregs->kr_rcvctrl,
-			 dd->ipath_rcvctrl);
-	dd->ipath_p0_rcvegrcnt = 2048; /* always */
-	if (dd->ipath_flags & IPATH_HAS_SEND_DMA)
-		dd->ipath_pioreserved = 3; /* kpiobufs used for PIO */
-}
-
-
-static int ipath_7220_get_ib_cfg(struct ipath_devdata *dd, int which)
-{
-	int lsb, ret = 0;
-	u64 maskr; /* right-justified mask */
-
-	switch (which) {
-	case IPATH_IB_CFG_HRTBT: /* Get Heartbeat off/enable/auto */
-		lsb = IBA7220_IBC_HRTBT_SHIFT;
-		maskr = IBA7220_IBC_HRTBT_MASK;
-		break;
-
-	case IPATH_IB_CFG_LWID_ENB: /* Get allowed Link-width */
-		ret = dd->ipath_link_width_enabled;
-		goto done;
-
-	case IPATH_IB_CFG_LWID: /* Get currently active Link-width */
-		ret = dd->ipath_link_width_active;
-		goto done;
-
-	case IPATH_IB_CFG_SPD_ENB: /* Get allowed Link speeds */
-		ret = dd->ipath_link_speed_enabled;
-		goto done;
-
-	case IPATH_IB_CFG_SPD: /* Get current Link spd */
-		ret = dd->ipath_link_speed_active;
-		goto done;
-
-	case IPATH_IB_CFG_RXPOL_ENB: /* Get Auto-RX-polarity enable */
-		lsb = IBA7220_IBC_RXPOL_SHIFT;
-		maskr = IBA7220_IBC_RXPOL_MASK;
-		break;
-
-	case IPATH_IB_CFG_LREV_ENB: /* Get Auto-Lane-reversal enable */
-		lsb = IBA7220_IBC_LREV_SHIFT;
-		maskr = IBA7220_IBC_LREV_MASK;
-		break;
-
-	case IPATH_IB_CFG_LINKLATENCY:
-		ret = ipath_read_kreg64(dd, dd->ipath_kregs->kr_ibcddrstatus)
-			& IBA7220_DDRSTAT_LINKLAT_MASK;
-		goto done;
-
-	default:
-		ret = -ENOTSUPP;
-		goto done;
-	}
-	ret = (int)((dd->ipath_ibcddrctrl >> lsb) & maskr);
-done:
-	return ret;
-}
-
-static int ipath_7220_set_ib_cfg(struct ipath_devdata *dd, int which, u32 val)
-{
-	int lsb, ret = 0, setforce = 0;
-	u64 maskr; /* right-justified mask */
-
-	switch (which) {
-	case IPATH_IB_CFG_LIDLMC:
-		/*
-		 * Set LID and LMC. Combined to avoid possible hazard
-		 * caller puts LMC in 16MSbits, DLID in 16LSbits of val
-		 */
-		lsb = IBA7220_IBC_DLIDLMC_SHIFT;
-		maskr = IBA7220_IBC_DLIDLMC_MASK;
-		break;
-
-	case IPATH_IB_CFG_HRTBT: /* set Heartbeat off/enable/auto */
-		if (val & IPATH_IB_HRTBT_ON &&
-			(dd->ipath_flags & IPATH_NO_HRTBT))
-			goto bail;
-		lsb = IBA7220_IBC_HRTBT_SHIFT;
-		maskr = IBA7220_IBC_HRTBT_MASK;
-		break;
-
-	case IPATH_IB_CFG_LWID_ENB: /* set allowed Link-width */
-		/*
-		 * As with speed, only write the actual register if
-		 * the link is currently down, otherwise takes effect
-		 * on next link change.
-		 */
-		dd->ipath_link_width_enabled = val;
-		if ((dd->ipath_flags & (IPATH_LINKDOWN|IPATH_LINKINIT)) !=
-			IPATH_LINKDOWN)
-			goto bail;
-		/*
-		 * We set the IPATH_IB_FORCE_NOTIFY bit so updown
-		 * will get called because we want update
-		 * link_width_active, and the change may not take
-		 * effect for some time (if we are in POLL), so this
-		 * flag will force the updown routine to be called
-		 * on the next ibstatuschange down interrupt, even
-		 * if it's not an down->up transition.
-		 */
-		val--; /* convert from IB to chip */
-		maskr = IBA7220_IBC_WIDTH_MASK;
-		lsb = IBA7220_IBC_WIDTH_SHIFT;
-		setforce = 1;
-		dd->ipath_flags |= IPATH_IB_FORCE_NOTIFY;
-		break;
-
-	case IPATH_IB_CFG_SPD_ENB: /* set allowed Link speeds */
-		/*
-		 * If we turn off IB1.2, need to preset SerDes defaults,
-		 * but not right now. Set a flag for the next time
-		 * we command the link down.  As with width, only write the
-		 * actual register if the link is currently down, otherwise
-		 * takes effect on next link change.  Since setting is being
-		 * explictly requested (via MAD or sysfs), clear autoneg
-		 * failure status if speed autoneg is enabled.
-		 */
-		dd->ipath_link_speed_enabled = val;
-		if (dd->ipath_ibcddrctrl & IBA7220_IBC_IBTA_1_2_MASK &&
-		    !(val & (val - 1)))
-			dd->ipath_presets_needed = 1;
-		if ((dd->ipath_flags & (IPATH_LINKDOWN|IPATH_LINKINIT)) !=
-			IPATH_LINKDOWN)
-			goto bail;
-		/*
-		 * We set the IPATH_IB_FORCE_NOTIFY bit so updown
-		 * will get called because we want update
-		 * link_speed_active, and the change may not take
-		 * effect for some time (if we are in POLL), so this
-		 * flag will force the updown routine to be called
-		 * on the next ibstatuschange down interrupt, even
-		 * if it's not an down->up transition.  When setting
-		 * speed autoneg, clear AUTONEG_FAILED.
-		 */
-		if (val == (IPATH_IB_SDR | IPATH_IB_DDR)) {
-			val = IBA7220_IBC_SPEED_AUTONEG_MASK |
-				IBA7220_IBC_IBTA_1_2_MASK;
-			dd->ipath_flags &= ~IPATH_IB_AUTONEG_FAILED;
-		} else
-			val = val == IPATH_IB_DDR ?  IBA7220_IBC_SPEED_DDR
-				: IBA7220_IBC_SPEED_SDR;
-		maskr = IBA7220_IBC_SPEED_AUTONEG_MASK |
-			IBA7220_IBC_IBTA_1_2_MASK;
-		lsb = 0; /* speed bits are low bits */
-		setforce = 1;
-		break;
-
-	case IPATH_IB_CFG_RXPOL_ENB: /* set Auto-RX-polarity enable */
-		lsb = IBA7220_IBC_RXPOL_SHIFT;
-		maskr = IBA7220_IBC_RXPOL_MASK;
-		break;
-
-	case IPATH_IB_CFG_LREV_ENB: /* set Auto-Lane-reversal enable */
-		lsb = IBA7220_IBC_LREV_SHIFT;
-		maskr = IBA7220_IBC_LREV_MASK;
-		break;
-
-	default:
-		ret = -ENOTSUPP;
-		goto bail;
-	}
-	dd->ipath_ibcddrctrl &= ~(maskr << lsb);
-	dd->ipath_ibcddrctrl |= (((u64) val & maskr) << lsb);
-	ipath_write_kreg(dd, dd->ipath_kregs->kr_ibcddrctrl,
-			 dd->ipath_ibcddrctrl);
-	if (setforce)
-		dd->ipath_flags |= IPATH_IB_FORCE_NOTIFY;
-bail:
-	return ret;
-}
-
-static void ipath_7220_read_counters(struct ipath_devdata *dd,
-				     struct infinipath_counters *cntrs)
-{
-	u64 *counters = (u64 *) cntrs;
-	int i;
-
-	for (i = 0; i < sizeof(*cntrs) / sizeof(u64); i++)
-		counters[i] = ipath_snap_cntr(dd, i);
-}
-
-/* if we are using MSI, try to fallback to INTx */
-static int ipath_7220_intr_fallback(struct ipath_devdata *dd)
-{
-	if (dd->ipath_msi_lo) {
-		dev_info(&dd->pcidev->dev, "MSI interrupt not detected,"
-			" trying INTx interrupts\n");
-		ipath_7220_nomsi(dd);
-		ipath_enable_intx(dd->pcidev);
-		/*
-		 * some newer kernels require free_irq before disable_msi,
-		 * and irq can be changed during disable and intx enable
-		 * and we need to therefore use the pcidev->irq value,
-		 * not our saved MSI value.
-		 */
-		dd->ipath_irq = dd->pcidev->irq;
-		if (request_irq(dd->ipath_irq, ipath_intr, IRQF_SHARED,
-			IPATH_DRV_NAME, dd))
-			ipath_dev_err(dd,
-				"Could not re-request_irq for INTx\n");
-		return 1;
-	}
-	return 0;
-}
-
-/*
- * reset the XGXS (between serdes and IBC).  Slightly less intrusive
- * than resetting the IBC or external link state, and useful in some
- * cases to cause some retraining.  To do this right, we reset IBC
- * as well.
- */
-static void ipath_7220_xgxs_reset(struct ipath_devdata *dd)
-{
-	u64 val, prev_val;
-
-	prev_val = ipath_read_kreg64(dd, dd->ipath_kregs->kr_xgxsconfig);
-	val = prev_val | INFINIPATH_XGXS_RESET;
-	prev_val &= ~INFINIPATH_XGXS_RESET; /* be sure */
-	ipath_write_kreg(dd, dd->ipath_kregs->kr_control,
-			 dd->ipath_control & ~INFINIPATH_C_LINKENABLE);
-	ipath_write_kreg(dd, dd->ipath_kregs->kr_xgxsconfig, val);
-	ipath_read_kreg32(dd, dd->ipath_kregs->kr_scratch);
-	ipath_write_kreg(dd, dd->ipath_kregs->kr_xgxsconfig, prev_val);
-	ipath_write_kreg(dd, dd->ipath_kregs->kr_control,
-			 dd->ipath_control);
-}
-
-
-/* Still needs cleanup, too much hardwired stuff */
-static void autoneg_send(struct ipath_devdata *dd,
-	u32 *hdr, u32 dcnt, u32 *data)
-{
-	int i;
-	u64 cnt;
-	u32 __iomem *piobuf;
-	u32 pnum;
-
-	i = 0;
-	cnt = 7 + dcnt + 1; /* 7 dword header, dword data, icrc */
-	while (!(piobuf = ipath_getpiobuf(dd, cnt, &pnum))) {
-		if (i++ > 15) {
-			ipath_dbg("Couldn't get pio buffer for send\n");
-			return;
-		}
-		udelay(2);
-	}
-	if (dd->ipath_flags&IPATH_HAS_PBC_CNT)
-		cnt |= 0x80000000UL<<32; /* mark as VL15 */
-	writeq(cnt, piobuf);
-	ipath_flush_wc();
-	__iowrite32_copy(piobuf + 2, hdr, 7);
-	__iowrite32_copy(piobuf + 9, data, dcnt);
-	ipath_flush_wc();
-}
-
-/*
- * _start packet gets sent twice at start, _done gets sent twice at end
- */
-static void ipath_autoneg_send(struct ipath_devdata *dd, int which)
-{
-	static u32 swapped;
-	u32 dw, i, hcnt, dcnt, *data;
-	static u32 hdr[7] = { 0xf002ffff, 0x48ffff, 0x6400abba };
-	static u32 madpayload_start[0x40] = {
-		0x1810103, 0x1, 0x0, 0x0, 0x2c90000, 0x2c9, 0x0, 0x0,
-		0xffffffff, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
-		0x1, 0x1388, 0x15e, 0x1, /* rest 0's */
-		};
-	static u32 madpayload_done[0x40] = {
-		0x1810103, 0x1, 0x0, 0x0, 0x2c90000, 0x2c9, 0x0, 0x0,
-		0xffffffff, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
-		0x40000001, 0x1388, 0x15e, /* rest 0's */
-		};
-	dcnt = ARRAY_SIZE(madpayload_start);
-	hcnt = ARRAY_SIZE(hdr);
-	if (!swapped) {
-		/* for maintainability, do it at runtime */
-		for (i = 0; i < hcnt; i++) {
-			dw = (__force u32) cpu_to_be32(hdr[i]);
-			hdr[i] = dw;
-		}
-		for (i = 0; i < dcnt; i++) {
-			dw = (__force u32) cpu_to_be32(madpayload_start[i]);
-			madpayload_start[i] = dw;
-			dw = (__force u32) cpu_to_be32(madpayload_done[i]);
-			madpayload_done[i] = dw;
-		}
-		swapped = 1;
-	}
-
-	data = which ? madpayload_done : madpayload_start;
-	ipath_cdbg(PKT, "Sending %s special MADs\n", which?"done":"start");
-
-	autoneg_send(dd, hdr, dcnt, data);
-	ipath_read_kreg64(dd, dd->ipath_kregs->kr_scratch);
-	udelay(2);
-	autoneg_send(dd, hdr, dcnt, data);
-	ipath_read_kreg64(dd, dd->ipath_kregs->kr_scratch);
-	udelay(2);
-}
-
-
-
-/*
- * Do the absolute minimum to cause an IB speed change, and make it
- * ready, but don't actually trigger the change.   The caller will
- * do that when ready (if link is in Polling training state, it will
- * happen immediately, otherwise when link next goes down)
- *
- * This routine should only be used as part of the DDR autonegotation
- * code for devices that are not compliant with IB 1.2 (or code that
- * fixes things up for same).
- *
- * When link has gone down, and autoneg enabled, or autoneg has
- * failed and we give up until next time we set both speeds, and
- * then we want IBTA enabled as well as "use max enabled speed.
- */
-static void set_speed_fast(struct ipath_devdata *dd, u32 speed)
-{
-	dd->ipath_ibcddrctrl &= ~(IBA7220_IBC_SPEED_AUTONEG_MASK |
-		IBA7220_IBC_IBTA_1_2_MASK |
-		(IBA7220_IBC_WIDTH_MASK << IBA7220_IBC_WIDTH_SHIFT));
-
-	if (speed == (IPATH_IB_SDR | IPATH_IB_DDR))
-		dd->ipath_ibcddrctrl |= IBA7220_IBC_SPEED_AUTONEG_MASK |
-			IBA7220_IBC_IBTA_1_2_MASK;
-	else
-		dd->ipath_ibcddrctrl |= speed == IPATH_IB_DDR ?
-			IBA7220_IBC_SPEED_DDR : IBA7220_IBC_SPEED_SDR;
-
-	/*
-	 * Convert from IB-style 1 = 1x, 2 = 4x, 3 = auto
-	 * to chip-centric       0 = 1x, 1 = 4x, 2 = auto
-	 */
-	dd->ipath_ibcddrctrl |= (u64)(dd->ipath_link_width_enabled - 1) <<
-		IBA7220_IBC_WIDTH_SHIFT;
-	ipath_write_kreg(dd, dd->ipath_kregs->kr_ibcddrctrl,
-			dd->ipath_ibcddrctrl);
-	ipath_cdbg(VERBOSE, "setup for IB speed (%x) done\n", speed);
-}
-
-
-/*
- * this routine is only used when we are not talking to another
- * IB 1.2-compliant device that we think can do DDR.
- * (This includes all existing switch chips as of Oct 2007.)
- * 1.2-compliant devices go directly to DDR prior to reaching INIT
- */
-static void try_auto_neg(struct ipath_devdata *dd)
-{
-	/*
-	 * required for older non-IB1.2 DDR switches.  Newer
-	 * non-IB-compliant switches don't need it, but so far,
-	 * aren't bothered by it either.  "Magic constant"
-	 */
-	ipath_write_kreg(dd, IPATH_KREG_OFFSET(IBNCModeCtrl),
-		0x3b9dc07);
-	dd->ipath_flags |= IPATH_IB_AUTONEG_INPROG;
-	ipath_autoneg_send(dd, 0);
-	set_speed_fast(dd, IPATH_IB_DDR);
-	ipath_toggle_rclkrls(dd);
-	/* 2 msec is minimum length of a poll cycle */
-	schedule_delayed_work(&dd->ipath_autoneg_work,
-		msecs_to_jiffies(2));
-}
-
-
-static int ipath_7220_ib_updown(struct ipath_devdata *dd, int ibup, u64 ibcs)
-{
-	int ret = 0, symadj = 0;
-	u32 ltstate = ipath_ib_linkstate(dd, ibcs);
-
-	dd->ipath_link_width_active =
-		((ibcs >> IBA7220_IBCS_LINKWIDTH_SHIFT) & 1) ?
-		    IB_WIDTH_4X : IB_WIDTH_1X;
-	dd->ipath_link_speed_active =
-		((ibcs >> IBA7220_IBCS_LINKSPEED_SHIFT) & 1) ?
-		    IPATH_IB_DDR : IPATH_IB_SDR;
-
-	if (!ibup) {
-		/*
-		 * when link goes down we don't want aeq running, so it
-		 * won't't interfere with IBC training, etc., and we need
-		 * to go back to the static SerDes preset values
-		 */
-		if (dd->ipath_x1_fix_tries &&
-			 ltstate <= INFINIPATH_IBCS_LT_STATE_SLEEPQUIET &&
-			ltstate != INFINIPATH_IBCS_LT_STATE_LINKUP)
-			dd->ipath_x1_fix_tries = 0;
-		if (!(dd->ipath_flags & (IPATH_IB_AUTONEG_FAILED |
-			IPATH_IB_AUTONEG_INPROG)))
-			set_speed_fast(dd, dd->ipath_link_speed_enabled);
-		if (!(dd->ipath_flags & IPATH_IB_AUTONEG_INPROG)) {
-			ipath_cdbg(VERBOSE, "Setting RXEQ defaults\n");
-			ipath_sd7220_presets(dd);
-		}
-		/* this might better in ipath_sd7220_presets() */
-		ipath_set_relock_poll(dd, ibup);
-	} else {
-		if (ipath_compat_ddr_negotiate &&
-		    !(dd->ipath_flags & (IPATH_IB_AUTONEG_FAILED |
-			IPATH_IB_AUTONEG_INPROG)) &&
-			dd->ipath_link_speed_active == IPATH_IB_SDR &&
-			(dd->ipath_link_speed_enabled &
-			    (IPATH_IB_DDR | IPATH_IB_SDR)) ==
-			    (IPATH_IB_DDR | IPATH_IB_SDR) &&
-			dd->ipath_autoneg_tries < IPATH_AUTONEG_TRIES) {
-			/* we are SDR, and DDR auto-negotiation enabled */
-			++dd->ipath_autoneg_tries;
-			ipath_dbg("DDR negotiation try, %u/%u\n",
-				dd->ipath_autoneg_tries,
-				IPATH_AUTONEG_TRIES);
-			if (!dd->ibdeltainprog) {
-				dd->ibdeltainprog = 1;
-				dd->ibsymsnap = ipath_read_creg32(dd,
-					dd->ipath_cregs->cr_ibsymbolerrcnt);
-				dd->iblnkerrsnap = ipath_read_creg32(dd,
-					dd->ipath_cregs->cr_iblinkerrrecovcnt);
-			}
-			try_auto_neg(dd);
-			ret = 1; /* no other IB status change processing */
-		} else if ((dd->ipath_flags & IPATH_IB_AUTONEG_INPROG)
-			&& dd->ipath_link_speed_active == IPATH_IB_SDR) {
-			ipath_autoneg_send(dd, 1);
-			set_speed_fast(dd, IPATH_IB_DDR);
-			udelay(2);
-			ipath_toggle_rclkrls(dd);
-			ret = 1; /* no other IB status change processing */
-		} else {
-			if ((dd->ipath_flags & IPATH_IB_AUTONEG_INPROG) &&
-				(dd->ipath_link_speed_active & IPATH_IB_DDR)) {
-				ipath_dbg("Got to INIT with DDR autoneg\n");
-				dd->ipath_flags &= ~(IPATH_IB_AUTONEG_INPROG
-					| IPATH_IB_AUTONEG_FAILED);
-				dd->ipath_autoneg_tries = 0;
-				/* re-enable SDR, for next link down */
-				set_speed_fast(dd,
-					dd->ipath_link_speed_enabled);
-				wake_up(&dd->ipath_autoneg_wait);
-				symadj = 1;
-			} else if (dd->ipath_flags & IPATH_IB_AUTONEG_FAILED) {
-				/*
-				 * clear autoneg failure flag, and do setup
-				 * so we'll try next time link goes down and
-				 * back to INIT (possibly connected to different
-				 * device).
-				 */
-				ipath_dbg("INIT %sDR after autoneg failure\n",
-					(dd->ipath_link_speed_active &
-					  IPATH_IB_DDR) ? "D" : "S");
-				dd->ipath_flags &= ~IPATH_IB_AUTONEG_FAILED;
-				dd->ipath_ibcddrctrl |=
-					IBA7220_IBC_IBTA_1_2_MASK;
-				ipath_write_kreg(dd,
-					IPATH_KREG_OFFSET(IBNCModeCtrl), 0);
-				symadj = 1;
-			}
-		}
-		/*
-		 * if we are in 1X on rev1 only, and are in autoneg width,
-		 * it could be due to an xgxs problem, so if we haven't
-		 * already tried, try twice to get to 4X; if we
-		 * tried, and couldn't, report it, since it will
-		 * probably not be what is desired.
-		 */
-		if (dd->ipath_minrev == 1 &&
-		    (dd->ipath_link_width_enabled & (IB_WIDTH_1X |
-			IB_WIDTH_4X)) == (IB_WIDTH_1X | IB_WIDTH_4X)
-			&& dd->ipath_link_width_active == IB_WIDTH_1X
-			&& dd->ipath_x1_fix_tries < 3) {
-		     if (++dd->ipath_x1_fix_tries == 3) {
-				dev_info(&dd->pcidev->dev,
-					"IB link is in 1X mode\n");
-				if (!(dd->ipath_flags &
-				      IPATH_IB_AUTONEG_INPROG))
-					symadj = 1;
-		     }
-			else {
-				ipath_cdbg(VERBOSE, "IB 1X in "
-					"auto-width, try %u to be "
-					"sure it's really 1X; "
-					"ltstate %u\n",
-					 dd->ipath_x1_fix_tries,
-					 ltstate);
-				dd->ipath_f_xgxs_reset(dd);
-				ret = 1; /* skip other processing */
-			}
-		} else if (!(dd->ipath_flags & IPATH_IB_AUTONEG_INPROG))
-			symadj = 1;
-
-		if (!ret) {
-			dd->delay_mult = rate_to_delay
-			    [(ibcs >> IBA7220_IBCS_LINKSPEED_SHIFT) & 1]
-			    [(ibcs >> IBA7220_IBCS_LINKWIDTH_SHIFT) & 1];
-
-			ipath_set_relock_poll(dd, ibup);
-		}
-	}
-
-	if (symadj) {
-		if (dd->ibdeltainprog) {
-			dd->ibdeltainprog = 0;
-			dd->ibsymdelta += ipath_read_creg32(dd,
-				dd->ipath_cregs->cr_ibsymbolerrcnt) -
-				dd->ibsymsnap;
-			dd->iblnkerrdelta += ipath_read_creg32(dd,
-				dd->ipath_cregs->cr_iblinkerrrecovcnt) -
-				dd->iblnkerrsnap;
-		}
-	} else if (!ibup && !dd->ibdeltainprog
-		   && !(dd->ipath_flags & IPATH_IB_AUTONEG_INPROG)) {
-		dd->ibdeltainprog = 1;
-		dd->ibsymsnap =	ipath_read_creg32(dd,
-				     dd->ipath_cregs->cr_ibsymbolerrcnt);
-		dd->iblnkerrsnap = ipath_read_creg32(dd,
-				     dd->ipath_cregs->cr_iblinkerrrecovcnt);
-	}
-
-	if (!ret)
-		ipath_setup_7220_setextled(dd, ipath_ib_linkstate(dd, ibcs),
-			ltstate);
-	return ret;
-}
-
-
-/*
- * Handle the empirically determined mechanism for auto-negotiation
- * of DDR speed with switches.
- */
-static void autoneg_work(struct work_struct *work)
-{
-	struct ipath_devdata *dd;
-	u64 startms;
-	u32 lastlts, i;
-
-	dd = container_of(work, struct ipath_devdata,
-		ipath_autoneg_work.work);
-
-	startms = jiffies_to_msecs(jiffies);
-
-	/*
-	 * busy wait for this first part, it should be at most a
-	 * few hundred usec, since we scheduled ourselves for 2msec.
-	 */
-	for (i = 0; i < 25; i++) {
-		lastlts = ipath_ib_linktrstate(dd, dd->ipath_lastibcstat);
-		if (lastlts == INFINIPATH_IBCS_LT_STATE_POLLQUIET) {
-			ipath_set_linkstate(dd, IPATH_IB_LINKDOWN_DISABLE);
-			break;
-		}
-		udelay(100);
-	}
-
-	if (!(dd->ipath_flags & IPATH_IB_AUTONEG_INPROG))
-		goto done; /* we got there early or told to stop */
-
-	/* we expect this to timeout */
-	if (wait_event_timeout(dd->ipath_autoneg_wait,
-		!(dd->ipath_flags & IPATH_IB_AUTONEG_INPROG),
-		msecs_to_jiffies(90)))
-		goto done;
-
-	ipath_toggle_rclkrls(dd);
-
-	/* we expect this to timeout */
-	if (wait_event_timeout(dd->ipath_autoneg_wait,
-		!(dd->ipath_flags & IPATH_IB_AUTONEG_INPROG),
-		msecs_to_jiffies(1700)))
-		goto done;
-
-	set_speed_fast(dd, IPATH_IB_SDR);
-	ipath_toggle_rclkrls(dd);
-
-	/*
-	 * wait up to 250 msec for link to train and get to INIT at DDR;
-	 * this should terminate early
-	 */
-	wait_event_timeout(dd->ipath_autoneg_wait,
-		!(dd->ipath_flags & IPATH_IB_AUTONEG_INPROG),
-		msecs_to_jiffies(250));
-done:
-	if (dd->ipath_flags & IPATH_IB_AUTONEG_INPROG) {
-		ipath_dbg("Did not get to DDR INIT (%x) after %Lu msecs\n",
-			ipath_ib_state(dd, dd->ipath_lastibcstat),
-			(unsigned long long) jiffies_to_msecs(jiffies)-startms);
-		dd->ipath_flags &= ~IPATH_IB_AUTONEG_INPROG;
-		if (dd->ipath_autoneg_tries == IPATH_AUTONEG_TRIES) {
-			dd->ipath_flags |= IPATH_IB_AUTONEG_FAILED;
-			ipath_dbg("Giving up on DDR until next IB "
-				"link Down\n");
-			dd->ipath_autoneg_tries = 0;
-		}
-		set_speed_fast(dd, dd->ipath_link_speed_enabled);
-	}
-}
-
-
-/**
- * ipath_init_iba7220_funcs - set up the chip-specific function pointers
- * @dd: the infinipath device
- *
- * This is global, and is called directly at init to set up the
- * chip-specific function pointers for later use.
- */
-void ipath_init_iba7220_funcs(struct ipath_devdata *dd)
-{
-	dd->ipath_f_intrsetup = ipath_7220_intconfig;
-	dd->ipath_f_bus = ipath_setup_7220_config;
-	dd->ipath_f_reset = ipath_setup_7220_reset;
-	dd->ipath_f_get_boardname = ipath_7220_boardname;
-	dd->ipath_f_init_hwerrors = ipath_7220_init_hwerrors;
-	dd->ipath_f_early_init = ipath_7220_early_init;
-	dd->ipath_f_handle_hwerrors = ipath_7220_handle_hwerrors;
-	dd->ipath_f_quiet_serdes = ipath_7220_quiet_serdes;
-	dd->ipath_f_bringup_serdes = ipath_7220_bringup_serdes;
-	dd->ipath_f_clear_tids = ipath_7220_clear_tids;
-	dd->ipath_f_put_tid = ipath_7220_put_tid;
-	dd->ipath_f_cleanup = ipath_setup_7220_cleanup;
-	dd->ipath_f_setextled = ipath_setup_7220_setextled;
-	dd->ipath_f_get_base_info = ipath_7220_get_base_info;
-	dd->ipath_f_free_irq = ipath_7220_free_irq;
-	dd->ipath_f_tidtemplate = ipath_7220_tidtemplate;
-	dd->ipath_f_intr_fallback = ipath_7220_intr_fallback;
-	dd->ipath_f_xgxs_reset = ipath_7220_xgxs_reset;
-	dd->ipath_f_get_ib_cfg = ipath_7220_get_ib_cfg;
-	dd->ipath_f_set_ib_cfg = ipath_7220_set_ib_cfg;
-	dd->ipath_f_config_jint = ipath_7220_config_jint;
-	dd->ipath_f_config_ports = ipath_7220_config_ports;
-	dd->ipath_f_read_counters = ipath_7220_read_counters;
-	dd->ipath_f_get_msgheader = ipath_7220_get_msgheader;
-	dd->ipath_f_ib_updown = ipath_7220_ib_updown;
-
-	/* initialize chip-specific variables */
-	ipath_init_7220_variables(dd);
-}
diff --git a/drivers/infiniband/hw/ipath/ipath_kernel.h b/drivers/infiniband/hw/ipath/ipath_kernel.h
index 6ba4861..cf444f1 100644
--- a/drivers/infiniband/hw/ipath/ipath_kernel.h
+++ b/drivers/infiniband/hw/ipath/ipath_kernel.h
@@ -1030,8 +1030,6 @@ void ipath_free_data(struct ipath_portdata *dd);
 u32 __iomem *ipath_getpiobuf(struct ipath_devdata *, u32, u32 *);
 void ipath_chg_pioavailkernel(struct ipath_devdata *dd, unsigned start,
 				unsigned len, int avail);
-void ipath_init_iba7220_funcs(struct ipath_devdata *);
-void ipath_init_iba6120_funcs(struct ipath_devdata *);
 void ipath_init_iba6110_funcs(struct ipath_devdata *);
 void ipath_get_eeprom_info(struct ipath_devdata *);
 int ipath_update_eeprom_log(struct ipath_devdata *dd);
diff --git a/drivers/infiniband/hw/ipath/ipath_sd7220.c b/drivers/infiniband/hw/ipath/ipath_sd7220.c
deleted file mode 100644
index aa47eb5..0000000
--- a/drivers/infiniband/hw/ipath/ipath_sd7220.c
+++ /dev/null
@@ -1,1462 +0,0 @@
-/*
- * Copyright (c) 2006, 2007, 2008 QLogic Corporation. All rights reserved.
- * Copyright (c) 2003, 2004, 2005, 2006 PathScale, Inc. All rights reserved.
- *
- * This software is available to you under a choice of one of two
- * licenses.  You may choose to be licensed under the terms of the GNU
- * General Public License (GPL) Version 2, available from the file
- * COPYING in the main directory of this source tree, or the
- * OpenIB.org BSD license below:
- *
- *     Redistribution and use in source and binary forms, with or
- *     without modification, are permitted provided that the following
- *     conditions are met:
- *
- *      - Redistributions of source code must retain the above
- *        copyright notice, this list of conditions and the following
- *        disclaimer.
- *
- *      - Redistributions in binary form must reproduce the above
- *        copyright notice, this list of conditions and the following
- *        disclaimer in the documentation and/or other materials
- *        provided with the distribution.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
- * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
- * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
- * SOFTWARE.
- */
-/*
- * This file contains all of the code that is specific to the SerDes
- * on the InfiniPath 7220 chip.
- */
-
-#include <linux/pci.h>
-#include <linux/delay.h>
-
-#include "ipath_kernel.h"
-#include "ipath_registers.h"
-#include "ipath_7220.h"
-
-/*
- * The IBSerDesMappTable is a memory that holds values to be stored in
- * various SerDes registers by IBC. It is not part of the normal kregs
- * map and is used in exactly one place, hence the #define below.
- */
-#define KR_IBSerDesMappTable (0x94000 / (sizeof(uint64_t)))
-
-/*
- * Below used for sdnum parameter, selecting one of the two sections
- * used for PCIe, or the single SerDes used for IB.
- */
-#define PCIE_SERDES0 0
-#define PCIE_SERDES1 1
-
-/*
- * The EPB requires addressing in a particular form. EPB_LOC() is intended
- * to make #definitions a little more readable.
- */
-#define EPB_ADDR_SHF 8
-#define EPB_LOC(chn, elt, reg) \
-	(((elt & 0xf) | ((chn & 7) << 4) | ((reg & 0x3f) << 9)) << \
-	 EPB_ADDR_SHF)
-#define EPB_IB_QUAD0_CS_SHF (25)
-#define EPB_IB_QUAD0_CS (1U <<  EPB_IB_QUAD0_CS_SHF)
-#define EPB_IB_UC_CS_SHF (26)
-#define EPB_PCIE_UC_CS_SHF (27)
-#define EPB_GLOBAL_WR (1U << (EPB_ADDR_SHF + 8))
-
-/* Forward declarations. */
-static int ipath_sd7220_reg_mod(struct ipath_devdata *dd, int sdnum, u32 loc,
-				u32 data, u32 mask);
-static int ibsd_mod_allchnls(struct ipath_devdata *dd, int loc, int val,
-			     int mask);
-static int ipath_sd_trimdone_poll(struct ipath_devdata *dd);
-static void ipath_sd_trimdone_monitor(struct ipath_devdata *dd,
-				      const char *where);
-static int ipath_sd_setvals(struct ipath_devdata *dd);
-static int ipath_sd_early(struct ipath_devdata *dd);
-static int ipath_sd_dactrim(struct ipath_devdata *dd);
-/* Set the registers that IBC may muck with to their default "preset" values */
-int ipath_sd7220_presets(struct ipath_devdata *dd);
-static int ipath_internal_presets(struct ipath_devdata *dd);
-/* Tweak the register (CMUCTRL5) that contains the TRIMSELF controls */
-static int ipath_sd_trimself(struct ipath_devdata *dd, int val);
-static int epb_access(struct ipath_devdata *dd, int sdnum, int claim);
-
-void ipath_set_relock_poll(struct ipath_devdata *dd, int ibup);
-
-/*
- * Below keeps track of whether the "once per power-on" initialization has
- * been done, because uC code Version 1.32.17 or higher allows the uC to
- * be reset at will, and Automatic Equalization may require it. So the
- * state of the reset "pin", as reflected in was_reset parameter to
- * ipath_sd7220_init() is no longer valid. Instead, we check for the
- * actual uC code having been loaded.
- */
-static int ipath_ibsd_ucode_loaded(struct ipath_devdata *dd)
-{
-	if (!dd->serdes_first_init_done && (ipath_sd7220_ib_vfy(dd) > 0))
-		dd->serdes_first_init_done = 1;
-	return dd->serdes_first_init_done;
-}
-
-/* repeat #define for local use. "Real" #define is in ipath_iba7220.c */
-#define INFINIPATH_HWE_IB_UC_MEMORYPARITYERR      0x0000004000000000ULL
-#define IB_MPREG5 (EPB_LOC(6, 0, 0xE) | (1L << EPB_IB_UC_CS_SHF))
-#define IB_MPREG6 (EPB_LOC(6, 0, 0xF) | (1U << EPB_IB_UC_CS_SHF))
-#define UC_PAR_CLR_D 8
-#define UC_PAR_CLR_M 0xC
-#define IB_CTRL2(chn) (EPB_LOC(chn, 7, 3) | EPB_IB_QUAD0_CS)
-#define START_EQ1(chan) EPB_LOC(chan, 7, 0x27)
-
-void ipath_sd7220_clr_ibpar(struct ipath_devdata *dd)
-{
-	int ret;
-
-	/* clear, then re-enable parity errs */
-	ret = ipath_sd7220_reg_mod(dd, IB_7220_SERDES, IB_MPREG6,
-		UC_PAR_CLR_D, UC_PAR_CLR_M);
-	if (ret < 0) {
-		ipath_dev_err(dd, "Failed clearing IBSerDes Parity err\n");
-		goto bail;
-	}
-	ret = ipath_sd7220_reg_mod(dd, IB_7220_SERDES, IB_MPREG6, 0,
-		UC_PAR_CLR_M);
-
-	ipath_read_kreg32(dd, dd->ipath_kregs->kr_scratch);
-	udelay(4);
-	ipath_write_kreg(dd, dd->ipath_kregs->kr_hwerrclear,
-		INFINIPATH_HWE_IB_UC_MEMORYPARITYERR);
-	ipath_read_kreg32(dd, dd->ipath_kregs->kr_scratch);
-bail:
-	return;
-}
-
-/*
- * After a reset or other unusual event, the epb interface may need
- * to be re-synchronized, between the host and the uC.
- * returns <0 for failure to resync within IBSD_RESYNC_TRIES (not expected)
- */
-#define IBSD_RESYNC_TRIES 3
-#define IB_PGUDP(chn) (EPB_LOC((chn), 2, 1) | EPB_IB_QUAD0_CS)
-#define IB_CMUDONE(chn) (EPB_LOC((chn), 7, 0xF) | EPB_IB_QUAD0_CS)
-
-static int ipath_resync_ibepb(struct ipath_devdata *dd)
-{
-	int ret, pat, tries, chn;
-	u32 loc;
-
-	ret = -1;
-	chn = 0;
-	for (tries = 0; tries < (4 * IBSD_RESYNC_TRIES); ++tries) {
-		loc = IB_PGUDP(chn);
-		ret = ipath_sd7220_reg_mod(dd, IB_7220_SERDES, loc, 0, 0);
-		if (ret < 0) {
-			ipath_dev_err(dd, "Failed read in resync\n");
-			continue;
-		}
-		if (ret != 0xF0 && ret != 0x55 && tries == 0)
-			ipath_dev_err(dd, "unexpected pattern in resync\n");
-		pat = ret ^ 0xA5; /* alternate F0 and 55 */
-		ret = ipath_sd7220_reg_mod(dd, IB_7220_SERDES, loc, pat, 0xFF);
-		if (ret < 0) {
-			ipath_dev_err(dd, "Failed write in resync\n");
-			continue;
-		}
-		ret = ipath_sd7220_reg_mod(dd, IB_7220_SERDES, loc, 0, 0);
-		if (ret < 0) {
-			ipath_dev_err(dd, "Failed re-read in resync\n");
-			continue;
-		}
-		if (ret != pat) {
-			ipath_dev_err(dd, "Failed compare1 in resync\n");
-			continue;
-		}
-		loc = IB_CMUDONE(chn);
-		ret = ipath_sd7220_reg_mod(dd, IB_7220_SERDES, loc, 0, 0);
-		if (ret < 0) {
-			ipath_dev_err(dd, "Failed CMUDONE rd in resync\n");
-			continue;
-		}
-		if ((ret & 0x70) != ((chn << 4) | 0x40)) {
-			ipath_dev_err(dd, "Bad CMUDONE value %02X, chn %d\n",
-				ret, chn);
-			continue;
-		}
-		if (++chn == 4)
-			break;  /* Success */
-	}
-	ipath_cdbg(VERBOSE, "Resync in %d tries\n", tries);
-	return (ret > 0) ? 0 : ret;
-}
-
-/*
- * Localize the stuff that should be done to change IB uC reset
- * returns <0 for errors.
- */
-static int ipath_ibsd_reset(struct ipath_devdata *dd, int assert_rst)
-{
-	u64 rst_val;
-	int ret = 0;
-	unsigned long flags;
-
-	rst_val = ipath_read_kreg64(dd, dd->ipath_kregs->kr_ibserdesctrl);
-	if (assert_rst) {
-		/*
-		 * Vendor recommends "interrupting" uC before reset, to
-		 * minimize possible glitches.
-		 */
-		spin_lock_irqsave(&dd->ipath_sdepb_lock, flags);
-		epb_access(dd, IB_7220_SERDES, 1);
-		rst_val |= 1ULL;
-		/* Squelch possible parity error from _asserting_ reset */
-		ipath_write_kreg(dd, dd->ipath_kregs->kr_hwerrmask,
-			dd->ipath_hwerrmask &
-			~INFINIPATH_HWE_IB_UC_MEMORYPARITYERR);
-		ipath_write_kreg(dd, dd->ipath_kregs->kr_ibserdesctrl, rst_val);
-		/* flush write, delay to ensure it took effect */
-		ipath_read_kreg32(dd, dd->ipath_kregs->kr_scratch);
-		udelay(2);
-		/* once it's reset, can remove interrupt */
-		epb_access(dd, IB_7220_SERDES, -1);
-		spin_unlock_irqrestore(&dd->ipath_sdepb_lock, flags);
-	} else {
-		/*
-		 * Before we de-assert reset, we need to deal with
-		 * possible glitch on the Parity-error line.
-		 * Suppress it around the reset, both in chip-level
-		 * hwerrmask and in IB uC control reg. uC will allow
-		 * it again during startup.
-		 */
-		u64 val;
-		rst_val &= ~(1ULL);
-		ipath_write_kreg(dd, dd->ipath_kregs->kr_hwerrmask,
-			dd->ipath_hwerrmask &
-			~INFINIPATH_HWE_IB_UC_MEMORYPARITYERR);
-
-		ret = ipath_resync_ibepb(dd);
-		if (ret < 0)
-			ipath_dev_err(dd, "unable to re-sync IB EPB\n");
-
-		/* set uC control regs to suppress parity errs */
-		ret = ipath_sd7220_reg_mod(dd, IB_7220_SERDES, IB_MPREG5, 1, 1);
-		if (ret < 0)
-			goto bail;
-		/* IB uC code past Version 1.32.17 allow suppression of wdog */
-		ret = ipath_sd7220_reg_mod(dd, IB_7220_SERDES, IB_MPREG6, 0x80,
-			0x80);
-		if (ret < 0) {
-			ipath_dev_err(dd, "Failed to set WDOG disable\n");
-			goto bail;
-		}
-		ipath_write_kreg(dd, dd->ipath_kregs->kr_ibserdesctrl, rst_val);
-		/* flush write, delay for startup */
-		ipath_read_kreg32(dd, dd->ipath_kregs->kr_scratch);
-		udelay(1);
-		/* clear, then re-enable parity errs */
-		ipath_sd7220_clr_ibpar(dd);
-		val = ipath_read_kreg64(dd, dd->ipath_kregs->kr_hwerrstatus);
-		if (val & INFINIPATH_HWE_IB_UC_MEMORYPARITYERR) {
-			ipath_dev_err(dd, "IBUC Parity still set after RST\n");
-			dd->ipath_hwerrmask &=
-				~INFINIPATH_HWE_IB_UC_MEMORYPARITYERR;
-		}
-		ipath_write_kreg(dd, dd->ipath_kregs->kr_hwerrmask,
-			dd->ipath_hwerrmask);
-	}
-
-bail:
-	return ret;
-}
-
-static void ipath_sd_trimdone_monitor(struct ipath_devdata *dd,
-       const char *where)
-{
-	int ret, chn, baduns;
-	u64 val;
-
-	if (!where)
-		where = "?";
-
-	/* give time for reset to settle out in EPB */
-	udelay(2);
-
-	ret = ipath_resync_ibepb(dd);
-	if (ret < 0)
-		ipath_dev_err(dd, "not able to re-sync IB EPB (%s)\n", where);
-
-	/* Do "sacrificial read" to get EPB in sane state after reset */
-	ret = ipath_sd7220_reg_mod(dd, IB_7220_SERDES, IB_CTRL2(0), 0, 0);
-	if (ret < 0)
-		ipath_dev_err(dd, "Failed TRIMDONE 1st read, (%s)\n", where);
-
-	/* Check/show "summary" Trim-done bit in IBCStatus */
-	val = ipath_read_kreg64(dd, dd->ipath_kregs->kr_ibcstatus);
-	if (val & (1ULL << 11))
-		ipath_cdbg(VERBOSE, "IBCS TRIMDONE set (%s)\n", where);
-	else
-		ipath_dev_err(dd, "IBCS TRIMDONE clear (%s)\n", where);
-
-	udelay(2);
-
-	ret = ipath_sd7220_reg_mod(dd, IB_7220_SERDES, IB_MPREG6, 0x80, 0x80);
-	if (ret < 0)
-		ipath_dev_err(dd, "Failed Dummy RMW, (%s)\n", where);
-	udelay(10);
-
-	baduns = 0;
-
-	for (chn = 3; chn >= 0; --chn) {
-		/* Read CTRL reg for each channel to check TRIMDONE */
-		ret = ipath_sd7220_reg_mod(dd, IB_7220_SERDES,
-			IB_CTRL2(chn), 0, 0);
-		if (ret < 0)
-			ipath_dev_err(dd, "Failed checking TRIMDONE, chn %d"
-				" (%s)\n", chn, where);
-
-		if (!(ret & 0x10)) {
-			int probe;
-			baduns |= (1 << chn);
-			ipath_dev_err(dd, "TRIMDONE cleared on chn %d (%02X)."
-				" (%s)\n", chn, ret, where);
-			probe = ipath_sd7220_reg_mod(dd, IB_7220_SERDES,
-				IB_PGUDP(0), 0, 0);
-			ipath_dev_err(dd, "probe is %d (%02X)\n",
-				probe, probe);
-			probe = ipath_sd7220_reg_mod(dd, IB_7220_SERDES,
-				IB_CTRL2(chn), 0, 0);
-			ipath_dev_err(dd, "re-read: %d (%02X)\n",
-				probe, probe);
-			ret = ipath_sd7220_reg_mod(dd, IB_7220_SERDES,
-				IB_CTRL2(chn), 0x10, 0x10);
-			if (ret < 0)
-				ipath_dev_err(dd,
-					"Err on TRIMDONE rewrite1\n");
-		}
-	}
-	for (chn = 3; chn >= 0; --chn) {
-		/* Read CTRL reg for each channel to check TRIMDONE */
-		if (baduns & (1 << chn)) {
-			ipath_dev_err(dd,
-				"Reseting TRIMDONE on chn %d (%s)\n",
-				chn, where);
-			ret = ipath_sd7220_reg_mod(dd, IB_7220_SERDES,
-				IB_CTRL2(chn), 0x10, 0x10);
-			if (ret < 0)
-				ipath_dev_err(dd, "Failed re-setting "
-					"TRIMDONE, chn %d (%s)\n",
-					chn, where);
-		}
-	}
-}
-
-/*
- * Below is portion of IBA7220-specific bringup_serdes() that actually
- * deals with registers and memory within the SerDes itself.
- * Post IB uC code version 1.32.17, was_reset being 1 is not really
- * informative, so we double-check.
- */
-int ipath_sd7220_init(struct ipath_devdata *dd, int was_reset)
-{
-	int ret = 1; /* default to failure */
-	int first_reset;
-	int val_stat;
-
-	if (!was_reset) {
-		/* entered with reset not asserted, we need to do it */
-		ipath_ibsd_reset(dd, 1);
-		ipath_sd_trimdone_monitor(dd, "Driver-reload");
-	}
-
-	/* Substitute our deduced value for was_reset */
-	ret = ipath_ibsd_ucode_loaded(dd);
-	if (ret < 0) {
-		ret = 1;
-		goto done;
-	}
-	first_reset = !ret; /* First reset if IBSD uCode not yet loaded */
-
-	/*
-	 * Alter some regs per vendor latest doc, reset-defaults
-	 * are not right for IB.
-	 */
-	ret = ipath_sd_early(dd);
-	if (ret < 0) {
-		ipath_dev_err(dd, "Failed to set IB SERDES early defaults\n");
-		ret = 1;
-		goto done;
-	}
-
-	/*
-	 * Set DAC manual trim IB.
-	 * We only do this once after chip has been reset (usually
-	 * same as once per system boot).
-	 */
-	if (first_reset) {
-		ret = ipath_sd_dactrim(dd);
-		if (ret < 0) {
-			ipath_dev_err(dd, "Failed IB SERDES DAC trim\n");
-			ret = 1;
-			goto done;
-		}
-	}
-
-	/*
-	 * Set various registers (DDS and RXEQ) that will be
-	 * controlled by IBC (in 1.2 mode) to reasonable preset values
-	 * Calling the "internal" version avoids the "check for needed"
-	 * and "trimdone monitor" that might be counter-productive.
-	 */
-	ret = ipath_internal_presets(dd);
-	if (ret < 0) {
-		ipath_dev_err(dd, "Failed to set IB SERDES presets\n");
-		ret = 1;
-		goto done;
-	}
-	ret = ipath_sd_trimself(dd, 0x80);
-	if (ret < 0) {
-		ipath_dev_err(dd, "Failed to set IB SERDES TRIMSELF\n");
-		ret = 1;
-		goto done;
-	}
-
-	/* Load image, then try to verify */
-	ret = 0;	/* Assume success */
-	if (first_reset) {
-		int vfy;
-		int trim_done;
-		ipath_dbg("SerDes uC was reset, reloading PRAM\n");
-		ret = ipath_sd7220_ib_load(dd);
-		if (ret < 0) {
-			ipath_dev_err(dd, "Failed to load IB SERDES image\n");
-			ret = 1;
-			goto done;
-		}
-
-		/* Loaded image, try to verify */
-		vfy = ipath_sd7220_ib_vfy(dd);
-		if (vfy != ret) {
-			ipath_dev_err(dd, "SERDES PRAM VFY failed\n");
-			ret = 1;
-			goto done;
-		}
-		/*
-		 * Loaded and verified. Almost good...
-		 * hold "success" in ret
-		 */
-		ret = 0;
-
-		/*
-		 * Prev steps all worked, continue bringup
-		 * De-assert RESET to uC, only in first reset, to allow
-		 * trimming.
-		 *
-		 * Since our default setup sets START_EQ1 to
-		 * PRESET, we need to clear that for this very first run.
-		 */
-		ret = ibsd_mod_allchnls(dd, START_EQ1(0), 0, 0x38);
-		if (ret < 0) {
-			ipath_dev_err(dd, "Failed clearing START_EQ1\n");
-			ret = 1;
-			goto done;
-		}
-
-		ipath_ibsd_reset(dd, 0);
-		/*
-		 * If this is not the first reset, trimdone should be set
-		 * already.
-		 */
-		trim_done = ipath_sd_trimdone_poll(dd);
-		/*
-		 * Whether or not trimdone succeeded, we need to put the
-		 * uC back into reset to avoid a possible fight with the
-		 * IBC state-machine.
-		 */
-		ipath_ibsd_reset(dd, 1);
-
-		if (!trim_done) {
-			ipath_dev_err(dd, "No TRIMDONE seen\n");
-			ret = 1;
-			goto done;
-		}
-
-		ipath_sd_trimdone_monitor(dd, "First-reset");
-		/* Remember so we do not re-do the load, dactrim, etc. */
-		dd->serdes_first_init_done = 1;
-	}
-	/*
-	 * Setup for channel training and load values for
-	 * RxEq and DDS in tables used by IBC in IB1.2 mode
-	 */
-
-	val_stat = ipath_sd_setvals(dd);
-	if (val_stat < 0)
-		ret = 1;
-done:
-	/* start relock timer regardless, but start at 1 second */
-	ipath_set_relock_poll(dd, -1);
-	return ret;
-}
-
-#define EPB_ACC_REQ 1
-#define EPB_ACC_GNT 0x100
-#define EPB_DATA_MASK 0xFF
-#define EPB_RD (1ULL << 24)
-#define EPB_TRANS_RDY (1ULL << 31)
-#define EPB_TRANS_ERR (1ULL << 30)
-#define EPB_TRANS_TRIES 5
-
-/*
- * query, claim, release ownership of the EPB (External Parallel Bus)
- * for a specified SERDES.
- * the "claim" parameter is >0 to claim, <0 to release, 0 to query.
- * Returns <0 for errors, >0 if we had ownership, else 0.
- */
-static int epb_access(struct ipath_devdata *dd, int sdnum, int claim)
-{
-	u16 acc;
-	u64 accval;
-	int owned = 0;
-	u64 oct_sel = 0;
-
-	switch (sdnum) {
-	case IB_7220_SERDES :
-		/*
-		 * The IB SERDES "ownership" is fairly simple. A single each
-		 * request/grant.
-		 */
-		acc = dd->ipath_kregs->kr_ib_epbacc;
-		break;
-	case PCIE_SERDES0 :
-	case PCIE_SERDES1 :
-		/* PCIe SERDES has two "octants", need to select which */
-		acc = dd->ipath_kregs->kr_pcie_epbacc;
-		oct_sel = (2 << (sdnum - PCIE_SERDES0));
-		break;
-	default :
-		return 0;
-	}
-
-	/* Make sure any outstanding transaction was seen */
-	ipath_read_kreg32(dd, dd->ipath_kregs->kr_scratch);
-	udelay(15);
-
-	accval = ipath_read_kreg32(dd, acc);
-
-	owned = !!(accval & EPB_ACC_GNT);
-	if (claim < 0) {
-		/* Need to release */
-		u64 pollval;
-		/*
-		 * The only writeable bits are the request and CS.
-		 * Both should be clear
-		 */
-		u64 newval = 0;
-		ipath_write_kreg(dd, acc, newval);
-		/* First read after write is not trustworthy */
-		pollval = ipath_read_kreg32(dd, acc);
-		udelay(5);
-		pollval = ipath_read_kreg32(dd, acc);
-		if (pollval & EPB_ACC_GNT)
-			owned = -1;
-	} else if (claim > 0) {
-		/* Need to claim */
-		u64 pollval;
-		u64 newval = EPB_ACC_REQ | oct_sel;
-		ipath_write_kreg(dd, acc, newval);
-		/* First read after write is not trustworthy */
-		pollval = ipath_read_kreg32(dd, acc);
-		udelay(5);
-		pollval = ipath_read_kreg32(dd, acc);
-		if (!(pollval & EPB_ACC_GNT))
-			owned = -1;
-	}
-	return owned;
-}
-
-/*
- * Lemma to deal with race condition of write..read to epb regs
- */
-static int epb_trans(struct ipath_devdata *dd, u16 reg, u64 i_val, u64 *o_vp)
-{
-	int tries;
-	u64 transval;
-
-
-	ipath_write_kreg(dd, reg, i_val);
-	/* Throw away first read, as RDY bit may be stale */
-	transval = ipath_read_kreg64(dd, reg);
-
-	for (tries = EPB_TRANS_TRIES; tries; --tries) {
-		transval = ipath_read_kreg32(dd, reg);
-		if (transval & EPB_TRANS_RDY)
-			break;
-		udelay(5);
-	}
-	if (transval & EPB_TRANS_ERR)
-		return -1;
-	if (tries > 0 && o_vp)
-		*o_vp = transval;
-	return tries;
-}
-
-/**
- *
- * ipath_sd7220_reg_mod - modify SERDES register
- * @dd: the infinipath device
- * @sdnum: which SERDES to access
- * @loc: location - channel, element, register, as packed by EPB_LOC() macro.
- * @wd: Write Data - value to set in register
- * @mask: ones where data should be spliced into reg.
- *
- * Basic register read/modify/write, with un-needed acesses elided. That is,
- * a mask of zero will prevent write, while a mask of 0xFF will prevent read.
- * returns current (presumed, if a write was done) contents of selected
- * register, or <0 if errors.
- */
-static int ipath_sd7220_reg_mod(struct ipath_devdata *dd, int sdnum, u32 loc,
-				u32 wd, u32 mask)
-{
-	u16 trans;
-	u64 transval;
-	int owned;
-	int tries, ret;
-	unsigned long flags;
-
-	switch (sdnum) {
-	case IB_7220_SERDES :
-		trans = dd->ipath_kregs->kr_ib_epbtrans;
-		break;
-	case PCIE_SERDES0 :
-	case PCIE_SERDES1 :
-		trans = dd->ipath_kregs->kr_pcie_epbtrans;
-		break;
-	default :
-		return -1;
-	}
-
-	/*
-	 * All access is locked in software (vs other host threads) and
-	 * hardware (vs uC access).
-	 */
-	spin_lock_irqsave(&dd->ipath_sdepb_lock, flags);
-
-	owned = epb_access(dd, sdnum, 1);
-	if (owned < 0) {
-		spin_unlock_irqrestore(&dd->ipath_sdepb_lock, flags);
-		return -1;
-	}
-	ret = 0;
-	for (tries = EPB_TRANS_TRIES; tries; --tries) {
-		transval = ipath_read_kreg32(dd, trans);
-		if (transval & EPB_TRANS_RDY)
-			break;
-		udelay(5);
-	}
-
-	if (tries > 0) {
-		tries = 1;	/* to make read-skip work */
-		if (mask != 0xFF) {
-			/*
-			 * Not a pure write, so need to read.
-			 * loc encodes chip-select as well as address
-			 */
-			transval = loc | EPB_RD;
-			tries = epb_trans(dd, trans, transval, &transval);
-		}
-		if (tries > 0 && mask != 0) {
-			/*
-			 * Not a pure read, so need to write.
-			 */
-			wd = (wd & mask) | (transval & ~mask);
-			transval = loc | (wd & EPB_DATA_MASK);
-			tries = epb_trans(dd, trans, transval, &transval);
-		}
-	}
-	/* else, failed to see ready, what error-handling? */
-
-	/*
-	 * Release bus. Failure is an error.
-	 */
-	if (epb_access(dd, sdnum, -1) < 0)
-		ret = -1;
-	else
-		ret = transval & EPB_DATA_MASK;
-
-	spin_unlock_irqrestore(&dd->ipath_sdepb_lock, flags);
-	if (tries <= 0)
-		ret = -1;
-	return ret;
-}
-
-#define EPB_ROM_R (2)
-#define EPB_ROM_W (1)
-/*
- * Below, all uC-related, use appropriate UC_CS, depending
- * on which SerDes is used.
- */
-#define EPB_UC_CTL EPB_LOC(6, 0, 0)
-#define EPB_MADDRL EPB_LOC(6, 0, 2)
-#define EPB_MADDRH EPB_LOC(6, 0, 3)
-#define EPB_ROMDATA EPB_LOC(6, 0, 4)
-#define EPB_RAMDATA EPB_LOC(6, 0, 5)
-
-/* Transfer date to/from uC Program RAM of IB or PCIe SerDes */
-static int ipath_sd7220_ram_xfer(struct ipath_devdata *dd, int sdnum, u32 loc,
-			       u8 *buf, int cnt, int rd_notwr)
-{
-	u16 trans;
-	u64 transval;
-	u64 csbit;
-	int owned;
-	int tries;
-	int sofar;
-	int addr;
-	int ret;
-	unsigned long flags;
-	const char *op;
-
-	/* Pick appropriate transaction reg and "Chip select" for this serdes */
-	switch (sdnum) {
-	case IB_7220_SERDES :
-		csbit = 1ULL << EPB_IB_UC_CS_SHF;
-		trans = dd->ipath_kregs->kr_ib_epbtrans;
-		break;
-	case PCIE_SERDES0 :
-	case PCIE_SERDES1 :
-		/* PCIe SERDES has uC "chip select" in different bit, too */
-		csbit = 1ULL << EPB_PCIE_UC_CS_SHF;
-		trans = dd->ipath_kregs->kr_pcie_epbtrans;
-		break;
-	default :
-		return -1;
-	}
-
-	op = rd_notwr ? "Rd" : "Wr";
-	spin_lock_irqsave(&dd->ipath_sdepb_lock, flags);
-
-	owned = epb_access(dd, sdnum, 1);
-	if (owned < 0) {
-		spin_unlock_irqrestore(&dd->ipath_sdepb_lock, flags);
-		ipath_dbg("Could not get %s access to %s EPB: %X, loc %X\n",
-			op, (sdnum == IB_7220_SERDES) ? "IB" : "PCIe",
-			owned, loc);
-		return -1;
-	}
-
-	/*
-	 * In future code, we may need to distinguish several address ranges,
-	 * and select various memories based on this. For now, just trim
-	 * "loc" (location including address and memory select) to
-	 * "addr" (address within memory). we will only support PRAM
-	 * The memory is 8KB.
-	 */
-	addr = loc & 0x1FFF;
-	for (tries = EPB_TRANS_TRIES; tries; --tries) {
-		transval = ipath_read_kreg32(dd, trans);
-		if (transval & EPB_TRANS_RDY)
-			break;
-		udelay(5);
-	}
-
-	sofar = 0;
-	if (tries <= 0)
-		ipath_dbg("No initial RDY on EPB access request\n");
-	else {
-		/*
-		 * Every "memory" access is doubly-indirect.
-		 * We set two bytes of address, then read/write
-		 * one or mores bytes of data.
-		 */
-
-		/* First, we set control to "Read" or "Write" */
-		transval = csbit | EPB_UC_CTL |
-			(rd_notwr ? EPB_ROM_R : EPB_ROM_W);
-		tries = epb_trans(dd, trans, transval, &transval);
-		if (tries <= 0)
-			ipath_dbg("No EPB response to uC %s cmd\n", op);
-		while (tries > 0 && sofar < cnt) {
-			if (!sofar) {
-				/* Only set address at start of chunk */
-				int addrbyte = (addr + sofar) >> 8;
-				transval = csbit | EPB_MADDRH | addrbyte;
-				tries = epb_trans(dd, trans, transval,
-						  &transval);
-				if (tries <= 0) {
-					ipath_dbg("No EPB response ADDRH\n");
-					break;
-				}
-				addrbyte = (addr + sofar) & 0xFF;
-				transval = csbit | EPB_MADDRL | addrbyte;
-				tries = epb_trans(dd, trans, transval,
-						 &transval);
-				if (tries <= 0) {
-					ipath_dbg("No EPB response ADDRL\n");
-					break;
-				}
-			}
-
-			if (rd_notwr)
-				transval = csbit | EPB_ROMDATA | EPB_RD;
-			else
-				transval = csbit | EPB_ROMDATA | buf[sofar];
-			tries = epb_trans(dd, trans, transval, &transval);
-			if (tries <= 0) {
-				ipath_dbg("No EPB response DATA\n");
-				break;
-			}
-			if (rd_notwr)
-				buf[sofar] = transval & EPB_DATA_MASK;
-			++sofar;
-		}
-		/* Finally, clear control-bit for Read or Write */
-		transval = csbit | EPB_UC_CTL;
-		tries = epb_trans(dd, trans, transval, &transval);
-		if (tries <= 0)
-			ipath_dbg("No EPB response to drop of uC %s cmd\n", op);
-	}
-
-	ret = sofar;
-	/* Release bus. Failure is an error */
-	if (epb_access(dd, sdnum, -1) < 0)
-		ret = -1;
-
-	spin_unlock_irqrestore(&dd->ipath_sdepb_lock, flags);
-	if (tries <= 0) {
-		ipath_dbg("SERDES PRAM %s failed after %d bytes\n", op, sofar);
-		ret = -1;
-	}
-	return ret;
-}
-
-#define PROG_CHUNK 64
-
-int ipath_sd7220_prog_ld(struct ipath_devdata *dd, int sdnum,
-	u8 *img, int len, int offset)
-{
-	int cnt, sofar, req;
-
-	sofar = 0;
-	while (sofar < len) {
-		req = len - sofar;
-		if (req > PROG_CHUNK)
-			req = PROG_CHUNK;
-		cnt = ipath_sd7220_ram_xfer(dd, sdnum, offset + sofar,
-					  img + sofar, req, 0);
-		if (cnt < req) {
-			sofar = -1;
-			break;
-		}
-		sofar += req;
-	}
-	return sofar;
-}
-
-#define VFY_CHUNK 64
-#define SD_PRAM_ERROR_LIMIT 42
-
-int ipath_sd7220_prog_vfy(struct ipath_devdata *dd, int sdnum,
-	const u8 *img, int len, int offset)
-{
-	int cnt, sofar, req, idx, errors;
-	unsigned char readback[VFY_CHUNK];
-
-	errors = 0;
-	sofar = 0;
-	while (sofar < len) {
-		req = len - sofar;
-		if (req > VFY_CHUNK)
-			req = VFY_CHUNK;
-		cnt = ipath_sd7220_ram_xfer(dd, sdnum, sofar + offset,
-					  readback, req, 1);
-		if (cnt < req) {
-			/* failed in read itself */
-			sofar = -1;
-			break;
-		}
-		for (idx = 0; idx < cnt; ++idx) {
-			if (readback[idx] != img[idx+sofar])
-				++errors;
-		}
-		sofar += cnt;
-	}
-	return errors ? -errors : sofar;
-}
-
-/* IRQ not set up at this point in init, so we poll. */
-#define IB_SERDES_TRIM_DONE (1ULL << 11)
-#define TRIM_TMO (30)
-
-static int ipath_sd_trimdone_poll(struct ipath_devdata *dd)
-{
-	int trim_tmo, ret;
-	uint64_t val;
-
-	/*
-	 * Default to failure, so IBC will not start
-	 * without IB_SERDES_TRIM_DONE.
-	 */
-	ret = 0;
-	for (trim_tmo = 0; trim_tmo < TRIM_TMO; ++trim_tmo) {
-		val = ipath_read_kreg64(dd, dd->ipath_kregs->kr_ibcstatus);
-		if (val & IB_SERDES_TRIM_DONE) {
-			ipath_cdbg(VERBOSE, "TRIMDONE after %d\n", trim_tmo);
-			ret = 1;
-			break;
-		}
-		msleep(10);
-	}
-	if (trim_tmo >= TRIM_TMO) {
-		ipath_dev_err(dd, "No TRIMDONE in %d tries\n", trim_tmo);
-		ret = 0;
-	}
-	return ret;
-}
-
-#define TX_FAST_ELT (9)
-
-/*
- * Set the "negotiation" values for SERDES. These are used by the IB1.2
- * link negotiation. Macros below are attempt to keep the values a
- * little more human-editable.
- * First, values related to Drive De-emphasis Settings.
- */
-
-#define NUM_DDS_REGS 6
-#define DDS_REG_MAP 0x76A910 /* LSB-first list of regs (in elt 9) to mod */
-
-#define DDS_VAL(amp_d, main_d, ipst_d, ipre_d, amp_s, main_s, ipst_s, ipre_s) \
-	{ { ((amp_d & 0x1F) << 1) | 1, ((amp_s & 0x1F) << 1) | 1, \
-	  (main_d << 3) | 4 | (ipre_d >> 2), \
-	  (main_s << 3) | 4 | (ipre_s >> 2), \
-	  ((ipst_d & 0xF) << 1) | ((ipre_d & 3) << 6) | 0x21, \
-	  ((ipst_s & 0xF) << 1) | ((ipre_s & 3) << 6) | 0x21 } }
-
-static struct dds_init {
-	uint8_t reg_vals[NUM_DDS_REGS];
-} dds_init_vals[] = {
-	/*       DDR(FDR)       SDR(HDR)   */
-	/* Vendor recommends below for 3m cable */
-#define DDS_3M 0
-	DDS_VAL(31, 19, 12, 0, 29, 22,  9, 0),
-	DDS_VAL(31, 12, 15, 4, 31, 15, 15, 1),
-	DDS_VAL(31, 13, 15, 3, 31, 16, 15, 0),
-	DDS_VAL(31, 14, 15, 2, 31, 17, 14, 0),
-	DDS_VAL(31, 15, 15, 1, 31, 18, 13, 0),
-	DDS_VAL(31, 16, 15, 0, 31, 19, 12, 0),
-	DDS_VAL(31, 17, 14, 0, 31, 20, 11, 0),
-	DDS_VAL(31, 18, 13, 0, 30, 21, 10, 0),
-	DDS_VAL(31, 20, 11, 0, 28, 23,  8, 0),
-	DDS_VAL(31, 21, 10, 0, 27, 24,  7, 0),
-	DDS_VAL(31, 22,  9, 0, 26, 25,  6, 0),
-	DDS_VAL(30, 23,  8, 0, 25, 26,  5, 0),
-	DDS_VAL(29, 24,  7, 0, 23, 27,  4, 0),
-	/* Vendor recommends below for 1m cable */
-#define DDS_1M 13
-	DDS_VAL(28, 25,  6, 0, 21, 28,  3, 0),
-	DDS_VAL(27, 26,  5, 0, 19, 29,  2, 0),
-	DDS_VAL(25, 27,  4, 0, 17, 30,  1, 0)
-};
-
-/*
- * Next, values related to Receive Equalization.
- * In comments, FDR (Full) is IB DDR, HDR (Half) is IB SDR
- */
-/* Hardware packs an element number and register address thus: */
-#define RXEQ_INIT_RDESC(elt, addr) (((elt) & 0xF) | ((addr) << 4))
-#define RXEQ_VAL(elt, adr, val0, val1, val2, val3) \
-	{RXEQ_INIT_RDESC((elt), (adr)), {(val0), (val1), (val2), (val3)} }
-
-#define RXEQ_VAL_ALL(elt, adr, val)  \
-	{RXEQ_INIT_RDESC((elt), (adr)), {(val), (val), (val), (val)} }
-
-#define RXEQ_SDR_DFELTH 0
-#define RXEQ_SDR_TLTH 0
-#define RXEQ_SDR_G1CNT_Z1CNT 0x11
-#define RXEQ_SDR_ZCNT 23
-
-static struct rxeq_init {
-	u16 rdesc;	/* in form used in SerDesDDSRXEQ */
-	u8  rdata[4];
-} rxeq_init_vals[] = {
-	/* Set Rcv Eq. to Preset node */
-	RXEQ_VAL_ALL(7, 0x27, 0x10),
-	/* Set DFELTHFDR/HDR thresholds */
-	RXEQ_VAL(7, 8,    0, 0, 0, 0), /* FDR */
-	RXEQ_VAL(7, 0x21, 0, 0, 0, 0), /* HDR */
-	/* Set TLTHFDR/HDR theshold */
-	RXEQ_VAL(7, 9,    2, 2, 2, 2), /* FDR */
-	RXEQ_VAL(7, 0x23, 2, 2, 2, 2), /* HDR */
-	/* Set Preamp setting 2 (ZFR/ZCNT) */
-	RXEQ_VAL(7, 0x1B, 12, 12, 12, 12), /* FDR */
-	RXEQ_VAL(7, 0x1C, 12, 12, 12, 12), /* HDR */
-	/* Set Preamp DC gain and Setting 1 (GFR/GHR) */
-	RXEQ_VAL(7, 0x1E, 0x10, 0x10, 0x10, 0x10), /* FDR */
-	RXEQ_VAL(7, 0x1F, 0x10, 0x10, 0x10, 0x10), /* HDR */
-	/* Toggle RELOCK (in VCDL_CTRL0) to lock to data */
-	RXEQ_VAL_ALL(6, 6, 0x20), /* Set D5 High */
-	RXEQ_VAL_ALL(6, 6, 0), /* Set D5 Low */
-};
-
-/* There are 17 values from vendor, but IBC only accesses the first 16 */
-#define DDS_ROWS (16)
-#define RXEQ_ROWS ARRAY_SIZE(rxeq_init_vals)
-
-static int ipath_sd_setvals(struct ipath_devdata *dd)
-{
-	int idx, midx;
-	int min_idx;	 /* Minimum index for this portion of table */
-	uint32_t dds_reg_map;
-	u64 __iomem *taddr, *iaddr;
-	uint64_t data;
-	uint64_t sdctl;
-
-	taddr = dd->ipath_kregbase + KR_IBSerDesMappTable;
-	iaddr = dd->ipath_kregbase + dd->ipath_kregs->kr_ib_ddsrxeq;
-
-	/*
-	 * Init the DDS section of the table.
-	 * Each "row" of the table provokes NUM_DDS_REG writes, to the
-	 * registers indicated in DDS_REG_MAP.
-	 */
-	sdctl = ipath_read_kreg64(dd, dd->ipath_kregs->kr_ibserdesctrl);
-	sdctl = (sdctl & ~(0x1f << 8)) | (NUM_DDS_REGS << 8);
-	sdctl = (sdctl & ~(0x1f << 13)) | (RXEQ_ROWS << 13);
-	ipath_write_kreg(dd, dd->ipath_kregs->kr_ibserdesctrl, sdctl);
-
-	/*
-	 * Iterate down table within loop for each register to store.
-	 */
-	dds_reg_map = DDS_REG_MAP;
-	for (idx = 0; idx < NUM_DDS_REGS; ++idx) {
-		data = ((dds_reg_map & 0xF) << 4) | TX_FAST_ELT;
-		writeq(data, iaddr + idx);
-		mmiowb();
-		ipath_read_kreg32(dd, dd->ipath_kregs->kr_scratch);
-		dds_reg_map >>= 4;
-		for (midx = 0; midx < DDS_ROWS; ++midx) {
-			u64 __iomem *daddr = taddr + ((midx << 4) + idx);
-			data = dds_init_vals[midx].reg_vals[idx];
-			writeq(data, daddr);
-			mmiowb();
-			ipath_read_kreg32(dd, dd->ipath_kregs->kr_scratch);
-		} /* End inner for (vals for this reg, each row) */
-	} /* end outer for (regs to be stored) */
-
-	/*
-	 * Init the RXEQ section of the table. As explained above the table
-	 * rxeq_init_vals[], this runs in a different order, as the pattern
-	 * of register references is more complex, but there are only
-	 * four "data" values per register.
-	 */
-	min_idx = idx; /* RXEQ indices pick up where DDS left off */
-	taddr += 0x100; /* RXEQ data is in second half of table */
-	/* Iterate through RXEQ register addresses */
-	for (idx = 0; idx < RXEQ_ROWS; ++idx) {
-		int didx; /* "destination" */
-		int vidx;
-
-		/* didx is offset by min_idx to address RXEQ range of regs */
-		didx = idx + min_idx;
-		/* Store the next RXEQ register address */
-		writeq(rxeq_init_vals[idx].rdesc, iaddr + didx);
-		mmiowb();
-		ipath_read_kreg32(dd, dd->ipath_kregs->kr_scratch);
-		/* Iterate through RXEQ values */
-		for (vidx = 0; vidx < 4; vidx++) {
-			data = rxeq_init_vals[idx].rdata[vidx];
-			writeq(data, taddr + (vidx << 6) + idx);
-			mmiowb();
-			ipath_read_kreg32(dd, dd->ipath_kregs->kr_scratch);
-		}
-	} /* end outer for (Reg-writes for RXEQ) */
-	return 0;
-}
-
-#define CMUCTRL5 EPB_LOC(7, 0, 0x15)
-#define RXHSCTRL0(chan) EPB_LOC(chan, 6, 0)
-#define VCDL_DAC2(chan) EPB_LOC(chan, 6, 5)
-#define VCDL_CTRL0(chan) EPB_LOC(chan, 6, 6)
-#define VCDL_CTRL2(chan) EPB_LOC(chan, 6, 8)
-#define START_EQ2(chan) EPB_LOC(chan, 7, 0x28)
-
-static int ibsd_sto_noisy(struct ipath_devdata *dd, int loc, int val, int mask)
-{
-	int ret = -1;
-	int sloc; /* shifted loc, for messages */
-
-	loc |= (1U << EPB_IB_QUAD0_CS_SHF);
-	sloc = loc >> EPB_ADDR_SHF;
-
-	ret = ipath_sd7220_reg_mod(dd, IB_7220_SERDES, loc, val, mask);
-	if (ret < 0)
-		ipath_dev_err(dd, "Write failed: elt %d,"
-			" addr 0x%X, chnl %d, val 0x%02X, mask 0x%02X\n",
-			(sloc & 0xF), (sloc >> 9) & 0x3f, (sloc >> 4) & 7,
-			val & 0xFF, mask & 0xFF);
-	return ret;
-}
-
-/*
- * Repeat a "store" across all channels of the IB SerDes.
- * Although nominally it inherits the "read value" of the last
- * channel it modified, the only really useful return is <0 for
- * failure, >= 0 for success. The parameter 'loc' is assumed to
- * be the location for the channel-0 copy of the register to
- * be modified.
- */
-static int ibsd_mod_allchnls(struct ipath_devdata *dd, int loc, int val,
-	int mask)
-{
-	int ret = -1;
-	int chnl;
-
-	if (loc & EPB_GLOBAL_WR) {
-		/*
-		 * Our caller has assured us that we can set all four
-		 * channels at once. Trust that. If mask is not 0xFF,
-		 * we will read the _specified_ channel for our starting
-		 * value.
-		 */
-		loc |= (1U << EPB_IB_QUAD0_CS_SHF);
-		chnl = (loc >> (4 + EPB_ADDR_SHF)) & 7;
-		if (mask != 0xFF) {
-			ret = ipath_sd7220_reg_mod(dd, IB_7220_SERDES,
-				loc & ~EPB_GLOBAL_WR, 0, 0);
-			if (ret < 0) {
-				int sloc = loc >> EPB_ADDR_SHF;
-				ipath_dev_err(dd, "pre-read failed: elt %d,"
-					" addr 0x%X, chnl %d\n", (sloc & 0xF),
-					(sloc >> 9) & 0x3f, chnl);
-				return ret;
-			}
-			val = (ret & ~mask) | (val & mask);
-		}
-		loc &=  ~(7 << (4+EPB_ADDR_SHF));
-		ret = ipath_sd7220_reg_mod(dd, IB_7220_SERDES, loc, val, 0xFF);
-		if (ret < 0) {
-			int sloc = loc >> EPB_ADDR_SHF;
-			ipath_dev_err(dd, "Global WR failed: elt %d,"
-				" addr 0x%X, val %02X\n",
-				(sloc & 0xF), (sloc >> 9) & 0x3f, val);
-		}
-		return ret;
-	}
-	/* Clear "channel" and set CS so we can simply iterate */
-	loc &=  ~(7 << (4+EPB_ADDR_SHF));
-	loc |= (1U << EPB_IB_QUAD0_CS_SHF);
-	for (chnl = 0; chnl < 4; ++chnl) {
-		int cloc;
-		cloc = loc | (chnl << (4+EPB_ADDR_SHF));
-		ret = ipath_sd7220_reg_mod(dd, IB_7220_SERDES, cloc, val, mask);
-		if (ret < 0) {
-			int sloc = loc >> EPB_ADDR_SHF;
-			ipath_dev_err(dd, "Write failed: elt %d,"
-				" addr 0x%X, chnl %d, val 0x%02X,"
-				" mask 0x%02X\n",
-				(sloc & 0xF), (sloc >> 9) & 0x3f, chnl,
-				val & 0xFF, mask & 0xFF);
-			break;
-		}
-	}
-	return ret;
-}
-
-/*
- * Set the Tx values normally modified by IBC in IB1.2 mode to default
- * values, as gotten from first row of init table.
- */
-static int set_dds_vals(struct ipath_devdata *dd, struct dds_init *ddi)
-{
-	int ret;
-	int idx, reg, data;
-	uint32_t regmap;
-
-	regmap = DDS_REG_MAP;
-	for (idx = 0; idx < NUM_DDS_REGS; ++idx) {
-		reg = (regmap & 0xF);
-		regmap >>= 4;
-		data = ddi->reg_vals[idx];
-		/* Vendor says RMW not needed for these regs, use 0xFF mask */
-		ret = ibsd_mod_allchnls(dd, EPB_LOC(0, 9, reg), data, 0xFF);
-		if (ret < 0)
-			break;
-	}
-	return ret;
-}
-
-/*
- * Set the Rx values normally modified by IBC in IB1.2 mode to default
- * values, as gotten from selected column of init table.
- */
-static int set_rxeq_vals(struct ipath_devdata *dd, int vsel)
-{
-	int ret;
-	int ridx;
-	int cnt = ARRAY_SIZE(rxeq_init_vals);
-
-	for (ridx = 0; ridx < cnt; ++ridx) {
-		int elt, reg, val, loc;
-		elt = rxeq_init_vals[ridx].rdesc & 0xF;
-		reg = rxeq_init_vals[ridx].rdesc >> 4;
-		loc = EPB_LOC(0, elt, reg);
-		val = rxeq_init_vals[ridx].rdata[vsel];
-		/* mask of 0xFF, because hardware does full-byte store. */
-		ret = ibsd_mod_allchnls(dd, loc, val, 0xFF);
-		if (ret < 0)
-			break;
-	}
-	return ret;
-}
-
-/*
- * Set the default values (row 0) for DDR Driver Demphasis.
- * we do this initially and whenever we turn off IB-1.2
- * The "default" values for Rx equalization are also stored to
- * SerDes registers. Formerly (and still default), we used set 2.
- * For experimenting with cables and link-partners, we allow changing
- * that via a module parameter.
- */
-static unsigned ipath_rxeq_set = 2;
-module_param_named(rxeq_default_set, ipath_rxeq_set, uint,
-	S_IWUSR | S_IRUGO);
-MODULE_PARM_DESC(rxeq_default_set,
-	"Which set [0..3] of Rx Equalization values is default");
-
-static int ipath_internal_presets(struct ipath_devdata *dd)
-{
-	int ret = 0;
-
-	ret = set_dds_vals(dd, dds_init_vals + DDS_3M);
-
-	if (ret < 0)
-		ipath_dev_err(dd, "Failed to set default DDS values\n");
-	ret = set_rxeq_vals(dd, ipath_rxeq_set & 3);
-	if (ret < 0)
-		ipath_dev_err(dd, "Failed to set default RXEQ values\n");
-	return ret;
-}
-
-int ipath_sd7220_presets(struct ipath_devdata *dd)
-{
-	int ret = 0;
-
-	if (!dd->ipath_presets_needed)
-		return ret;
-	dd->ipath_presets_needed = 0;
-	/* Assert uC reset, so we don't clash with it. */
-	ipath_ibsd_reset(dd, 1);
-	udelay(2);
-	ipath_sd_trimdone_monitor(dd, "link-down");
-
-	ret = ipath_internal_presets(dd);
-return ret;
-}
-
-static int ipath_sd_trimself(struct ipath_devdata *dd, int val)
-{
-	return ibsd_sto_noisy(dd, CMUCTRL5, val, 0xFF);
-}
-
-static int ipath_sd_early(struct ipath_devdata *dd)
-{
-	int ret = -1; /* Default failed */
-	int chnl;
-
-	for (chnl = 0; chnl < 4; ++chnl) {
-		ret = ibsd_sto_noisy(dd, RXHSCTRL0(chnl), 0xD4, 0xFF);
-		if (ret < 0)
-			goto bail;
-	}
-	for (chnl = 0; chnl < 4; ++chnl) {
-		ret = ibsd_sto_noisy(dd, VCDL_DAC2(chnl), 0x2D, 0xFF);
-		if (ret < 0)
-			goto bail;
-	}
-	/* more fine-tuning of what will be default */
-	for (chnl = 0; chnl < 4; ++chnl) {
-		ret = ibsd_sto_noisy(dd, VCDL_CTRL2(chnl), 3, 0xF);
-		if (ret < 0)
-			goto bail;
-	}
-	for (chnl = 0; chnl < 4; ++chnl) {
-		ret = ibsd_sto_noisy(dd, START_EQ1(chnl), 0x10, 0xFF);
-		if (ret < 0)
-			goto bail;
-	}
-	for (chnl = 0; chnl < 4; ++chnl) {
-		ret = ibsd_sto_noisy(dd, START_EQ2(chnl), 0x30, 0xFF);
-		if (ret < 0)
-			goto bail;
-	}
-bail:
-	return ret;
-}
-
-#define BACTRL(chnl) EPB_LOC(chnl, 6, 0x0E)
-#define LDOUTCTRL1(chnl) EPB_LOC(chnl, 7, 6)
-#define RXHSSTATUS(chnl) EPB_LOC(chnl, 6, 0xF)
-
-static int ipath_sd_dactrim(struct ipath_devdata *dd)
-{
-	int ret = -1; /* Default failed */
-	int chnl;
-
-	for (chnl = 0; chnl < 4; ++chnl) {
-		ret = ibsd_sto_noisy(dd, BACTRL(chnl), 0x40, 0xFF);
-		if (ret < 0)
-			goto bail;
-	}
-	for (chnl = 0; chnl < 4; ++chnl) {
-		ret = ibsd_sto_noisy(dd, LDOUTCTRL1(chnl), 0x04, 0xFF);
-		if (ret < 0)
-			goto bail;
-	}
-	for (chnl = 0; chnl < 4; ++chnl) {
-		ret = ibsd_sto_noisy(dd, RXHSSTATUS(chnl), 0x04, 0xFF);
-		if (ret < 0)
-			goto bail;
-	}
-	/*
-	 * delay for max possible number of steps, with slop.
-	 * Each step is about 4usec.
-	 */
-	udelay(415);
-	for (chnl = 0; chnl < 4; ++chnl) {
-		ret = ibsd_sto_noisy(dd, LDOUTCTRL1(chnl), 0x00, 0xFF);
-		if (ret < 0)
-			goto bail;
-	}
-bail:
-	return ret;
-}
-
-#define RELOCK_FIRST_MS 3
-#define RXLSPPM(chan) EPB_LOC(chan, 0, 2)
-void ipath_toggle_rclkrls(struct ipath_devdata *dd)
-{
-	int loc = RXLSPPM(0) | EPB_GLOBAL_WR;
-	int ret;
-
-	ret = ibsd_mod_allchnls(dd, loc, 0, 0x80);
-	if (ret < 0)
-		ipath_dev_err(dd, "RCLKRLS failed to clear D7\n");
-	else {
-		udelay(1);
-		ibsd_mod_allchnls(dd, loc, 0x80, 0x80);
-	}
-	/* And again for good measure */
-	udelay(1);
-	ret = ibsd_mod_allchnls(dd, loc, 0, 0x80);
-	if (ret < 0)
-		ipath_dev_err(dd, "RCLKRLS failed to clear D7\n");
-	else {
-		udelay(1);
-		ibsd_mod_allchnls(dd, loc, 0x80, 0x80);
-	}
-	/* Now reset xgxs and IBC to complete the recovery */
-	dd->ipath_f_xgxs_reset(dd);
-}
-
-/*
- * Shut down the timer that polls for relock occasions, if needed
- * this is "hooked" from ipath_7220_quiet_serdes(), which is called
- * just before ipath_shutdown_device() in ipath_driver.c shuts down all
- * the other timers
- */
-void ipath_shutdown_relock_poll(struct ipath_devdata *dd)
-{
-	struct ipath_relock *irp = &dd->ipath_relock_singleton;
-	if (atomic_read(&irp->ipath_relock_timer_active)) {
-		del_timer_sync(&irp->ipath_relock_timer);
-		atomic_set(&irp->ipath_relock_timer_active, 0);
-	}
-}
-
-static unsigned ipath_relock_by_timer = 1;
-module_param_named(relock_by_timer, ipath_relock_by_timer, uint,
-	S_IWUSR | S_IRUGO);
-MODULE_PARM_DESC(relock_by_timer, "Allow relock attempt if link not up");
-
-static void ipath_run_relock(unsigned long opaque)
-{
-	struct ipath_devdata *dd = (struct ipath_devdata *)opaque;
-	struct ipath_relock *irp = &dd->ipath_relock_singleton;
-	u64 val, ltstate;
-
-	if (!(dd->ipath_flags & IPATH_INITTED)) {
-		/* Not yet up, just reenable the timer for later */
-		irp->ipath_relock_interval = HZ;
-		mod_timer(&irp->ipath_relock_timer, jiffies + HZ);
-		return;
-	}
-
-	/*
-	 * Check link-training state for "stuck" state.
-	 * if found, try relock and schedule another try at
-	 * exponentially growing delay, maxed at one second.
-	 * if not stuck, our work is done.
-	 */
-	val = ipath_read_kreg64(dd, dd->ipath_kregs->kr_ibcstatus);
-	ltstate = ipath_ib_linktrstate(dd, val);
-
-	if (ltstate <= INFINIPATH_IBCS_LT_STATE_CFGWAITRMT
-		&& ltstate != INFINIPATH_IBCS_LT_STATE_LINKUP) {
-		int timeoff;
-		/* Not up yet. Try again, if allowed by module-param */
-		if (ipath_relock_by_timer) {
-			if (dd->ipath_flags & IPATH_IB_AUTONEG_INPROG)
-				ipath_cdbg(VERBOSE, "Skip RELOCK in AUTONEG\n");
-			else if (!(dd->ipath_flags & IPATH_IB_LINK_DISABLED)) {
-				ipath_cdbg(VERBOSE, "RELOCK\n");
-				ipath_toggle_rclkrls(dd);
-			}
-		}
-		/* re-set timer for next check */
-		timeoff = irp->ipath_relock_interval << 1;
-		if (timeoff > HZ)
-			timeoff = HZ;
-		irp->ipath_relock_interval = timeoff;
-
-		mod_timer(&irp->ipath_relock_timer, jiffies + timeoff);
-	} else {
-		/* Up, so no more need to check so often */
-		mod_timer(&irp->ipath_relock_timer, jiffies + HZ);
-	}
-}
-
-void ipath_set_relock_poll(struct ipath_devdata *dd, int ibup)
-{
-	struct ipath_relock *irp = &dd->ipath_relock_singleton;
-
-	if (ibup > 0) {
-		/* we are now up, so relax timer to 1 second interval */
-		if (atomic_read(&irp->ipath_relock_timer_active))
-			mod_timer(&irp->ipath_relock_timer, jiffies + HZ);
-	} else {
-		/* Transition to down, (re-)set timer to short interval. */
-		int timeout;
-		timeout = (HZ * ((ibup == -1) ? 1000 : RELOCK_FIRST_MS))/1000;
-		if (timeout == 0)
-			timeout = 1;
-		/* If timer has not yet been started, do so. */
-		if (atomic_inc_return(&irp->ipath_relock_timer_active) == 1) {
-			init_timer(&irp->ipath_relock_timer);
-			irp->ipath_relock_timer.function = ipath_run_relock;
-			irp->ipath_relock_timer.data = (unsigned long) dd;
-			irp->ipath_relock_interval = timeout;
-			irp->ipath_relock_timer.expires = jiffies + timeout;
-			add_timer(&irp->ipath_relock_timer);
-		} else {
-			irp->ipath_relock_interval = timeout;
-			mod_timer(&irp->ipath_relock_timer, jiffies + timeout);
-			atomic_dec(&irp->ipath_relock_timer_active);
-		}
-	}
-}
-
diff --git a/drivers/infiniband/hw/ipath/ipath_sd7220_img.c b/drivers/infiniband/hw/ipath/ipath_sd7220_img.c
deleted file mode 100644
index 5ef59da..0000000
--- a/drivers/infiniband/hw/ipath/ipath_sd7220_img.c
+++ /dev/null
@@ -1,1082 +0,0 @@
-/*
- * Copyright (c) 2007, 2008 QLogic Corporation. All rights reserved.
- *
- * This software is available to you under a choice of one of two
- * licenses.  You may choose to be licensed under the terms of the GNU
- * General Public License (GPL) Version 2, available from the file
- * COPYING in the main directory of this source tree, or the
- * OpenIB.org BSD license below:
- *
- *     Redistribution and use in source and binary forms, with or
- *     without modification, are permitted provided that the following
- *     conditions are met:
- *
- *      - Redistributions of source code must retain the above
- *        copyright notice, this list of conditions and the following
- *        disclaimer.
- *
- *      - Redistributions in binary form must reproduce the above
- *        copyright notice, this list of conditions and the following
- *        disclaimer in the documentation and/or other materials
- *        provided with the distribution.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
- * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
- * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
- * SOFTWARE.
- */
-
-/*
- * This file contains the memory image from the vendor, to be copied into
- * the IB SERDES of the IBA7220 during initialization.
- * The file also includes the two functions which use this image.
- */
-#include <linux/pci.h>
-#include <linux/delay.h>
-
-#include "ipath_kernel.h"
-#include "ipath_registers.h"
-#include "ipath_7220.h"
-
-static unsigned char ipath_sd7220_ib_img[] = {
-/*0000*/0x02, 0x0A, 0x29, 0x02, 0x0A, 0x87, 0xE5, 0xE6,
-	0x30, 0xE6, 0x04, 0x7F, 0x01, 0x80, 0x02, 0x7F,
-/*0010*/0x00, 0xE5, 0xE2, 0x30, 0xE4, 0x04, 0x7E, 0x01,
-	0x80, 0x02, 0x7E, 0x00, 0xEE, 0x5F, 0x60, 0x08,
-/*0020*/0x53, 0xF9, 0xF7, 0xE4, 0xF5, 0xFE, 0x80, 0x08,
-	0x7F, 0x0A, 0x12, 0x17, 0x31, 0x12, 0x0E, 0xA2,
-/*0030*/0x75, 0xFC, 0x08, 0xE4, 0xF5, 0xFD, 0xE5, 0xE7,
-	0x20, 0xE7, 0x03, 0x43, 0xF9, 0x08, 0x22, 0x00,
-/*0040*/0x01, 0x20, 0x11, 0x00, 0x04, 0x20, 0x00, 0x75,
-	0x51, 0x01, 0xE4, 0xF5, 0x52, 0xF5, 0x53, 0xF5,
-/*0050*/0x52, 0xF5, 0x7E, 0x7F, 0x04, 0x02, 0x04, 0x38,
-	0xC2, 0x36, 0x05, 0x52, 0xE5, 0x52, 0xD3, 0x94,
-/*0060*/0x0C, 0x40, 0x05, 0x75, 0x52, 0x01, 0xD2, 0x36,
-	0x90, 0x07, 0x0C, 0x74, 0x07, 0xF0, 0xA3, 0x74,
-/*0070*/0xFF, 0xF0, 0xE4, 0xF5, 0x0C, 0xA3, 0xF0, 0x90,
-	0x07, 0x14, 0xF0, 0xA3, 0xF0, 0x75, 0x0B, 0x20,
-/*0080*/0xF5, 0x09, 0xE4, 0xF5, 0x08, 0xE5, 0x08, 0xD3,
-	0x94, 0x30, 0x40, 0x03, 0x02, 0x04, 0x04, 0x12,
-/*0090*/0x00, 0x06, 0x15, 0x0B, 0xE5, 0x08, 0x70, 0x04,
-	0x7F, 0x01, 0x80, 0x02, 0x7F, 0x00, 0xE5, 0x09,
-/*00A0*/0x70, 0x04, 0x7E, 0x01, 0x80, 0x02, 0x7E, 0x00,
-	0xEE, 0x5F, 0x60, 0x05, 0x12, 0x18, 0x71, 0xD2,
-/*00B0*/0x35, 0x53, 0xE1, 0xF7, 0xE5, 0x08, 0x45, 0x09,
-	0xFF, 0xE5, 0x0B, 0x25, 0xE0, 0x25, 0xE0, 0x24,
-/*00C0*/0x83, 0xF5, 0x82, 0xE4, 0x34, 0x07, 0xF5, 0x83,
-	0xEF, 0xF0, 0x85, 0xE2, 0x20, 0xE5, 0x52, 0xD3,
-/*00D0*/0x94, 0x01, 0x40, 0x0D, 0x12, 0x19, 0xF3, 0xE0,
-	0x54, 0xA0, 0x64, 0x40, 0x70, 0x03, 0x02, 0x03,
-/*00E0*/0xFB, 0x53, 0xF9, 0xF8, 0x90, 0x94, 0x70, 0xE4,
-	0xF0, 0xE0, 0xF5, 0x10, 0xAF, 0x09, 0x12, 0x1E,
-/*00F0*/0xB3, 0xAF, 0x08, 0xEF, 0x44, 0x08, 0xF5, 0x82,
-	0x75, 0x83, 0x80, 0xE0, 0xF5, 0x29, 0xEF, 0x44,
-/*0100*/0x07, 0x12, 0x1A, 0x3C, 0xF5, 0x22, 0x54, 0x40,
-	0xD3, 0x94, 0x00, 0x40, 0x1E, 0xE5, 0x29, 0x54,
-/*0110*/0xF0, 0x70, 0x21, 0x12, 0x19, 0xF3, 0xE0, 0x44,
-	0x80, 0xF0, 0xE5, 0x22, 0x54, 0x30, 0x65, 0x08,
-/*0120*/0x70, 0x09, 0x12, 0x19, 0xF3, 0xE0, 0x54, 0xBF,
-	0xF0, 0x80, 0x09, 0x12, 0x19, 0xF3, 0x74, 0x40,
-/*0130*/0xF0, 0x02, 0x03, 0xFB, 0x12, 0x1A, 0x12, 0x75,
-	0x83, 0xAE, 0x74, 0xFF, 0xF0, 0xAF, 0x08, 0x7E,
-/*0140*/0x00, 0xEF, 0x44, 0x07, 0xF5, 0x82, 0xE0, 0xFD,
-	0xE5, 0x0B, 0x25, 0xE0, 0x25, 0xE0, 0x24, 0x81,
-/*0150*/0xF5, 0x82, 0xE4, 0x34, 0x07, 0xF5, 0x83, 0xED,
-	0xF0, 0x90, 0x07, 0x0E, 0xE0, 0x04, 0xF0, 0xEF,
-/*0160*/0x44, 0x07, 0xF5, 0x82, 0x75, 0x83, 0x98, 0xE0,
-	0xF5, 0x28, 0x12, 0x1A, 0x23, 0x40, 0x0C, 0x12,
-/*0170*/0x19, 0xF3, 0xE0, 0x44, 0x01, 0x12, 0x1A, 0x32,
-	0x02, 0x03, 0xF6, 0xAF, 0x08, 0x7E, 0x00, 0x74,
-/*0180*/0x80, 0xCD, 0xEF, 0xCD, 0x8D, 0x82, 0xF5, 0x83,
-	0xE0, 0x30, 0xE0, 0x0A, 0x12, 0x19, 0xF3, 0xE0,
-/*0190*/0x44, 0x20, 0xF0, 0x02, 0x03, 0xFB, 0x12, 0x19,
-	0xF3, 0xE0, 0x54, 0xDF, 0xF0, 0xEE, 0x44, 0xAE,
-/*01A0*/0x12, 0x1A, 0x43, 0x30, 0xE4, 0x03, 0x02, 0x03,
-	0xFB, 0x74, 0x9E, 0x12, 0x1A, 0x05, 0x20, 0xE0,
-/*01B0*/0x03, 0x02, 0x03, 0xFB, 0x8F, 0x82, 0x8E, 0x83,
-	0xE0, 0x20, 0xE0, 0x03, 0x02, 0x03, 0xFB, 0x12,
-/*01C0*/0x19, 0xF3, 0xE0, 0x44, 0x10, 0xF0, 0xE5, 0xE3,
-	0x20, 0xE7, 0x08, 0xE5, 0x08, 0x12, 0x1A, 0x3A,
-/*01D0*/0x44, 0x04, 0xF0, 0xAF, 0x08, 0x7E, 0x00, 0xEF,
-	0x12, 0x1A, 0x3A, 0x20, 0xE2, 0x34, 0x12, 0x19,
-/*01E0*/0xF3, 0xE0, 0x44, 0x08, 0xF0, 0xE5, 0xE4, 0x30,
-	0xE6, 0x04, 0x7D, 0x01, 0x80, 0x02, 0x7D, 0x00,
-/*01F0*/0xE5, 0x7E, 0xC3, 0x94, 0x04, 0x50, 0x04, 0x7C,
-	0x01, 0x80, 0x02, 0x7C, 0x00, 0xEC, 0x4D, 0x60,
-/*0200*/0x05, 0xC2, 0x35, 0x02, 0x03, 0xFB, 0xEE, 0x44,
-	0xD2, 0x12, 0x1A, 0x43, 0x44, 0x40, 0xF0, 0x02,
-/*0210*/0x03, 0xFB, 0x12, 0x19, 0xF3, 0xE0, 0x54, 0xF7,
-	0xF0, 0x12, 0x1A, 0x12, 0x75, 0x83, 0xD2, 0xE0,
-/*0220*/0x54, 0xBF, 0xF0, 0x90, 0x07, 0x14, 0xE0, 0x04,
-	0xF0, 0xE5, 0x7E, 0x70, 0x03, 0x75, 0x7E, 0x01,
-/*0230*/0xAF, 0x08, 0x7E, 0x00, 0x12, 0x1A, 0x23, 0x40,
-	0x12, 0x12, 0x19, 0xF3, 0xE0, 0x44, 0x01, 0x12,
-/*0240*/0x19, 0xF2, 0xE0, 0x54, 0x02, 0x12, 0x1A, 0x32,
-	0x02, 0x03, 0xFB, 0x12, 0x19, 0xF3, 0xE0, 0x44,
-/*0250*/0x02, 0x12, 0x19, 0xF2, 0xE0, 0x54, 0xFE, 0xF0,
-	0xC2, 0x35, 0xEE, 0x44, 0x8A, 0x8F, 0x82, 0xF5,
-/*0260*/0x83, 0xE0, 0xF5, 0x17, 0x54, 0x8F, 0x44, 0x40,
-	0xF0, 0x74, 0x90, 0xFC, 0xE5, 0x08, 0x44, 0x07,
-/*0270*/0xFD, 0xF5, 0x82, 0x8C, 0x83, 0xE0, 0x54, 0x3F,
-	0x90, 0x07, 0x02, 0xF0, 0xE0, 0x54, 0xC0, 0x8D,
-/*0280*/0x82, 0x8C, 0x83, 0xF0, 0x74, 0x92, 0x12, 0x1A,
-	0x05, 0x90, 0x07, 0x03, 0x12, 0x1A, 0x19, 0x74,
-/*0290*/0x82, 0x12, 0x1A, 0x05, 0x90, 0x07, 0x04, 0x12,
-	0x1A, 0x19, 0x74, 0xB4, 0x12, 0x1A, 0x05, 0x90,
-/*02A0*/0x07, 0x05, 0x12, 0x1A, 0x19, 0x74, 0x94, 0xFE,
-	0xE5, 0x08, 0x44, 0x06, 0x12, 0x1A, 0x0A, 0xF5,
-/*02B0*/0x10, 0x30, 0xE0, 0x04, 0xD2, 0x37, 0x80, 0x02,
-	0xC2, 0x37, 0xE5, 0x10, 0x54, 0x7F, 0x8F, 0x82,
-/*02C0*/0x8E, 0x83, 0xF0, 0x30, 0x44, 0x30, 0x12, 0x1A,
-	0x03, 0x54, 0x80, 0xD3, 0x94, 0x00, 0x40, 0x04,
-/*02D0*/0xD2, 0x39, 0x80, 0x02, 0xC2, 0x39, 0x8F, 0x82,
-	0x8E, 0x83, 0xE0, 0x44, 0x80, 0xF0, 0x12, 0x1A,
-/*02E0*/0x03, 0x54, 0x40, 0xD3, 0x94, 0x00, 0x40, 0x04,
-	0xD2, 0x3A, 0x80, 0x02, 0xC2, 0x3A, 0x8F, 0x82,
-/*02F0*/0x8E, 0x83, 0xE0, 0x44, 0x40, 0xF0, 0x74, 0x92,
-	0xFE, 0xE5, 0x08, 0x44, 0x06, 0x12, 0x1A, 0x0A,
-/*0300*/0x30, 0xE7, 0x04, 0xD2, 0x38, 0x80, 0x02, 0xC2,
-	0x38, 0x8F, 0x82, 0x8E, 0x83, 0xE0, 0x54, 0x7F,
-/*0310*/0xF0, 0x12, 0x1E, 0x46, 0xE4, 0xF5, 0x0A, 0x20,
-	0x03, 0x02, 0x80, 0x03, 0x30, 0x43, 0x03, 0x12,
-/*0320*/0x19, 0x95, 0x20, 0x02, 0x02, 0x80, 0x03, 0x30,
-	0x42, 0x03, 0x12, 0x0C, 0x8F, 0x30, 0x30, 0x06,
-/*0330*/0x12, 0x19, 0x95, 0x12, 0x0C, 0x8F, 0x12, 0x0D,
-	0x47, 0x12, 0x19, 0xF3, 0xE0, 0x54, 0xFB, 0xF0,
-/*0340*/0xE5, 0x0A, 0xC3, 0x94, 0x01, 0x40, 0x46, 0x43,
-	0xE1, 0x08, 0x12, 0x19, 0xF3, 0xE0, 0x44, 0x04,
-/*0350*/0xF0, 0xE5, 0xE4, 0x20, 0xE7, 0x2A, 0x12, 0x1A,
-	0x12, 0x75, 0x83, 0xD2, 0xE0, 0x54, 0x08, 0xD3,
-/*0360*/0x94, 0x00, 0x40, 0x04, 0x7F, 0x01, 0x80, 0x02,
-	0x7F, 0x00, 0xE5, 0x0A, 0xC3, 0x94, 0x01, 0x40,
-/*0370*/0x04, 0x7E, 0x01, 0x80, 0x02, 0x7E, 0x00, 0xEF,
-	0x5E, 0x60, 0x05, 0x12, 0x1D, 0xD7, 0x80, 0x17,
-/*0380*/0x12, 0x1A, 0x12, 0x75, 0x83, 0xD2, 0xE0, 0x44,
-	0x08, 0xF0, 0x02, 0x03, 0xFB, 0x12, 0x1A, 0x12,
-/*0390*/0x75, 0x83, 0xD2, 0xE0, 0x54, 0xF7, 0xF0, 0x12,
-	0x1E, 0x46, 0x7F, 0x08, 0x12, 0x17, 0x31, 0x74,
-/*03A0*/0x8E, 0xFE, 0x12, 0x1A, 0x12, 0x8E, 0x83, 0xE0,
-	0xF5, 0x10, 0x54, 0xFE, 0xF0, 0xE5, 0x10, 0x44,
-/*03B0*/0x01, 0xFF, 0xE5, 0x08, 0xFD, 0xED, 0x44, 0x07,
-	0xF5, 0x82, 0xEF, 0xF0, 0xE5, 0x10, 0x54, 0xFE,
-/*03C0*/0xFF, 0xED, 0x44, 0x07, 0xF5, 0x82, 0xEF, 0x12,
-	0x1A, 0x11, 0x75, 0x83, 0x86, 0xE0, 0x44, 0x10,
-/*03D0*/0x12, 0x1A, 0x11, 0xE0, 0x44, 0x10, 0xF0, 0x12,
-	0x19, 0xF3, 0xE0, 0x54, 0xFD, 0x44, 0x01, 0xFF,
-/*03E0*/0x12, 0x19, 0xF3, 0xEF, 0x12, 0x1A, 0x32, 0x30,
-	0x32, 0x0C, 0xE5, 0x08, 0x44, 0x08, 0xF5, 0x82,
-/*03F0*/0x75, 0x83, 0x82, 0x74, 0x05, 0xF0, 0xAF, 0x0B,
-	0x12, 0x18, 0xD7, 0x74, 0x10, 0x25, 0x08, 0xF5,
-/*0400*/0x08, 0x02, 0x00, 0x85, 0x05, 0x09, 0xE5, 0x09,
-	0xD3, 0x94, 0x07, 0x50, 0x03, 0x02, 0x00, 0x82,
-/*0410*/0xE5, 0x7E, 0xD3, 0x94, 0x00, 0x40, 0x04, 0x7F,
-	0x01, 0x80, 0x02, 0x7F, 0x00, 0xE5, 0x7E, 0xC3,
-/*0420*/0x94, 0xFA, 0x50, 0x04, 0x7E, 0x01, 0x80, 0x02,
-	0x7E, 0x00, 0xEE, 0x5F, 0x60, 0x02, 0x05, 0x7E,
-/*0430*/0x30, 0x35, 0x0B, 0x43, 0xE1, 0x01, 0x7F, 0x09,
-	0x12, 0x17, 0x31, 0x02, 0x00, 0x58, 0x53, 0xE1,
-/*0440*/0xFE, 0x02, 0x00, 0x58, 0x8E, 0x6A, 0x8F, 0x6B,
-	0x8C, 0x6C, 0x8D, 0x6D, 0x75, 0x6E, 0x01, 0x75,
-/*0450*/0x6F, 0x01, 0x75, 0x70, 0x01, 0xE4, 0xF5, 0x73,
-	0xF5, 0x74, 0xF5, 0x75, 0x90, 0x07, 0x2F, 0xF0,
-/*0460*/0xF5, 0x3C, 0xF5, 0x3E, 0xF5, 0x46, 0xF5, 0x47,
-	0xF5, 0x3D, 0xF5, 0x3F, 0xF5, 0x6F, 0xE5, 0x6F,
-/*0470*/0x70, 0x0F, 0xE5, 0x6B, 0x45, 0x6A, 0x12, 0x07,
-	0x2A, 0x75, 0x83, 0x80, 0x74, 0x3A, 0xF0, 0x80,
-/*0480*/0x09, 0x12, 0x07, 0x2A, 0x75, 0x83, 0x80, 0x74,
-	0x1A, 0xF0, 0xE4, 0xF5, 0x6E, 0xC3, 0x74, 0x3F,
-/*0490*/0x95, 0x6E, 0xFF, 0x12, 0x08, 0x65, 0x75, 0x83,
-	0x82, 0xEF, 0xF0, 0x12, 0x1A, 0x4D, 0x12, 0x08,
-/*04A0*/0xC6, 0xE5, 0x33, 0xF0, 0x12, 0x08, 0xFA, 0x12,
-	0x08, 0xB1, 0x40, 0xE1, 0xE5, 0x6F, 0x70, 0x0B,
-/*04B0*/0x12, 0x07, 0x2A, 0x75, 0x83, 0x80, 0x74, 0x36,
-	0xF0, 0x80, 0x09, 0x12, 0x07, 0x2A, 0x75, 0x83,
-/*04C0*/0x80, 0x74, 0x16, 0xF0, 0x75, 0x6E, 0x01, 0x12,
-	0x07, 0x2A, 0x75, 0x83, 0xB4, 0xE5, 0x6E, 0xF0,
-/*04D0*/0x12, 0x1A, 0x4D, 0x74, 0x3F, 0x25, 0x6E, 0xF5,
-	0x82, 0xE4, 0x34, 0x00, 0xF5, 0x83, 0xE5, 0x33,
-/*04E0*/0xF0, 0x74, 0xBF, 0x25, 0x6E, 0xF5, 0x82, 0xE4,
-	0x34, 0x00, 0x12, 0x08, 0xB1, 0x40, 0xD8, 0xE4,
-/*04F0*/0xF5, 0x70, 0xF5, 0x46, 0xF5, 0x47, 0xF5, 0x6E,
-	0x12, 0x08, 0xFA, 0xF5, 0x83, 0xE0, 0xFE, 0x12,
-/*0500*/0x08, 0xC6, 0xE0, 0x7C, 0x00, 0x24, 0x00, 0xFF,
-	0xEC, 0x3E, 0xFE, 0xAD, 0x3B, 0xD3, 0xEF, 0x9D,
-/*0510*/0xEE, 0x9C, 0x50, 0x04, 0x7B, 0x01, 0x80, 0x02,
-	0x7B, 0x00, 0xE5, 0x70, 0x70, 0x04, 0x7A, 0x01,
-/*0520*/0x80, 0x02, 0x7A, 0x00, 0xEB, 0x5A, 0x60, 0x06,
-	0x85, 0x6E, 0x46, 0x75, 0x70, 0x01, 0xD3, 0xEF,
-/*0530*/0x9D, 0xEE, 0x9C, 0x50, 0x04, 0x7F, 0x01, 0x80,
-	0x02, 0x7F, 0x00, 0xE5, 0x70, 0xB4, 0x01, 0x04,
-/*0540*/0x7E, 0x01, 0x80, 0x02, 0x7E, 0x00, 0xEF, 0x5E,
-	0x60, 0x03, 0x85, 0x6E, 0x47, 0x05, 0x6E, 0xE5,
-/*0550*/0x6E, 0x64, 0x7F, 0x70, 0xA3, 0xE5, 0x46, 0x60,
-	0x05, 0xE5, 0x47, 0xB4, 0x7E, 0x03, 0x85, 0x46,
-/*0560*/0x47, 0xE5, 0x6F, 0x70, 0x08, 0x85, 0x46, 0x76,
-	0x85, 0x47, 0x77, 0x80, 0x0E, 0xC3, 0x74, 0x7F,
-/*0570*/0x95, 0x46, 0xF5, 0x78, 0xC3, 0x74, 0x7F, 0x95,
-	0x47, 0xF5, 0x79, 0xE5, 0x6F, 0x70, 0x37, 0xE5,
-/*0580*/0x46, 0x65, 0x47, 0x70, 0x0C, 0x75, 0x73, 0x01,
-	0x75, 0x74, 0x01, 0xF5, 0x3C, 0xF5, 0x3D, 0x80,
-/*0590*/0x35, 0xE4, 0xF5, 0x4E, 0xC3, 0xE5, 0x47, 0x95,
-	0x46, 0xF5, 0x3C, 0xC3, 0x13, 0xF5, 0x71, 0x25,
-/*05A0*/0x46, 0xF5, 0x72, 0xC3, 0x94, 0x3F, 0x40, 0x05,
-	0xE4, 0xF5, 0x3D, 0x80, 0x40, 0xC3, 0x74, 0x3F,
-/*05B0*/0x95, 0x72, 0xF5, 0x3D, 0x80, 0x37, 0xE5, 0x46,
-	0x65, 0x47, 0x70, 0x0F, 0x75, 0x73, 0x01, 0x75,
-/*05C0*/0x75, 0x01, 0xF5, 0x3E, 0xF5, 0x3F, 0x75, 0x4E,
-	0x01, 0x80, 0x22, 0xE4, 0xF5, 0x4E, 0xC3, 0xE5,
-/*05D0*/0x47, 0x95, 0x46, 0xF5, 0x3E, 0xC3, 0x13, 0xF5,
-	0x71, 0x25, 0x46, 0xF5, 0x72, 0xD3, 0x94, 0x3F,
-/*05E0*/0x50, 0x05, 0xE4, 0xF5, 0x3F, 0x80, 0x06, 0xE5,
-	0x72, 0x24, 0xC1, 0xF5, 0x3F, 0x05, 0x6F, 0xE5,
-/*05F0*/0x6F, 0xC3, 0x94, 0x02, 0x50, 0x03, 0x02, 0x04,
-	0x6E, 0xE5, 0x6D, 0x45, 0x6C, 0x70, 0x02, 0x80,
-/*0600*/0x04, 0xE5, 0x74, 0x45, 0x75, 0x90, 0x07, 0x2F,
-	0xF0, 0x7F, 0x01, 0xE5, 0x3E, 0x60, 0x04, 0xE5,
-/*0610*/0x3C, 0x70, 0x14, 0xE4, 0xF5, 0x3C, 0xF5, 0x3D,
-	0xF5, 0x3E, 0xF5, 0x3F, 0x12, 0x08, 0xD2, 0x70,
-/*0620*/0x04, 0xF0, 0x02, 0x06, 0xA4, 0x80, 0x7A, 0xE5,
-	0x3C, 0xC3, 0x95, 0x3E, 0x40, 0x07, 0xE5, 0x3C,
-/*0630*/0x95, 0x3E, 0xFF, 0x80, 0x06, 0xC3, 0xE5, 0x3E,
-	0x95, 0x3C, 0xFF, 0xE5, 0x76, 0xD3, 0x95, 0x79,
-/*0640*/0x40, 0x05, 0x85, 0x76, 0x7A, 0x80, 0x03, 0x85,
-	0x79, 0x7A, 0xE5, 0x77, 0xC3, 0x95, 0x78, 0x50,
-/*0650*/0x05, 0x85, 0x77, 0x7B, 0x80, 0x03, 0x85, 0x78,
-	0x7B, 0xE5, 0x7B, 0xD3, 0x95, 0x7A, 0x40, 0x30,
-/*0660*/0xE5, 0x7B, 0x95, 0x7A, 0xF5, 0x3C, 0xF5, 0x3E,
-	0xC3, 0xE5, 0x7B, 0x95, 0x7A, 0x90, 0x07, 0x19,
-/*0670*/0xF0, 0xE5, 0x3C, 0xC3, 0x13, 0xF5, 0x71, 0x25,
-	0x7A, 0xF5, 0x72, 0xC3, 0x94, 0x3F, 0x40, 0x05,
-/*0680*/0xE4, 0xF5, 0x3D, 0x80, 0x1F, 0xC3, 0x74, 0x3F,
-	0x95, 0x72, 0xF5, 0x3D, 0xF5, 0x3F, 0x80, 0x14,
-/*0690*/0xE4, 0xF5, 0x3C, 0xF5, 0x3E, 0x90, 0x07, 0x19,
-	0xF0, 0x12, 0x08, 0xD2, 0x70, 0x03, 0xF0, 0x80,
-/*06A0*/0x03, 0x74, 0x01, 0xF0, 0x12, 0x08, 0x65, 0x75,
-	0x83, 0xD0, 0xE0, 0x54, 0x0F, 0xFE, 0xAD, 0x3C,
-/*06B0*/0x70, 0x02, 0x7E, 0x07, 0xBE, 0x0F, 0x02, 0x7E,
-	0x80, 0xEE, 0xFB, 0xEF, 0xD3, 0x9B, 0x74, 0x80,
-/*06C0*/0xF8, 0x98, 0x40, 0x1F, 0xE4, 0xF5, 0x3C, 0xF5,
-	0x3E, 0x12, 0x08, 0xD2, 0x70, 0x03, 0xF0, 0x80,
-/*06D0*/0x12, 0x74, 0x01, 0xF0, 0xE5, 0x08, 0xFB, 0xEB,
-	0x44, 0x07, 0xF5, 0x82, 0x75, 0x83, 0xD2, 0xE0,
-/*06E0*/0x44, 0x10, 0xF0, 0xE5, 0x08, 0xFB, 0xEB, 0x44,
-	0x09, 0xF5, 0x82, 0x75, 0x83, 0x9E, 0xED, 0xF0,
-/*06F0*/0xEB, 0x44, 0x07, 0xF5, 0x82, 0x75, 0x83, 0xCA,
-	0xED, 0xF0, 0x12, 0x08, 0x65, 0x75, 0x83, 0xCC,
-/*0700*/0xEF, 0xF0, 0x22, 0xE5, 0x08, 0x44, 0x07, 0xF5,
-	0x82, 0x75, 0x83, 0xBC, 0xE0, 0x54, 0xF0, 0xF0,
-/*0710*/0xE5, 0x08, 0x44, 0x07, 0xF5, 0x82, 0x75, 0x83,
-	0xBE, 0xE0, 0x54, 0xF0, 0xF0, 0xE5, 0x08, 0x44,
-/*0720*/0x07, 0xF5, 0x82, 0x75, 0x83, 0xC0, 0xE0, 0x54,
-	0xF0, 0xF0, 0xE5, 0x08, 0x44, 0x07, 0xF5, 0x82,
-/*0730*/0x22, 0xF0, 0x90, 0x07, 0x28, 0xE0, 0xFE, 0xA3,
-	0xE0, 0xF5, 0x82, 0x8E, 0x83, 0x22, 0x85, 0x42,
-/*0740*/0x42, 0x85, 0x41, 0x41, 0x85, 0x40, 0x40, 0x74,
-	0xC0, 0x2F, 0xF5, 0x82, 0x74, 0x02, 0x3E, 0xF5,
-/*0750*/0x83, 0xE5, 0x42, 0xF0, 0x74, 0xE0, 0x2F, 0xF5,
-	0x82, 0x74, 0x02, 0x3E, 0xF5, 0x83, 0x22, 0xE5,
-/*0760*/0x42, 0x29, 0xFD, 0xE4, 0x33, 0xFC, 0xE5, 0x3C,
-	0xC3, 0x9D, 0xEC, 0x64, 0x80, 0xF8, 0x74, 0x80,
-/*0770*/0x98, 0x22, 0xF5, 0x83, 0xE0, 0x90, 0x07, 0x22,
-	0x54, 0x1F, 0xFD, 0xE0, 0xFA, 0xA3, 0xE0, 0xF5,
-/*0780*/0x82, 0x8A, 0x83, 0xED, 0xF0, 0x22, 0x90, 0x07,
-	0x22, 0xE0, 0xFC, 0xA3, 0xE0, 0xF5, 0x82, 0x8C,
-/*0790*/0x83, 0x22, 0x90, 0x07, 0x24, 0xFF, 0xED, 0x44,
-	0x07, 0xCF, 0xF0, 0xA3, 0xEF, 0xF0, 0x22, 0x85,
-/*07A0*/0x38, 0x38, 0x85, 0x39, 0x39, 0x85, 0x3A, 0x3A,
-	0x74, 0xC0, 0x2F, 0xF5, 0x82, 0x74, 0x02, 0x3E,
-/*07B0*/0xF5, 0x83, 0x22, 0x90, 0x07, 0x26, 0xFF, 0xED,
-	0x44, 0x07, 0xCF, 0xF0, 0xA3, 0xEF, 0xF0, 0x22,
-/*07C0*/0xF0, 0x74, 0xA0, 0x2F, 0xF5, 0x82, 0x74, 0x02,
-	0x3E, 0xF5, 0x83, 0x22, 0x74, 0xC0, 0x25, 0x11,
-/*07D0*/0xF5, 0x82, 0xE4, 0x34, 0x01, 0xF5, 0x83, 0x22,
-	0x74, 0x00, 0x25, 0x11, 0xF5, 0x82, 0xE4, 0x34,
-/*07E0*/0x02, 0xF5, 0x83, 0x22, 0x74, 0x60, 0x25, 0x11,
-	0xF5, 0x82, 0xE4, 0x34, 0x03, 0xF5, 0x83, 0x22,
-/*07F0*/0x74, 0x80, 0x25, 0x11, 0xF5, 0x82, 0xE4, 0x34,
-	0x03, 0xF5, 0x83, 0x22, 0x74, 0xE0, 0x25, 0x11,
-/*0800*/0xF5, 0x82, 0xE4, 0x34, 0x03, 0xF5, 0x83, 0x22,
-	0x74, 0x40, 0x25, 0x11, 0xF5, 0x82, 0xE4, 0x34,
-/*0810*/0x06, 0xF5, 0x83, 0x22, 0x74, 0x80, 0x2F, 0xF5,
-	0x82, 0x74, 0x02, 0x3E, 0xF5, 0x83, 0x22, 0xAF,
-/*0820*/0x08, 0x7E, 0x00, 0xEF, 0x44, 0x07, 0xF5, 0x82,
-	0x22, 0xF5, 0x83, 0xE5, 0x82, 0x44, 0x07, 0xF5,
-/*0830*/0x82, 0xE5, 0x40, 0xF0, 0x22, 0x74, 0x40, 0x25,
-	0x11, 0xF5, 0x82, 0xE4, 0x34, 0x02, 0xF5, 0x83,
-/*0840*/0x22, 0x74, 0xC0, 0x25, 0x11, 0xF5, 0x82, 0xE4,
-	0x34, 0x03, 0xF5, 0x83, 0x22, 0x74, 0x00, 0x25,
-/*0850*/0x11, 0xF5, 0x82, 0xE4, 0x34, 0x06, 0xF5, 0x83,
-	0x22, 0x74, 0x20, 0x25, 0x11, 0xF5, 0x82, 0xE4,
-/*0860*/0x34, 0x06, 0xF5, 0x83, 0x22, 0xE5, 0x08, 0xFD,
-	0xED, 0x44, 0x07, 0xF5, 0x82, 0x22, 0xE5, 0x41,
-/*0870*/0xF0, 0xE5, 0x65, 0x64, 0x01, 0x45, 0x64, 0x22,
-	0x7E, 0x00, 0xFB, 0x7A, 0x00, 0xFD, 0x7C, 0x00,
-/*0880*/0x22, 0x74, 0x20, 0x25, 0x11, 0xF5, 0x82, 0xE4,
-	0x34, 0x02, 0x22, 0x74, 0xA0, 0x25, 0x11, 0xF5,
-/*0890*/0x82, 0xE4, 0x34, 0x03, 0x22, 0x85, 0x3E, 0x42,
-	0x85, 0x3F, 0x41, 0x8F, 0x40, 0x22, 0x85, 0x3C,
-/*08A0*/0x42, 0x85, 0x3D, 0x41, 0x8F, 0x40, 0x22, 0x75,
-	0x45, 0x3F, 0x90, 0x07, 0x20, 0xE4, 0xF0, 0xA3,
-/*08B0*/0x22, 0xF5, 0x83, 0xE5, 0x32, 0xF0, 0x05, 0x6E,
-	0xE5, 0x6E, 0xC3, 0x94, 0x40, 0x22, 0xF0, 0xE5,
-/*08C0*/0x08, 0x44, 0x06, 0xF5, 0x82, 0x22, 0x74, 0x00,
-	0x25, 0x6E, 0xF5, 0x82, 0xE4, 0x34, 0x00, 0xF5,
-/*08D0*/0x83, 0x22, 0xE5, 0x6D, 0x45, 0x6C, 0x90, 0x07,
-	0x2F, 0x22, 0xE4, 0xF9, 0xE5, 0x3C, 0xD3, 0x95,
-/*08E0*/0x3E, 0x22, 0x74, 0x80, 0x2E, 0xF5, 0x82, 0xE4,
-	0x34, 0x02, 0xF5, 0x83, 0xE0, 0x22, 0x74, 0xA0,
-/*08F0*/0x2E, 0xF5, 0x82, 0xE4, 0x34, 0x02, 0xF5, 0x83,
-	0xE0, 0x22, 0x74, 0x80, 0x25, 0x6E, 0xF5, 0x82,
-/*0900*/0xE4, 0x34, 0x00, 0x22, 0x25, 0x42, 0xFD, 0xE4,
-	0x33, 0xFC, 0x22, 0x85, 0x42, 0x42, 0x85, 0x41,
-/*0910*/0x41, 0x85, 0x40, 0x40, 0x22, 0xED, 0x4C, 0x60,
-	0x03, 0x02, 0x09, 0xE5, 0xEF, 0x4E, 0x70, 0x37,
-/*0920*/0x90, 0x07, 0x26, 0x12, 0x07, 0x89, 0xE0, 0xFD,
-	0x12, 0x07, 0xCC, 0xED, 0xF0, 0x90, 0x07, 0x28,
-/*0930*/0x12, 0x07, 0x89, 0xE0, 0xFD, 0x12, 0x07, 0xD8,
-	0xED, 0xF0, 0x12, 0x07, 0x86, 0xE0, 0x54, 0x1F,
-/*0940*/0xFD, 0x12, 0x08, 0x81, 0xF5, 0x83, 0xED, 0xF0,
-	0x90, 0x07, 0x24, 0x12, 0x07, 0x89, 0xE0, 0x54,
-/*0950*/0x1F, 0xFD, 0x12, 0x08, 0x35, 0xED, 0xF0, 0xEF,
-	0x64, 0x04, 0x4E, 0x70, 0x37, 0x90, 0x07, 0x26,
-/*0960*/0x12, 0x07, 0x89, 0xE0, 0xFD, 0x12, 0x07, 0xE4,
-	0xED, 0xF0, 0x90, 0x07, 0x28, 0x12, 0x07, 0x89,
-/*0970*/0xE0, 0xFD, 0x12, 0x07, 0xF0, 0xED, 0xF0, 0x12,
-	0x07, 0x86, 0xE0, 0x54, 0x1F, 0xFD, 0x12, 0x08,
-/*0980*/0x8B, 0xF5, 0x83, 0xED, 0xF0, 0x90, 0x07, 0x24,
-	0x12, 0x07, 0x89, 0xE0, 0x54, 0x1F, 0xFD, 0x12,
-/*0990*/0x08, 0x41, 0xED, 0xF0, 0xEF, 0x64, 0x01, 0x4E,
-	0x70, 0x04, 0x7D, 0x01, 0x80, 0x02, 0x7D, 0x00,
-/*09A0*/0xEF, 0x64, 0x02, 0x4E, 0x70, 0x04, 0x7F, 0x01,
-	0x80, 0x02, 0x7F, 0x00, 0xEF, 0x4D, 0x60, 0x78,
-/*09B0*/0x90, 0x07, 0x26, 0x12, 0x07, 0x35, 0xE0, 0xFF,
-	0x12, 0x07, 0xFC, 0xEF, 0x12, 0x07, 0x31, 0xE0,
-/*09C0*/0xFF, 0x12, 0x08, 0x08, 0xEF, 0xF0, 0x90, 0x07,
-	0x22, 0x12, 0x07, 0x35, 0xE0, 0x54, 0x1F, 0xFF,
-/*09D0*/0x12, 0x08, 0x4D, 0xEF, 0xF0, 0x90, 0x07, 0x24,
-	0x12, 0x07, 0x35, 0xE0, 0x54, 0x1F, 0xFF, 0x12,
-/*09E0*/0x08, 0x59, 0xEF, 0xF0, 0x22, 0x12, 0x07, 0xCC,
-	0xE4, 0xF0, 0x12, 0x07, 0xD8, 0xE4, 0xF0, 0x12,
-/*09F0*/0x08, 0x81, 0xF5, 0x83, 0xE4, 0xF0, 0x12, 0x08,
-	0x35, 0x74, 0x14, 0xF0, 0x12, 0x07, 0xE4, 0xE4,
-/*0A00*/0xF0, 0x12, 0x07, 0xF0, 0xE4, 0xF0, 0x12, 0x08,
-	0x8B, 0xF5, 0x83, 0xE4, 0xF0, 0x12, 0x08, 0x41,
-/*0A10*/0x74, 0x14, 0xF0, 0x12, 0x07, 0xFC, 0xE4, 0xF0,
-	0x12, 0x08, 0x08, 0xE4, 0xF0, 0x12, 0x08, 0x4D,
-/*0A20*/0xE4, 0xF0, 0x12, 0x08, 0x59, 0x74, 0x14, 0xF0,
-	0x22, 0x53, 0xF9, 0xF7, 0x75, 0xFC, 0x10, 0xE4,
-/*0A30*/0xF5, 0xFD, 0x75, 0xFE, 0x30, 0xF5, 0xFF, 0xE5,
-	0xE7, 0x20, 0xE7, 0x03, 0x43, 0xF9, 0x08, 0xE5,
-/*0A40*/0xE6, 0x20, 0xE7, 0x0B, 0x78, 0xFF, 0xE4, 0xF6,
-	0xD8, 0xFD, 0x53, 0xE6, 0xFE, 0x80, 0x09, 0x78,
-/*0A50*/0x08, 0xE4, 0xF6, 0xD8, 0xFD, 0x53, 0xE6, 0xFE,
-	0x75, 0x81, 0x80, 0xE4, 0xF5, 0xA8, 0xD2, 0xA8,
-/*0A60*/0xC2, 0xA9, 0xD2, 0xAF, 0xE5, 0xE2, 0x20, 0xE5,
-	0x05, 0x20, 0xE6, 0x02, 0x80, 0x03, 0x43, 0xE1,
-/*0A70*/0x02, 0xE5, 0xE2, 0x20, 0xE0, 0x0E, 0x90, 0x00,
-	0x00, 0x7F, 0x00, 0x7E, 0x08, 0xE4, 0xF0, 0xA3,
-/*0A80*/0xDF, 0xFC, 0xDE, 0xFA, 0x02, 0x0A, 0xDB, 0x43,
-	0xFA, 0x01, 0xC0, 0xE0, 0xC0, 0xF0, 0xC0, 0x83,
-/*0A90*/0xC0, 0x82, 0xC0, 0xD0, 0x12, 0x1C, 0xE7, 0xD0,
-	0xD0, 0xD0, 0x82, 0xD0, 0x83, 0xD0, 0xF0, 0xD0,
-/*0AA0*/0xE0, 0x53, 0xFA, 0xFE, 0x32, 0x02, 0x1B, 0x55,
-	0xE4, 0x93, 0xA3, 0xF8, 0xE4, 0x93, 0xA3, 0xF6,
-/*0AB0*/0x08, 0xDF, 0xF9, 0x80, 0x29, 0xE4, 0x93, 0xA3,
-	0xF8, 0x54, 0x07, 0x24, 0x0C, 0xC8, 0xC3, 0x33,
-/*0AC0*/0xC4, 0x54, 0x0F, 0x44, 0x20, 0xC8, 0x83, 0x40,
-	0x04, 0xF4, 0x56, 0x80, 0x01, 0x46, 0xF6, 0xDF,
-/*0AD0*/0xE4, 0x80, 0x0B, 0x01, 0x02, 0x04, 0x08, 0x10,
-	0x20, 0x40, 0x80, 0x90, 0x00, 0x3F, 0xE4, 0x7E,
-/*0AE0*/0x01, 0x93, 0x60, 0xC1, 0xA3, 0xFF, 0x54, 0x3F,
-	0x30, 0xE5, 0x09, 0x54, 0x1F, 0xFE, 0xE4, 0x93,
-/*0AF0*/0xA3, 0x60, 0x01, 0x0E, 0xCF, 0x54, 0xC0, 0x25,
-	0xE0, 0x60, 0xAD, 0x40, 0xB8, 0x80, 0xFE, 0x8C,
-/*0B00*/0x64, 0x8D, 0x65, 0x8A, 0x66, 0x8B, 0x67, 0xE4,
-	0xF5, 0x69, 0xEF, 0x4E, 0x70, 0x03, 0x02, 0x1D,
-/*0B10*/0x55, 0xE4, 0xF5, 0x68, 0xE5, 0x67, 0x45, 0x66,
-	0x70, 0x32, 0x12, 0x07, 0x2A, 0x75, 0x83, 0x90,
-/*0B20*/0xE4, 0x12, 0x07, 0x29, 0x75, 0x83, 0xC2, 0xE4,
-	0x12, 0x07, 0x29, 0x75, 0x83, 0xC4, 0xE4, 0x12,
-/*0B30*/0x08, 0x70, 0x70, 0x29, 0x12, 0x07, 0x2A, 0x75,
-	0x83, 0x92, 0xE4, 0x12, 0x07, 0x29, 0x75, 0x83,
-/*0B40*/0xC6, 0xE4, 0x12, 0x07, 0x29, 0x75, 0x83, 0xC8,
-	0xE4, 0xF0, 0x80, 0x11, 0x90, 0x07, 0x26, 0x12,
-/*0B50*/0x07, 0x35, 0xE4, 0x12, 0x08, 0x70, 0x70, 0x05,
-	0x12, 0x07, 0x32, 0xE4, 0xF0, 0x12, 0x1D, 0x55,
-/*0B60*/0x12, 0x1E, 0xBF, 0xE5, 0x67, 0x45, 0x66, 0x70,
-	0x33, 0x12, 0x07, 0x2A, 0x75, 0x83, 0x90, 0xE5,
-/*0B70*/0x41, 0x12, 0x07, 0x29, 0x75, 0x83, 0xC2, 0xE5,
-	0x41, 0x12, 0x07, 0x29, 0x75, 0x83, 0xC4, 0x12,
-/*0B80*/0x08, 0x6E, 0x70, 0x29, 0x12, 0x07, 0x2A, 0x75,
-	0x83, 0x92, 0xE5, 0x40, 0x12, 0x07, 0x29, 0x75,
-/*0B90*/0x83, 0xC6, 0xE5, 0x40, 0x12, 0x07, 0x29, 0x75,
-	0x83, 0xC8, 0x80, 0x0E, 0x90, 0x07, 0x26, 0x12,
-/*0BA0*/0x07, 0x35, 0x12, 0x08, 0x6E, 0x70, 0x06, 0x12,
-	0x07, 0x32, 0xE5, 0x40, 0xF0, 0xAF, 0x69, 0x7E,
-/*0BB0*/0x00, 0xAD, 0x67, 0xAC, 0x66, 0x12, 0x04, 0x44,
-	0x12, 0x07, 0x2A, 0x75, 0x83, 0xCA, 0xE0, 0xD3,
-/*0BC0*/0x94, 0x00, 0x50, 0x0C, 0x05, 0x68, 0xE5, 0x68,
-	0xC3, 0x94, 0x05, 0x50, 0x03, 0x02, 0x0B, 0x14,
-/*0BD0*/0x22, 0x8C, 0x60, 0x8D, 0x61, 0x12, 0x08, 0xDA,
-	0x74, 0x20, 0x40, 0x0D, 0x2F, 0xF5, 0x82, 0x74,
-/*0BE0*/0x03, 0x3E, 0xF5, 0x83, 0xE5, 0x3E, 0xF0, 0x80,
-	0x0B, 0x2F, 0xF5, 0x82, 0x74, 0x03, 0x3E, 0xF5,
-/*0BF0*/0x83, 0xE5, 0x3C, 0xF0, 0xE5, 0x3C, 0xD3, 0x95,
-	0x3E, 0x40, 0x3C, 0xE5, 0x61, 0x45, 0x60, 0x70,
-/*0C00*/0x10, 0xE9, 0x12, 0x09, 0x04, 0xE5, 0x3E, 0x12,
-	0x07, 0x68, 0x40, 0x3B, 0x12, 0x08, 0x95, 0x80,
-/*0C10*/0x18, 0xE5, 0x3E, 0xC3, 0x95, 0x38, 0x40, 0x1D,
-	0x85, 0x3E, 0x38, 0xE5, 0x3E, 0x60, 0x05, 0x85,
-/*0C20*/0x3F, 0x39, 0x80, 0x03, 0x85, 0x39, 0x39, 0x8F,
-	0x3A, 0x12, 0x08, 0x14, 0xE5, 0x3E, 0x12, 0x07,
-/*0C30*/0xC0, 0xE5, 0x3F, 0xF0, 0x22, 0x80, 0x43, 0xE5,
-	0x61, 0x45, 0x60, 0x70, 0x19, 0x12, 0x07, 0x5F,
-/*0C40*/0x40, 0x05, 0x12, 0x08, 0x9E, 0x80, 0x27, 0x12,
-	0x09, 0x0B, 0x12, 0x08, 0x14, 0xE5, 0x42, 0x12,
-/*0C50*/0x07, 0xC0, 0xE5, 0x41, 0xF0, 0x22, 0xE5, 0x3C,
-	0xC3, 0x95, 0x38, 0x40, 0x1D, 0x85, 0x3C, 0x38,
-/*0C60*/0xE5, 0x3C, 0x60, 0x05, 0x85, 0x3D, 0x39, 0x80,
-	0x03, 0x85, 0x39, 0x39, 0x8F, 0x3A, 0x12, 0x08,
-/*0C70*/0x14, 0xE5, 0x3C, 0x12, 0x07, 0xC0, 0xE5, 0x3D,
-	0xF0, 0x22, 0x85, 0x38, 0x38, 0x85, 0x39, 0x39,
-/*0C80*/0x85, 0x3A, 0x3A, 0x12, 0x08, 0x14, 0xE5, 0x38,
-	0x12, 0x07, 0xC0, 0xE5, 0x39, 0xF0, 0x22, 0x7F,
-/*0C90*/0x06, 0x12, 0x17, 0x31, 0x12, 0x1D, 0x23, 0x12,
-	0x0E, 0x04, 0x12, 0x0E, 0x33, 0xE0, 0x44, 0x0A,
-/*0CA0*/0xF0, 0x74, 0x8E, 0xFE, 0x12, 0x0E, 0x04, 0x12,
-	0x0E, 0x0B, 0xEF, 0xF0, 0xE5, 0x28, 0x30, 0xE5,
-/*0CB0*/0x03, 0xD3, 0x80, 0x01, 0xC3, 0x40, 0x05, 0x75,
-	0x14, 0x20, 0x80, 0x03, 0x75, 0x14, 0x08, 0x12,
-/*0CC0*/0x0E, 0x04, 0x75, 0x83, 0x8A, 0xE5, 0x14, 0xF0,
-	0xB4, 0xFF, 0x05, 0x75, 0x12, 0x80, 0x80, 0x06,
-/*0CD0*/0xE5, 0x14, 0xC3, 0x13, 0xF5, 0x12, 0xE4, 0xF5,
-	0x16, 0xF5, 0x7F, 0x12, 0x19, 0x36, 0x12, 0x13,
-/*0CE0*/0xA3, 0xE5, 0x0A, 0xC3, 0x94, 0x01, 0x50, 0x09,
-	0x05, 0x16, 0xE5, 0x16, 0xC3, 0x94, 0x14, 0x40,
-/*0CF0*/0xEA, 0xE5, 0xE4, 0x20, 0xE7, 0x28, 0x12, 0x0E,
-	0x04, 0x75, 0x83, 0xD2, 0xE0, 0x54, 0x08, 0xD3,
-/*0D00*/0x94, 0x00, 0x40, 0x04, 0x7F, 0x01, 0x80, 0x02,
-	0x7F, 0x00, 0xE5, 0x0A, 0xC3, 0x94, 0x01, 0x40,
-/*0D10*/0x04, 0x7E, 0x01, 0x80, 0x02, 0x7E, 0x00, 0xEF,
-	0x5E, 0x60, 0x03, 0x12, 0x1D, 0xD7, 0xE5, 0x7F,
-/*0D20*/0xC3, 0x94, 0x11, 0x40, 0x14, 0x12, 0x0E, 0x04,
-	0x75, 0x83, 0xD2, 0xE0, 0x44, 0x80, 0xF0, 0xE5,
-/*0D30*/0xE4, 0x20, 0xE7, 0x0F, 0x12, 0x1D, 0xD7, 0x80,
-	0x0A, 0x12, 0x0E, 0x04, 0x75, 0x83, 0xD2, 0xE0,
-/*0D40*/0x54, 0x7F, 0xF0, 0x12, 0x1D, 0x23, 0x22, 0x74,
-	0x8A, 0x85, 0x08, 0x82, 0xF5, 0x83, 0xE5, 0x17,
-/*0D50*/0xF0, 0x12, 0x0E, 0x3A, 0xE4, 0xF0, 0x90, 0x07,
-	0x02, 0xE0, 0x12, 0x0E, 0x17, 0x75, 0x83, 0x90,
-/*0D60*/0xEF, 0xF0, 0x74, 0x92, 0xFE, 0xE5, 0x08, 0x44,
-	0x07, 0xFF, 0xF5, 0x82, 0x8E, 0x83, 0xE0, 0x54,
-/*0D70*/0xC0, 0xFD, 0x90, 0x07, 0x03, 0xE0, 0x54, 0x3F,
-	0x4D, 0x8F, 0x82, 0x8E, 0x83, 0xF0, 0x90, 0x07,
-/*0D80*/0x04, 0xE0, 0x12, 0x0E, 0x17, 0x75, 0x83, 0x82,
-	0xEF, 0xF0, 0x90, 0x07, 0x05, 0xE0, 0xFF, 0xED,
-/*0D90*/0x44, 0x07, 0xF5, 0x82, 0x75, 0x83, 0xB4, 0xEF,
-	0x12, 0x0E, 0x03, 0x75, 0x83, 0x80, 0xE0, 0x54,
-/*0DA0*/0xBF, 0xF0, 0x30, 0x37, 0x0A, 0x12, 0x0E, 0x91,
-	0x75, 0x83, 0x94, 0xE0, 0x44, 0x80, 0xF0, 0x30,
-/*0DB0*/0x38, 0x0A, 0x12, 0x0E, 0x91, 0x75, 0x83, 0x92,
-	0xE0, 0x44, 0x80, 0xF0, 0xE5, 0x28, 0x30, 0xE4,
-/*0DC0*/0x1A, 0x20, 0x39, 0x0A, 0x12, 0x0E, 0x04, 0x75,
-	0x83, 0x88, 0xE0, 0x54, 0x7F, 0xF0, 0x20, 0x3A,
-/*0DD0*/0x0A, 0x12, 0x0E, 0x04, 0x75, 0x83, 0x88, 0xE0,
-	0x54, 0xBF, 0xF0, 0x74, 0x8C, 0xFE, 0x12, 0x0E,
-/*0DE0*/0x04, 0x8E, 0x83, 0xE0, 0x54, 0x0F, 0x12, 0x0E,
-	0x03, 0x75, 0x83, 0x86, 0xE0, 0x54, 0xBF, 0xF0,
-/*0DF0*/0xE5, 0x08, 0x44, 0x06, 0x12, 0x0D, 0xFD, 0x75,
-	0x83, 0x8A, 0xE4, 0xF0, 0x22, 0xF5, 0x82, 0x75,
-/*0E00*/0x83, 0x82, 0xE4, 0xF0, 0xE5, 0x08, 0x44, 0x07,
-	0xF5, 0x82, 0x22, 0x8E, 0x83, 0xE0, 0xF5, 0x10,
-/*0E10*/0x54, 0xFE, 0xF0, 0xE5, 0x10, 0x44, 0x01, 0xFF,
-	0xE5, 0x08, 0xFD, 0xED, 0x44, 0x07, 0xF5, 0x82,
-/*0E20*/0x22, 0xE5, 0x15, 0xC4, 0x54, 0x07, 0xFF, 0xE5,
-	0x08, 0xFD, 0xED, 0x44, 0x08, 0xF5, 0x82, 0x75,
-/*0E30*/0x83, 0x82, 0x22, 0x75, 0x83, 0x80, 0xE0, 0x44,
-	0x40, 0xF0, 0xE5, 0x08, 0x44, 0x08, 0xF5, 0x82,
-/*0E40*/0x75, 0x83, 0x8A, 0x22, 0xE5, 0x16, 0x25, 0xE0,
-	0x25, 0xE0, 0x24, 0xAF, 0xF5, 0x82, 0xE4, 0x34,
-/*0E50*/0x1A, 0xF5, 0x83, 0xE4, 0x93, 0xF5, 0x0D, 0x22,
-	0x43, 0xE1, 0x10, 0x43, 0xE1, 0x80, 0x53, 0xE1,
-/*0E60*/0xFD, 0x85, 0xE1, 0x10, 0x22, 0xE5, 0x16, 0x25,
-	0xE0, 0x25, 0xE0, 0x24, 0xB2, 0xF5, 0x82, 0xE4,
-/*0E70*/0x34, 0x1A, 0xF5, 0x83, 0xE4, 0x93, 0x22, 0x85,
-	0x55, 0x82, 0x85, 0x54, 0x83, 0xE5, 0x15, 0xF0,
-/*0E80*/0x22, 0xE5, 0xE2, 0x54, 0x20, 0xD3, 0x94, 0x00,
-	0x22, 0xE5, 0xE2, 0x54, 0x40, 0xD3, 0x94, 0x00,
-/*0E90*/0x22, 0xE5, 0x08, 0x44, 0x06, 0xF5, 0x82, 0x22,
-	0xFD, 0xE5, 0x08, 0xFB, 0xEB, 0x44, 0x07, 0xF5,
-/*0EA0*/0x82, 0x22, 0x53, 0xF9, 0xF7, 0x75, 0xFE, 0x30,
-	0x22, 0xEF, 0x4E, 0x70, 0x26, 0x12, 0x07, 0xCC,
-/*0EB0*/0xE0, 0xFD, 0x90, 0x07, 0x26, 0x12, 0x07, 0x7B,
-	0x12, 0x07, 0xD8, 0xE0, 0xFD, 0x90, 0x07, 0x28,
-/*0EC0*/0x12, 0x07, 0x7B, 0x12, 0x08, 0x81, 0x12, 0x07,
-	0x72, 0x12, 0x08, 0x35, 0xE0, 0x90, 0x07, 0x24,
-/*0ED0*/0x12, 0x07, 0x78, 0xEF, 0x64, 0x04, 0x4E, 0x70,
-	0x29, 0x12, 0x07, 0xE4, 0xE0, 0xFD, 0x90, 0x07,
-/*0EE0*/0x26, 0x12, 0x07, 0x7B, 0x12, 0x07, 0xF0, 0xE0,
-	0xFD, 0x90, 0x07, 0x28, 0x12, 0x07, 0x7B, 0x12,
-/*0EF0*/0x08, 0x8B, 0x12, 0x07, 0x72, 0x12, 0x08, 0x41,
-	0xE0, 0x54, 0x1F, 0xFD, 0x90, 0x07, 0x24, 0x12,
-/*0F00*/0x07, 0x7B, 0xEF, 0x64, 0x01, 0x4E, 0x70, 0x04,
-	0x7D, 0x01, 0x80, 0x02, 0x7D, 0x00, 0xEF, 0x64,
-/*0F10*/0x02, 0x4E, 0x70, 0x04, 0x7F, 0x01, 0x80, 0x02,
-	0x7F, 0x00, 0xEF, 0x4D, 0x60, 0x35, 0x12, 0x07,
-/*0F20*/0xFC, 0xE0, 0xFF, 0x90, 0x07, 0x26, 0x12, 0x07,
-	0x89, 0xEF, 0xF0, 0x12, 0x08, 0x08, 0xE0, 0xFF,
-/*0F30*/0x90, 0x07, 0x28, 0x12, 0x07, 0x89, 0xEF, 0xF0,
-	0x12, 0x08, 0x4D, 0xE0, 0x54, 0x1F, 0xFF, 0x12,
-/*0F40*/0x07, 0x86, 0xEF, 0xF0, 0x12, 0x08, 0x59, 0xE0,
-	0x54, 0x1F, 0xFF, 0x90, 0x07, 0x24, 0x12, 0x07,
-/*0F50*/0x89, 0xEF, 0xF0, 0x22, 0xE4, 0xF5, 0x53, 0x12,
-	0x0E, 0x81, 0x40, 0x04, 0x7F, 0x01, 0x80, 0x02,
-/*0F60*/0x7F, 0x00, 0x12, 0x0E, 0x89, 0x40, 0x04, 0x7E,
-	0x01, 0x80, 0x02, 0x7E, 0x00, 0xEE, 0x4F, 0x70,
-/*0F70*/0x03, 0x02, 0x0F, 0xF6, 0x85, 0xE1, 0x10, 0x43,
-	0xE1, 0x02, 0x53, 0xE1, 0x0F, 0x85, 0xE1, 0x10,
-/*0F80*/0xE4, 0xF5, 0x51, 0xE5, 0xE3, 0x54, 0x3F, 0xF5,
-	0x52, 0x12, 0x0E, 0x89, 0x40, 0x1D, 0xAD, 0x52,
-/*0F90*/0xAF, 0x51, 0x12, 0x11, 0x18, 0xEF, 0x60, 0x08,
-	0x85, 0xE1, 0x10, 0x43, 0xE1, 0x40, 0x80, 0x0B,
-/*0FA0*/0x53, 0xE1, 0xBF, 0x12, 0x0E, 0x58, 0x12, 0x00,
-	0x06, 0x80, 0xFB, 0xE5, 0xE3, 0x54, 0x3F, 0xF5,
-/*0FB0*/0x51, 0xE5, 0xE4, 0x54, 0x3F, 0xF5, 0x52, 0x12,
-	0x0E, 0x81, 0x40, 0x1D, 0xAD, 0x52, 0xAF, 0x51,
-/*0FC0*/0x12, 0x11, 0x18, 0xEF, 0x60, 0x08, 0x85, 0xE1,
-	0x10, 0x43, 0xE1, 0x20, 0x80, 0x0B, 0x53, 0xE1,
-/*0FD0*/0xDF, 0x12, 0x0E, 0x58, 0x12, 0x00, 0x06, 0x80,
-	0xFB, 0x12, 0x0E, 0x81, 0x40, 0x04, 0x7F, 0x01,
-/*0FE0*/0x80, 0x02, 0x7F, 0x00, 0x12, 0x0E, 0x89, 0x40,
-	0x04, 0x7E, 0x01, 0x80, 0x02, 0x7E, 0x00, 0xEE,
-/*0FF0*/0x4F, 0x60, 0x03, 0x12, 0x0E, 0x5B, 0x22, 0x12,
-	0x0E, 0x21, 0xEF, 0xF0, 0x12, 0x10, 0x91, 0x22,
-/*1000*/0x02, 0x11, 0x00, 0x02, 0x10, 0x40, 0x02, 0x10,
-	0x90, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-/*1010*/0x01, 0x20, 0x01, 0x20, 0xE4, 0xF5, 0x57, 0x12,
-	0x16, 0xBD, 0x12, 0x16, 0x44, 0xE4, 0x12, 0x10,
-/*1020*/0x56, 0x12, 0x14, 0xB7, 0x90, 0x07, 0x26, 0x12,
-	0x07, 0x35, 0xE4, 0x12, 0x07, 0x31, 0xE4, 0xF0,
-/*1030*/0x12, 0x10, 0x56, 0x12, 0x14, 0xB7, 0x90, 0x07,
-	0x26, 0x12, 0x07, 0x35, 0xE5, 0x41, 0x12, 0x07,
-/*1040*/0x31, 0xE5, 0x40, 0xF0, 0xAF, 0x57, 0x7E, 0x00,
-	0xAD, 0x56, 0x7C, 0x00, 0x12, 0x04, 0x44, 0xAF,
-/*1050*/0x56, 0x7E, 0x00, 0x02, 0x11, 0xEE, 0xFF, 0x90,
-	0x07, 0x20, 0xA3, 0xE0, 0xFD, 0xE4, 0xF5, 0x56,
-/*1060*/0xF5, 0x40, 0xFE, 0xFC, 0xAB, 0x56, 0xFA, 0x12,
-	0x11, 0x51, 0x7F, 0x0F, 0x7D, 0x18, 0xE4, 0xF5,
-/*1070*/0x56, 0xF5, 0x40, 0xFE, 0xFC, 0xAB, 0x56, 0xFA,
-	0x12, 0x15, 0x41, 0xAF, 0x56, 0x7E, 0x00, 0x12,
-/*1080*/0x1A, 0xFF, 0xE4, 0xFF, 0xF5, 0x56, 0x7D, 0x1F,
-	0xF5, 0x40, 0xFE, 0xFC, 0xAB, 0x56, 0xFA, 0x22,
-/*1090*/0x22, 0xE4, 0xF5, 0x55, 0xE5, 0x08, 0xFD, 0x74,
-	0xA0, 0xF5, 0x56, 0xED, 0x44, 0x07, 0xF5, 0x57,
-/*10A0*/0xE5, 0x28, 0x30, 0xE5, 0x03, 0xD3, 0x80, 0x01,
-	0xC3, 0x40, 0x05, 0x7F, 0x28, 0xEF, 0x80, 0x04,
-/*10B0*/0x7F, 0x14, 0xEF, 0xC3, 0x13, 0xF5, 0x54, 0xE4,
-	0xF9, 0x12, 0x0E, 0x18, 0x75, 0x83, 0x8E, 0xE0,
-/*10C0*/0xF5, 0x10, 0xCE, 0xEF, 0xCE, 0xEE, 0xD3, 0x94,
-	0x00, 0x40, 0x26, 0xE5, 0x10, 0x54, 0xFE, 0x12,
-/*10D0*/0x0E, 0x98, 0x75, 0x83, 0x8E, 0xED, 0xF0, 0xE5,
-	0x10, 0x44, 0x01, 0xFD, 0xEB, 0x44, 0x07, 0xF5,
-/*10E0*/0x82, 0xED, 0xF0, 0x85, 0x57, 0x82, 0x85, 0x56,
-	0x83, 0xE0, 0x30, 0xE3, 0x01, 0x09, 0x1E, 0x80,
-/*10F0*/0xD4, 0xC2, 0x34, 0xE9, 0xC3, 0x95, 0x54, 0x40,
-	0x02, 0xD2, 0x34, 0x22, 0x02, 0x00, 0x06, 0x22,
-/*1100*/0x30, 0x30, 0x11, 0x90, 0x10, 0x00, 0xE4, 0x93,
-	0xF5, 0x10, 0x90, 0x10, 0x10, 0xE4, 0x93, 0xF5,
-/*1110*/0x10, 0x12, 0x10, 0x90, 0x12, 0x11, 0x50, 0x22,
-	0xE4, 0xFC, 0xC3, 0xED, 0x9F, 0xFA, 0xEF, 0xF5,
-/*1120*/0x83, 0x75, 0x82, 0x00, 0x79, 0xFF, 0xE4, 0x93,
-	0xCC, 0x6C, 0xCC, 0xA3, 0xD9, 0xF8, 0xDA, 0xF6,
-/*1130*/0xE5, 0xE2, 0x30, 0xE4, 0x02, 0x8C, 0xE5, 0xED,
-	0x24, 0xFF, 0xFF, 0xEF, 0x75, 0x82, 0xFF, 0xF5,
-/*1140*/0x83, 0xE4, 0x93, 0x6C, 0x70, 0x03, 0x7F, 0x01,
-	0x22, 0x7F, 0x00, 0x22, 0x22, 0x11, 0x00, 0x00,
-/*1150*/0x22, 0x8E, 0x58, 0x8F, 0x59, 0x8C, 0x5A, 0x8D,
-	0x5B, 0x8A, 0x5C, 0x8B, 0x5D, 0x75, 0x5E, 0x01,
-/*1160*/0xE4, 0xF5, 0x5F, 0xF5, 0x60, 0xF5, 0x62, 0x12,
-	0x07, 0x2A, 0x75, 0x83, 0xD0, 0xE0, 0xFF, 0xC4,
-/*1170*/0x54, 0x0F, 0xF5, 0x61, 0x12, 0x1E, 0xA5, 0x85,
-	0x59, 0x5E, 0xD3, 0xE5, 0x5E, 0x95, 0x5B, 0xE5,
-/*1180*/0x5A, 0x12, 0x07, 0x6B, 0x50, 0x4B, 0x12, 0x07,
-	0x03, 0x75, 0x83, 0xBC, 0xE0, 0x45, 0x5E, 0x12,
-/*1190*/0x07, 0x29, 0x75, 0x83, 0xBE, 0xE0, 0x45, 0x5E,
-	0x12, 0x07, 0x29, 0x75, 0x83, 0xC0, 0xE0, 0x45,
-/*11A0*/0x5E, 0xF0, 0xAF, 0x5F, 0xE5, 0x60, 0x12, 0x08,
-	0x78, 0x12, 0x0A, 0xFF, 0xAF, 0x62, 0x7E, 0x00,
-/*11B0*/0xAD, 0x5D, 0xAC, 0x5C, 0x12, 0x04, 0x44, 0xE5,
-	0x61, 0xAF, 0x5E, 0x7E, 0x00, 0xB4, 0x03, 0x05,
-/*11C0*/0x12, 0x1E, 0x21, 0x80, 0x07, 0xAD, 0x5D, 0xAC,
-	0x5C, 0x12, 0x13, 0x17, 0x05, 0x5E, 0x02, 0x11,
-/*11D0*/0x7A, 0x12, 0x07, 0x03, 0x75, 0x83, 0xBC, 0xE0,
-	0x45, 0x40, 0x12, 0x07, 0x29, 0x75, 0x83, 0xBE,
-/*11E0*/0xE0, 0x45, 0x40, 0x12, 0x07, 0x29, 0x75, 0x83,
-	0xC0, 0xE0, 0x45, 0x40, 0xF0, 0x22, 0x8E, 0x58,
-/*11F0*/0x8F, 0x59, 0x75, 0x5A, 0x01, 0x79, 0x01, 0x75,
-	0x5B, 0x01, 0xE4, 0xFB, 0x12, 0x07, 0x2A, 0x75,
-/*1200*/0x83, 0xAE, 0xE0, 0x54, 0x1A, 0xFF, 0x12, 0x08,
-	0x65, 0xE0, 0xC4, 0x13, 0x54, 0x07, 0xFE, 0xEF,
-/*1210*/0x70, 0x0C, 0xEE, 0x65, 0x35, 0x70, 0x07, 0x90,
-	0x07, 0x2F, 0xE0, 0xB4, 0x01, 0x0D, 0xAF, 0x35,
-/*1220*/0x7E, 0x00, 0x12, 0x0E, 0xA9, 0xCF, 0xEB, 0xCF,
-	0x02, 0x1E, 0x60, 0xE5, 0x59, 0x64, 0x02, 0x45,
-/*1230*/0x58, 0x70, 0x04, 0x7F, 0x01, 0x80, 0x02, 0x7F,
-	0x00, 0xE5, 0x59, 0x45, 0x58, 0x70, 0x04, 0x7E,
-/*1240*/0x01, 0x80, 0x02, 0x7E, 0x00, 0xEE, 0x4F, 0x60,
-	0x23, 0x85, 0x41, 0x49, 0x85, 0x40, 0x4B, 0xE5,
-/*1250*/0x59, 0x45, 0x58, 0x70, 0x2C, 0xAF, 0x5A, 0xFE,
-	0xCD, 0xE9, 0xCD, 0xFC, 0xAB, 0x59, 0xAA, 0x58,
-/*1260*/0x12, 0x0A, 0xFF, 0xAF, 0x5B, 0x7E, 0x00, 0x12,
-	0x1E, 0x60, 0x80, 0x15, 0xAF, 0x5B, 0x7E, 0x00,
-/*1270*/0x12, 0x1E, 0x60, 0x90, 0x07, 0x26, 0x12, 0x07,
-	0x35, 0xE5, 0x49, 0x12, 0x07, 0x31, 0xE5, 0x4B,
-/*1280*/0xF0, 0xE4, 0xFD, 0xAF, 0x35, 0xFE, 0xFC, 0x12,
-	0x09, 0x15, 0x22, 0x8C, 0x64, 0x8D, 0x65, 0x12,
-/*1290*/0x08, 0xDA, 0x40, 0x3C, 0xE5, 0x65, 0x45, 0x64,
-	0x70, 0x10, 0x12, 0x09, 0x04, 0xC3, 0xE5, 0x3E,
-/*12A0*/0x12, 0x07, 0x69, 0x40, 0x3B, 0x12, 0x08, 0x95,
-	0x80, 0x18, 0xE5, 0x3E, 0xC3, 0x95, 0x38, 0x40,
-/*12B0*/0x1D, 0x85, 0x3E, 0x38, 0xE5, 0x3E, 0x60, 0x05,
-	0x85, 0x3F, 0x39, 0x80, 0x03, 0x85, 0x39, 0x39,
-/*12C0*/0x8F, 0x3A, 0x12, 0x07, 0xA8, 0xE5, 0x3E, 0x12,
-	0x07, 0x53, 0xE5, 0x3F, 0xF0, 0x22, 0x80, 0x3B,
-/*12D0*/0xE5, 0x65, 0x45, 0x64, 0x70, 0x11, 0x12, 0x07,
-	0x5F, 0x40, 0x05, 0x12, 0x08, 0x9E, 0x80, 0x1F,
-/*12E0*/0x12, 0x07, 0x3E, 0xE5, 0x41, 0xF0, 0x22, 0xE5,
-	0x3C, 0xC3, 0x95, 0x38, 0x40, 0x1D, 0x85, 0x3C,
-/*12F0*/0x38, 0xE5, 0x3C, 0x60, 0x05, 0x85, 0x3D, 0x39,
-	0x80, 0x03, 0x85, 0x39, 0x39, 0x8F, 0x3A, 0x12,
-/*1300*/0x07, 0xA8, 0xE5, 0x3C, 0x12, 0x07, 0x53, 0xE5,
-	0x3D, 0xF0, 0x22, 0x12, 0x07, 0x9F, 0xE5, 0x38,
-/*1310*/0x12, 0x07, 0x53, 0xE5, 0x39, 0xF0, 0x22, 0x8C,
-	0x63, 0x8D, 0x64, 0x12, 0x08, 0xDA, 0x40, 0x3C,
-/*1320*/0xE5, 0x64, 0x45, 0x63, 0x70, 0x10, 0x12, 0x09,
-	0x04, 0xC3, 0xE5, 0x3E, 0x12, 0x07, 0x69, 0x40,
-/*1330*/0x3B, 0x12, 0x08, 0x95, 0x80, 0x18, 0xE5, 0x3E,
-	0xC3, 0x95, 0x38, 0x40, 0x1D, 0x85, 0x3E, 0x38,
-/*1340*/0xE5, 0x3E, 0x60, 0x05, 0x85, 0x3F, 0x39, 0x80,
-	0x03, 0x85, 0x39, 0x39, 0x8F, 0x3A, 0x12, 0x07,
-/*1350*/0xA8, 0xE5, 0x3E, 0x12, 0x07, 0x53, 0xE5, 0x3F,
-	0xF0, 0x22, 0x80, 0x3B, 0xE5, 0x64, 0x45, 0x63,
-/*1360*/0x70, 0x11, 0x12, 0x07, 0x5F, 0x40, 0x05, 0x12,
-	0x08, 0x9E, 0x80, 0x1F, 0x12, 0x07, 0x3E, 0xE5,
-/*1370*/0x41, 0xF0, 0x22, 0xE5, 0x3C, 0xC3, 0x95, 0x38,
-	0x40, 0x1D, 0x85, 0x3C, 0x38, 0xE5, 0x3C, 0x60,
-/*1380*/0x05, 0x85, 0x3D, 0x39, 0x80, 0x03, 0x85, 0x39,
-	0x39, 0x8F, 0x3A, 0x12, 0x07, 0xA8, 0xE5, 0x3C,
-/*1390*/0x12, 0x07, 0x53, 0xE5, 0x3D, 0xF0, 0x22, 0x12,
-	0x07, 0x9F, 0xE5, 0x38, 0x12, 0x07, 0x53, 0xE5,
-/*13A0*/0x39, 0xF0, 0x22, 0xE5, 0x0D, 0xFE, 0xE5, 0x08,
-	0x8E, 0x54, 0x44, 0x05, 0xF5, 0x55, 0x75, 0x15,
-/*13B0*/0x0F, 0xF5, 0x82, 0x12, 0x0E, 0x7A, 0x12, 0x17,
-	0xA3, 0x20, 0x31, 0x05, 0x75, 0x15, 0x03, 0x80,
-/*13C0*/0x03, 0x75, 0x15, 0x0B, 0xE5, 0x0A, 0xC3, 0x94,
-	0x01, 0x50, 0x38, 0x12, 0x14, 0x20, 0x20, 0x31,
-/*13D0*/0x06, 0x05, 0x15, 0x05, 0x15, 0x80, 0x04, 0x15,
-	0x15, 0x15, 0x15, 0xE5, 0x0A, 0xC3, 0x94, 0x01,
-/*13E0*/0x50, 0x21, 0x12, 0x14, 0x20, 0x20, 0x31, 0x04,
-	0x05, 0x15, 0x80, 0x02, 0x15, 0x15, 0xE5, 0x0A,
-/*13F0*/0xC3, 0x94, 0x01, 0x50, 0x0E, 0x12, 0x0E, 0x77,
-	0x12, 0x17, 0xA3, 0x20, 0x31, 0x05, 0x05, 0x15,
-/*1400*/0x12, 0x0E, 0x77, 0xE5, 0x15, 0xB4, 0x08, 0x04,
-	0x7F, 0x01, 0x80, 0x02, 0x7F, 0x00, 0xE5, 0x15,
-/*1410*/0xB4, 0x07, 0x04, 0x7E, 0x01, 0x80, 0x02, 0x7E,
-	0x00, 0xEE, 0x4F, 0x60, 0x02, 0x05, 0x7F, 0x22,
-/*1420*/0x85, 0x55, 0x82, 0x85, 0x54, 0x83, 0xE5, 0x15,
-	0xF0, 0x12, 0x17, 0xA3, 0x22, 0x12, 0x07, 0x2A,
-/*1430*/0x75, 0x83, 0xAE, 0x74, 0xFF, 0x12, 0x07, 0x29,
-	0xE0, 0x54, 0x1A, 0xF5, 0x34, 0xE0, 0xC4, 0x13,
-/*1440*/0x54, 0x07, 0xF5, 0x35, 0x24, 0xFE, 0x60, 0x24,
-	0x24, 0xFE, 0x60, 0x3C, 0x24, 0x04, 0x70, 0x63,
-/*1450*/0x75, 0x31, 0x2D, 0xE5, 0x08, 0xFD, 0x74, 0xB6,
-	0x12, 0x07, 0x92, 0x74, 0xBC, 0x90, 0x07, 0x22,
-/*1460*/0x12, 0x07, 0x95, 0x74, 0x90, 0x12, 0x07, 0xB3,
-	0x74, 0x92, 0x80, 0x3C, 0x75, 0x31, 0x3A, 0xE5,
-/*1470*/0x08, 0xFD, 0x74, 0xBA, 0x12, 0x07, 0x92, 0x74,
-	0xC0, 0x90, 0x07, 0x22, 0x12, 0x07, 0xB6, 0x74,
-/*1480*/0xC4, 0x12, 0x07, 0xB3, 0x74, 0xC8, 0x80, 0x20,
-	0x75, 0x31, 0x35, 0xE5, 0x08, 0xFD, 0x74, 0xB8,
-/*1490*/0x12, 0x07, 0x92, 0x74, 0xBE, 0xFF, 0xED, 0x44,
-	0x07, 0x90, 0x07, 0x22, 0xCF, 0xF0, 0xA3, 0xEF,
-/*14A0*/0xF0, 0x74, 0xC2, 0x12, 0x07, 0xB3, 0x74, 0xC6,
-	0xFF, 0xED, 0x44, 0x07, 0xA3, 0xCF, 0xF0, 0xA3,
-/*14B0*/0xEF, 0xF0, 0x22, 0x75, 0x34, 0x01, 0x22, 0x8E,
-	0x58, 0x8F, 0x59, 0x8C, 0x5A, 0x8D, 0x5B, 0x8A,
-/*14C0*/0x5C, 0x8B, 0x5D, 0x75, 0x5E, 0x01, 0xE4, 0xF5,
-	0x5F, 0x12, 0x1E, 0xA5, 0x85, 0x59, 0x5E, 0xD3,
-/*14D0*/0xE5, 0x5E, 0x95, 0x5B, 0xE5, 0x5A, 0x12, 0x07,
-	0x6B, 0x50, 0x57, 0xE5, 0x5D, 0x45, 0x5C, 0x70,
-/*14E0*/0x30, 0x12, 0x07, 0x2A, 0x75, 0x83, 0x92, 0xE5,
-	0x5E, 0x12, 0x07, 0x29, 0x75, 0x83, 0xC6, 0xE5,
-/*14F0*/0x5E, 0x12, 0x07, 0x29, 0x75, 0x83, 0xC8, 0xE5,
-	0x5E, 0x12, 0x07, 0x29, 0x75, 0x83, 0x90, 0xE5,
-/*1500*/0x5E, 0x12, 0x07, 0x29, 0x75, 0x83, 0xC2, 0xE5,
-	0x5E, 0x12, 0x07, 0x29, 0x75, 0x83, 0xC4, 0x80,
-/*1510*/0x03, 0x12, 0x07, 0x32, 0xE5, 0x5E, 0xF0, 0xAF,
-	0x5F, 0x7E, 0x00, 0xAD, 0x5D, 0xAC, 0x5C, 0x12,
-/*1520*/0x04, 0x44, 0xAF, 0x5E, 0x7E, 0x00, 0xAD, 0x5D,
-	0xAC, 0x5C, 0x12, 0x0B, 0xD1, 0x05, 0x5E, 0x02,
-/*1530*/0x14, 0xCF, 0xAB, 0x5D, 0xAA, 0x5C, 0xAD, 0x5B,
-	0xAC, 0x5A, 0xAF, 0x59, 0xAE, 0x58, 0x02, 0x1B,
-/*1540*/0xFB, 0x8C, 0x5C, 0x8D, 0x5D, 0x8A, 0x5E, 0x8B,
-	0x5F, 0x75, 0x60, 0x01, 0xE4, 0xF5, 0x61, 0xF5,
-/*1550*/0x62, 0xF5, 0x63, 0x12, 0x1E, 0xA5, 0x8F, 0x60,
-	0xD3, 0xE5, 0x60, 0x95, 0x5D, 0xE5, 0x5C, 0x12,
-/*1560*/0x07, 0x6B, 0x50, 0x61, 0xE5, 0x5F, 0x45, 0x5E,
-	0x70, 0x27, 0x12, 0x07, 0x2A, 0x75, 0x83, 0xB6,
-/*1570*/0xE5, 0x60, 0x12, 0x07, 0x29, 0x75, 0x83, 0xB8,
-	0xE5, 0x60, 0x12, 0x07, 0x29, 0x75, 0x83, 0xBA,
-/*1580*/0xE5, 0x60, 0xF0, 0xAF, 0x61, 0x7E, 0x00, 0xE5,
-	0x62, 0x12, 0x08, 0x7A, 0x12, 0x0A, 0xFF, 0x80,
-/*1590*/0x19, 0x90, 0x07, 0x24, 0x12, 0x07, 0x35, 0xE5,
-	0x60, 0x12, 0x07, 0x29, 0x75, 0x83, 0x8E, 0xE4,
-/*15A0*/0x12, 0x07, 0x29, 0x74, 0x01, 0x12, 0x07, 0x29,
-	0xE4, 0xF0, 0xAF, 0x63, 0x7E, 0x00, 0xAD, 0x5F,
-/*15B0*/0xAC, 0x5E, 0x12, 0x04, 0x44, 0xAF, 0x60, 0x7E,
-	0x00, 0xAD, 0x5F, 0xAC, 0x5E, 0x12, 0x12, 0x8B,
-/*15C0*/0x05, 0x60, 0x02, 0x15, 0x58, 0x22, 0x90, 0x11,
-	0x4D, 0xE4, 0x93, 0x90, 0x07, 0x2E, 0xF0, 0x12,
-/*15D0*/0x08, 0x1F, 0x75, 0x83, 0xAE, 0xE0, 0x54, 0x1A,
-	0xF5, 0x34, 0x70, 0x67, 0xEF, 0x44, 0x07, 0xF5,
-/*15E0*/0x82, 0x75, 0x83, 0xCE, 0xE0, 0xFF, 0x13, 0x13,
-	0x13, 0x54, 0x07, 0xF5, 0x36, 0x54, 0x0F, 0xD3,
-/*15F0*/0x94, 0x00, 0x40, 0x06, 0x12, 0x14, 0x2D, 0x12,
-	0x1B, 0xA9, 0xE5, 0x36, 0x54, 0x0F, 0x24, 0xFE,
-/*1600*/0x60, 0x0C, 0x14, 0x60, 0x0C, 0x14, 0x60, 0x19,
-	0x24, 0x03, 0x70, 0x37, 0x80, 0x10, 0x02, 0x1E,
-/*1610*/0x91, 0x12, 0x1E, 0x91, 0x12, 0x07, 0x2A, 0x75,
-	0x83, 0xCE, 0xE0, 0x54, 0xEF, 0xF0, 0x02, 0x1D,
-/*1620*/0xAE, 0x12, 0x10, 0x14, 0xE4, 0xF5, 0x55, 0x12,
-	0x1D, 0x85, 0x05, 0x55, 0xE5, 0x55, 0xC3, 0x94,
-/*1630*/0x05, 0x40, 0xF4, 0x12, 0x07, 0x2A, 0x75, 0x83,
-	0xCE, 0xE0, 0x54, 0xC7, 0x12, 0x07, 0x29, 0xE0,
-/*1640*/0x44, 0x08, 0xF0, 0x22, 0xE4, 0xF5, 0x58, 0xF5,
-	0x59, 0xAF, 0x08, 0xEF, 0x44, 0x07, 0xF5, 0x82,
-/*1650*/0x75, 0x83, 0xD0, 0xE0, 0xFD, 0xC4, 0x54, 0x0F,
-	0xF5, 0x5A, 0xEF, 0x44, 0x07, 0xF5, 0x82, 0x75,
-/*1660*/0x83, 0x80, 0x74, 0x01, 0xF0, 0x12, 0x08, 0x21,
-	0x75, 0x83, 0x82, 0xE5, 0x45, 0xF0, 0xEF, 0x44,
-/*1670*/0x07, 0xF5, 0x82, 0x75, 0x83, 0x8A, 0x74, 0xFF,
-	0xF0, 0x12, 0x1A, 0x4D, 0x12, 0x07, 0x2A, 0x75,
-/*1680*/0x83, 0xBC, 0xE0, 0x54, 0xEF, 0x12, 0x07, 0x29,
-	0x75, 0x83, 0xBE, 0xE0, 0x54, 0xEF, 0x12, 0x07,
-/*1690*/0x29, 0x75, 0x83, 0xC0, 0xE0, 0x54, 0xEF, 0x12,
-	0x07, 0x29, 0x75, 0x83, 0xBC, 0xE0, 0x44, 0x10,
-/*16A0*/0x12, 0x07, 0x29, 0x75, 0x83, 0xBE, 0xE0, 0x44,
-	0x10, 0x12, 0x07, 0x29, 0x75, 0x83, 0xC0, 0xE0,
-/*16B0*/0x44, 0x10, 0xF0, 0xAF, 0x58, 0xE5, 0x59, 0x12,
-	0x08, 0x78, 0x02, 0x0A, 0xFF, 0xE4, 0xF5, 0x58,
-/*16C0*/0x7D, 0x01, 0xF5, 0x59, 0xAF, 0x35, 0xFE, 0xFC,
-	0x12, 0x09, 0x15, 0x12, 0x07, 0x2A, 0x75, 0x83,
-/*16D0*/0xB6, 0x74, 0x10, 0x12, 0x07, 0x29, 0x75, 0x83,
-	0xB8, 0x74, 0x10, 0x12, 0x07, 0x29, 0x75, 0x83,
-/*16E0*/0xBA, 0x74, 0x10, 0x12, 0x07, 0x29, 0x75, 0x83,
-	0xBC, 0x74, 0x10, 0x12, 0x07, 0x29, 0x75, 0x83,
-/*16F0*/0xBE, 0x74, 0x10, 0x12, 0x07, 0x29, 0x75, 0x83,
-	0xC0, 0x74, 0x10, 0x12, 0x07, 0x29, 0x75, 0x83,
-/*1700*/0x90, 0xE4, 0x12, 0x07, 0x29, 0x75, 0x83, 0xC2,
-	0xE4, 0x12, 0x07, 0x29, 0x75, 0x83, 0xC4, 0xE4,
-/*1710*/0x12, 0x07, 0x29, 0x75, 0x83, 0x92, 0xE4, 0x12,
-	0x07, 0x29, 0x75, 0x83, 0xC6, 0xE4, 0x12, 0x07,
-/*1720*/0x29, 0x75, 0x83, 0xC8, 0xE4, 0xF0, 0xAF, 0x58,
-	0xFE, 0xE5, 0x59, 0x12, 0x08, 0x7A, 0x02, 0x0A,
-/*1730*/0xFF, 0xE5, 0xE2, 0x30, 0xE4, 0x6C, 0xE5, 0xE7,
-	0x54, 0xC0, 0x64, 0x40, 0x70, 0x64, 0xE5, 0x09,
-/*1740*/0xC4, 0x54, 0x30, 0xFE, 0xE5, 0x08, 0x25, 0xE0,
-	0x25, 0xE0, 0x54, 0xC0, 0x4E, 0xFE, 0xEF, 0x54,
-/*1750*/0x3F, 0x4E, 0xFD, 0xE5, 0x2B, 0xAE, 0x2A, 0x78,
-	0x02, 0xC3, 0x33, 0xCE, 0x33, 0xCE, 0xD8, 0xF9,
-/*1760*/0xF5, 0x82, 0x8E, 0x83, 0xED, 0xF0, 0xE5, 0x2B,
-	0xAE, 0x2A, 0x78, 0x02, 0xC3, 0x33, 0xCE, 0x33,
-/*1770*/0xCE, 0xD8, 0xF9, 0xFF, 0xF5, 0x82, 0x8E, 0x83,
-	0xA3, 0xE5, 0xFE, 0xF0, 0x8F, 0x82, 0x8E, 0x83,
-/*1780*/0xA3, 0xA3, 0xE5, 0xFD, 0xF0, 0x8F, 0x82, 0x8E,
-	0x83, 0xA3, 0xA3, 0xA3, 0xE5, 0xFC, 0xF0, 0xC3,
-/*1790*/0xE5, 0x2B, 0x94, 0xFA, 0xE5, 0x2A, 0x94, 0x00,
-	0x50, 0x08, 0x05, 0x2B, 0xE5, 0x2B, 0x70, 0x02,
-/*17A0*/0x05, 0x2A, 0x22, 0xE4, 0xFF, 0xE4, 0xF5, 0x58,
-	0xF5, 0x56, 0xF5, 0x57, 0x74, 0x82, 0xFC, 0x12,
-/*17B0*/0x0E, 0x04, 0x8C, 0x83, 0xE0, 0xF5, 0x10, 0x54,
-	0x7F, 0xF0, 0xE5, 0x10, 0x44, 0x80, 0x12, 0x0E,
-/*17C0*/0x98, 0xED, 0xF0, 0x7E, 0x0A, 0x12, 0x0E, 0x04,
-	0x75, 0x83, 0xA0, 0xE0, 0x20, 0xE0, 0x26, 0xDE,
-/*17D0*/0xF4, 0x05, 0x57, 0xE5, 0x57, 0x70, 0x02, 0x05,
-	0x56, 0xE5, 0x14, 0x24, 0x01, 0xFD, 0xE4, 0x33,
-/*17E0*/0xFC, 0xD3, 0xE5, 0x57, 0x9D, 0xE5, 0x56, 0x9C,
-	0x40, 0xD9, 0xE5, 0x0A, 0x94, 0x20, 0x50, 0x02,
-/*17F0*/0x05, 0x0A, 0x43, 0xE1, 0x08, 0xC2, 0x31, 0x12,
-	0x0E, 0x04, 0x75, 0x83, 0xA6, 0xE0, 0x55, 0x12,
-/*1800*/0x65, 0x12, 0x70, 0x03, 0xD2, 0x31, 0x22, 0xC2,
-	0x31, 0x22, 0x90, 0x07, 0x26, 0xE0, 0xFA, 0xA3,
-/*1810*/0xE0, 0xF5, 0x82, 0x8A, 0x83, 0xE0, 0xF5, 0x41,
-	0xE5, 0x39, 0xC3, 0x95, 0x41, 0x40, 0x26, 0xE5,
-/*1820*/0x39, 0x95, 0x41, 0xC3, 0x9F, 0xEE, 0x12, 0x07,
-	0x6B, 0x40, 0x04, 0x7C, 0x01, 0x80, 0x02, 0x7C,
-/*1830*/0x00, 0xE5, 0x41, 0x64, 0x3F, 0x60, 0x04, 0x7B,
-	0x01, 0x80, 0x02, 0x7B, 0x00, 0xEC, 0x5B, 0x60,
-/*1840*/0x29, 0x05, 0x41, 0x80, 0x28, 0xC3, 0xE5, 0x41,
-	0x95, 0x39, 0xC3, 0x9F, 0xEE, 0x12, 0x07, 0x6B,
-/*1850*/0x40, 0x04, 0x7F, 0x01, 0x80, 0x02, 0x7F, 0x00,
-	0xE5, 0x41, 0x60, 0x04, 0x7E, 0x01, 0x80, 0x02,
-/*1860*/0x7E, 0x00, 0xEF, 0x5E, 0x60, 0x04, 0x15, 0x41,
-	0x80, 0x03, 0x85, 0x39, 0x41, 0x85, 0x3A, 0x40,
-/*1870*/0x22, 0xE5, 0xE2, 0x30, 0xE4, 0x60, 0xE5, 0xE1,
-	0x30, 0xE2, 0x5B, 0xE5, 0x09, 0x70, 0x04, 0x7F,
-/*1880*/0x01, 0x80, 0x02, 0x7F, 0x00, 0xE5, 0x08, 0x70,
-	0x04, 0x7E, 0x01, 0x80, 0x02, 0x7E, 0x00, 0xEE,
-/*1890*/0x5F, 0x60, 0x43, 0x53, 0xF9, 0xF8, 0xE5, 0xE2,
-	0x30, 0xE4, 0x3B, 0xE5, 0xE1, 0x30, 0xE2, 0x2E,
-/*18A0*/0x43, 0xFA, 0x02, 0x53, 0xFA, 0xFB, 0xE4, 0xF5,
-	0x10, 0x90, 0x94, 0x70, 0xE5, 0x10, 0xF0, 0xE5,
-/*18B0*/0xE1, 0x30, 0xE2, 0xE7, 0x90, 0x94, 0x70, 0xE0,
-	0x65, 0x10, 0x60, 0x03, 0x43, 0xFA, 0x04, 0x05,
-/*18C0*/0x10, 0x90, 0x94, 0x70, 0xE5, 0x10, 0xF0, 0x70,
-	0xE6, 0x12, 0x00, 0x06, 0x80, 0xE1, 0x53, 0xFA,
-/*18D0*/0xFD, 0x53, 0xFA, 0xFB, 0x80, 0xC0, 0x22, 0x8F,
-	0x54, 0x12, 0x00, 0x06, 0xE5, 0xE1, 0x30, 0xE0,
-/*18E0*/0x04, 0x7F, 0x01, 0x80, 0x02, 0x7F, 0x00, 0xE5,
-	0x7E, 0xD3, 0x94, 0x05, 0x40, 0x04, 0x7E, 0x01,
-/*18F0*/0x80, 0x02, 0x7E, 0x00, 0xEE, 0x4F, 0x60, 0x3D,
-	0x85, 0x54, 0x11, 0xE5, 0xE2, 0x20, 0xE1, 0x32,
-/*1900*/0x74, 0xCE, 0x12, 0x1A, 0x05, 0x30, 0xE7, 0x04,
-	0x7D, 0x01, 0x80, 0x02, 0x7D, 0x00, 0x8F, 0x82,
-/*1910*/0x8E, 0x83, 0xE0, 0x30, 0xE6, 0x04, 0x7F, 0x01,
-	0x80, 0x02, 0x7F, 0x00, 0xEF, 0x5D, 0x70, 0x15,
-/*1920*/0x12, 0x15, 0xC6, 0x74, 0xCE, 0x12, 0x1A, 0x05,
-	0x30, 0xE6, 0x07, 0xE0, 0x44, 0x80, 0xF0, 0x43,
-/*1930*/0xF9, 0x80, 0x12, 0x18, 0x71, 0x22, 0x12, 0x0E,
-	0x44, 0xE5, 0x16, 0x25, 0xE0, 0x25, 0xE0, 0x24,
-/*1940*/0xB0, 0xF5, 0x82, 0xE4, 0x34, 0x1A, 0xF5, 0x83,
-	0xE4, 0x93, 0xF5, 0x0F, 0xE5, 0x16, 0x25, 0xE0,
-/*1950*/0x25, 0xE0, 0x24, 0xB1, 0xF5, 0x82, 0xE4, 0x34,
-	0x1A, 0xF5, 0x83, 0xE4, 0x93, 0xF5, 0x0E, 0x12,
-/*1960*/0x0E, 0x65, 0xF5, 0x10, 0xE5, 0x0F, 0x54, 0xF0,
-	0x12, 0x0E, 0x17, 0x75, 0x83, 0x8C, 0xEF, 0xF0,
-/*1970*/0xE5, 0x0F, 0x30, 0xE0, 0x0C, 0x12, 0x0E, 0x04,
-	0x75, 0x83, 0x86, 0xE0, 0x44, 0x40, 0xF0, 0x80,
-/*1980*/0x0A, 0x12, 0x0E, 0x04, 0x75, 0x83, 0x86, 0xE0,
-	0x54, 0xBF, 0xF0, 0x12, 0x0E, 0x91, 0x75, 0x83,
-/*1990*/0x82, 0xE5, 0x0E, 0xF0, 0x22, 0x7F, 0x05, 0x12,
-	0x17, 0x31, 0x12, 0x0E, 0x04, 0x12, 0x0E, 0x33,
-/*19A0*/0x74, 0x02, 0xF0, 0x74, 0x8E, 0xFE, 0x12, 0x0E,
-	0x04, 0x12, 0x0E, 0x0B, 0xEF, 0xF0, 0x75, 0x15,
-/*19B0*/0x70, 0x12, 0x0F, 0xF7, 0x20, 0x34, 0x05, 0x75,
-	0x15, 0x10, 0x80, 0x03, 0x75, 0x15, 0x50, 0x12,
-/*19C0*/0x0F, 0xF7, 0x20, 0x34, 0x04, 0x74, 0x10, 0x80,
-	0x02, 0x74, 0xF0, 0x25, 0x15, 0xF5, 0x15, 0x12,
-/*19D0*/0x0E, 0x21, 0xEF, 0xF0, 0x12, 0x10, 0x91, 0x20,
-	0x34, 0x17, 0xE5, 0x15, 0x64, 0x30, 0x60, 0x0C,
-/*19E0*/0x74, 0x10, 0x25, 0x15, 0xF5, 0x15, 0xB4, 0x80,
-	0x03, 0xE4, 0xF5, 0x15, 0x12, 0x0E, 0x21, 0xEF,
-/*19F0*/0xF0, 0x22, 0xF0, 0xE5, 0x0B, 0x25, 0xE0, 0x25,
-	0xE0, 0x24, 0x82, 0xF5, 0x82, 0xE4, 0x34, 0x07,
-/*1A00*/0xF5, 0x83, 0x22, 0x74, 0x88, 0xFE, 0xE5, 0x08,
-	0x44, 0x07, 0xFF, 0xF5, 0x82, 0x8E, 0x83, 0xE0,
-/*1A10*/0x22, 0xF0, 0xE5, 0x08, 0x44, 0x07, 0xF5, 0x82,
-	0x22, 0xF0, 0xE0, 0x54, 0xC0, 0x8F, 0x82, 0x8E,
-/*1A20*/0x83, 0xF0, 0x22, 0xEF, 0x44, 0x07, 0xF5, 0x82,
-	0x75, 0x83, 0x86, 0xE0, 0x54, 0x10, 0xD3, 0x94,
-/*1A30*/0x00, 0x22, 0xF0, 0x90, 0x07, 0x15, 0xE0, 0x04,
-	0xF0, 0x22, 0x44, 0x06, 0xF5, 0x82, 0x75, 0x83,
-/*1A40*/0x9E, 0xE0, 0x22, 0xFE, 0xEF, 0x44, 0x07, 0xF5,
-	0x82, 0x8E, 0x83, 0xE0, 0x22, 0xE4, 0x90, 0x07,
-/*1A50*/0x2A, 0xF0, 0xA3, 0xF0, 0x12, 0x07, 0x2A, 0x75,
-	0x83, 0x82, 0xE0, 0x54, 0x7F, 0x12, 0x07, 0x29,
-/*1A60*/0xE0, 0x44, 0x80, 0xF0, 0x12, 0x10, 0xFC, 0x12,
-	0x08, 0x1F, 0x75, 0x83, 0xA0, 0xE0, 0x20, 0xE0,
-/*1A70*/0x1A, 0x90, 0x07, 0x2B, 0xE0, 0x04, 0xF0, 0x70,
-	0x06, 0x90, 0x07, 0x2A, 0xE0, 0x04, 0xF0, 0x90,
-/*1A80*/0x07, 0x2A, 0xE0, 0xB4, 0x10, 0xE1, 0xA3, 0xE0,
-	0xB4, 0x00, 0xDC, 0xEE, 0x44, 0xA6, 0xFC, 0xEF,
-/*1A90*/0x44, 0x07, 0xF5, 0x82, 0x8C, 0x83, 0xE0, 0xF5,
-	0x32, 0xEE, 0x44, 0xA8, 0xFE, 0xEF, 0x44, 0x07,
-/*1AA0*/0xF5, 0x82, 0x8E, 0x83, 0xE0, 0xF5, 0x33, 0x22,
-	0x01, 0x20, 0x11, 0x00, 0x04, 0x20, 0x00, 0x90,
-/*1AB0*/0x00, 0x20, 0x0F, 0x92, 0x00, 0x21, 0x0F, 0x94,
-	0x00, 0x22, 0x0F, 0x96, 0x00, 0x23, 0x0F, 0x98,
-/*1AC0*/0x00, 0x24, 0x0F, 0x9A, 0x00, 0x25, 0x0F, 0x9C,
-	0x00, 0x26, 0x0F, 0x9E, 0x00, 0x27, 0x0F, 0xA0,
-/*1AD0*/0x01, 0x20, 0x01, 0xA2, 0x01, 0x21, 0x01, 0xA4,
-	0x01, 0x22, 0x01, 0xA6, 0x01, 0x23, 0x01, 0xA8,
-/*1AE0*/0x01, 0x24, 0x01, 0xAA, 0x01, 0x25, 0x01, 0xAC,
-	0x01, 0x26, 0x01, 0xAE, 0x01, 0x27, 0x01, 0xB0,
-/*1AF0*/0x01, 0x28, 0x01, 0xB4, 0x00, 0x28, 0x0F, 0xB6,
-	0x40, 0x28, 0x0F, 0xB8, 0x61, 0x28, 0x01, 0xCB,
-/*1B00*/0xEF, 0xCB, 0xCA, 0xEE, 0xCA, 0x7F, 0x01, 0xE4,
-	0xFD, 0xEB, 0x4A, 0x70, 0x24, 0xE5, 0x08, 0xF5,
-/*1B10*/0x82, 0x74, 0xB6, 0x12, 0x08, 0x29, 0xE5, 0x08,
-	0xF5, 0x82, 0x74, 0xB8, 0x12, 0x08, 0x29, 0xE5,
-/*1B20*/0x08, 0xF5, 0x82, 0x74, 0xBA, 0x12, 0x08, 0x29,
-	0x7E, 0x00, 0x7C, 0x00, 0x12, 0x0A, 0xFF, 0x80,
-/*1B30*/0x12, 0x90, 0x07, 0x26, 0x12, 0x07, 0x35, 0xE5,
-	0x41, 0xF0, 0x90, 0x07, 0x24, 0x12, 0x07, 0x35,
-/*1B40*/0xE5, 0x40, 0xF0, 0x12, 0x07, 0x2A, 0x75, 0x83,
-	0x8E, 0xE4, 0x12, 0x07, 0x29, 0x74, 0x01, 0x12,
-/*1B50*/0x07, 0x29, 0xE4, 0xF0, 0x22, 0xE4, 0xF5, 0x26,
-	0xF5, 0x27, 0x53, 0xE1, 0xFE, 0xF5, 0x2A, 0x75,
-/*1B60*/0x2B, 0x01, 0xF5, 0x08, 0x7F, 0x01, 0x12, 0x17,
-	0x31, 0x30, 0x30, 0x1C, 0x90, 0x1A, 0xA9, 0xE4,
-/*1B70*/0x93, 0xF5, 0x10, 0x90, 0x1F, 0xF9, 0xE4, 0x93,
-	0xF5, 0x10, 0x90, 0x00, 0x41, 0xE4, 0x93, 0xF5,
-/*1B80*/0x10, 0x90, 0x1E, 0xCA, 0xE4, 0x93, 0xF5, 0x10,
-	0x7F, 0x02, 0x12, 0x17, 0x31, 0x12, 0x0F, 0x54,
-/*1B90*/0x7F, 0x03, 0x12, 0x17, 0x31, 0x12, 0x00, 0x06,
-	0xE5, 0xE2, 0x30, 0xE7, 0x09, 0x12, 0x10, 0x00,
-/*1BA0*/0x30, 0x30, 0x03, 0x12, 0x11, 0x00, 0x02, 0x00,
-	0x47, 0x12, 0x08, 0x1F, 0x75, 0x83, 0xD0, 0xE0,
-/*1BB0*/0xC4, 0x54, 0x0F, 0xFD, 0x75, 0x43, 0x01, 0x75,
-	0x44, 0xFF, 0x12, 0x08, 0xAA, 0x74, 0x04, 0xF0,
-/*1BC0*/0x75, 0x3B, 0x01, 0xED, 0x14, 0x60, 0x0C, 0x14,
-	0x60, 0x0B, 0x14, 0x60, 0x0F, 0x24, 0x03, 0x70,
-/*1BD0*/0x0B, 0x80, 0x09, 0x80, 0x00, 0x12, 0x08, 0xA7,
-	0x04, 0xF0, 0x80, 0x06, 0x12, 0x08, 0xA7, 0x74,
-/*1BE0*/0x04, 0xF0, 0xEE, 0x44, 0x82, 0xFE, 0xEF, 0x44,
-	0x07, 0xF5, 0x82, 0x8E, 0x83, 0xE5, 0x45, 0x12,
-/*1BF0*/0x08, 0xBE, 0x75, 0x83, 0x82, 0xE5, 0x31, 0xF0,
-	0x02, 0x11, 0x4C, 0x8E, 0x60, 0x8F, 0x61, 0x12,
-/*1C00*/0x1E, 0xA5, 0xE4, 0xFF, 0xCE, 0xED, 0xCE, 0xEE,
-	0xD3, 0x95, 0x61, 0xE5, 0x60, 0x12, 0x07, 0x6B,
-/*1C10*/0x40, 0x39, 0x74, 0x20, 0x2E, 0xF5, 0x82, 0xE4,
-	0x34, 0x03, 0xF5, 0x83, 0xE0, 0x70, 0x03, 0xFF,
-/*1C20*/0x80, 0x26, 0x12, 0x08, 0xE2, 0xFD, 0xC3, 0x9F,
-	0x40, 0x1E, 0xCF, 0xED, 0xCF, 0xEB, 0x4A, 0x70,
-/*1C30*/0x0B, 0x8D, 0x42, 0x12, 0x08, 0xEE, 0xF5, 0x41,
-	0x8E, 0x40, 0x80, 0x0C, 0x12, 0x08, 0xE2, 0xF5,
-/*1C40*/0x38, 0x12, 0x08, 0xEE, 0xF5, 0x39, 0x8E, 0x3A,
-	0x1E, 0x80, 0xBC, 0x22, 0x75, 0x58, 0x01, 0xE5,
-/*1C50*/0x35, 0x70, 0x0C, 0x12, 0x07, 0xCC, 0xE0, 0xF5,
-	0x4A, 0x12, 0x07, 0xD8, 0xE0, 0xF5, 0x4C, 0xE5,
-/*1C60*/0x35, 0xB4, 0x04, 0x0C, 0x12, 0x07, 0xE4, 0xE0,
-	0xF5, 0x4A, 0x12, 0x07, 0xF0, 0xE0, 0xF5, 0x4C,
-/*1C70*/0xE5, 0x35, 0xB4, 0x01, 0x04, 0x7F, 0x01, 0x80,
-	0x02, 0x7F, 0x00, 0xE5, 0x35, 0xB4, 0x02, 0x04,
-/*1C80*/0x7E, 0x01, 0x80, 0x02, 0x7E, 0x00, 0xEE, 0x4F,
-	0x60, 0x0C, 0x12, 0x07, 0xFC, 0xE0, 0xF5, 0x4A,
-/*1C90*/0x12, 0x08, 0x08, 0xE0, 0xF5, 0x4C, 0x85, 0x41,
-	0x49, 0x85, 0x40, 0x4B, 0x22, 0x75, 0x5B, 0x01,
-/*1CA0*/0x90, 0x07, 0x24, 0x12, 0x07, 0x35, 0xE0, 0x54,
-	0x1F, 0xFF, 0xD3, 0x94, 0x02, 0x50, 0x04, 0x8F,
-/*1CB0*/0x58, 0x80, 0x05, 0xEF, 0x24, 0xFE, 0xF5, 0x58,
-	0xEF, 0xC3, 0x94, 0x18, 0x40, 0x05, 0x75, 0x59,
-/*1CC0*/0x18, 0x80, 0x04, 0xEF, 0x04, 0xF5, 0x59, 0x85,
-	0x43, 0x5A, 0xAF, 0x58, 0x7E, 0x00, 0xAD, 0x59,
-/*1CD0*/0x7C, 0x00, 0xAB, 0x5B, 0x7A, 0x00, 0x12, 0x15,
-	0x41, 0xAF, 0x5A, 0x7E, 0x00, 0x12, 0x18, 0x0A,
-/*1CE0*/0xAF, 0x5B, 0x7E, 0x00, 0x02, 0x1A, 0xFF, 0xE5,
-	0xE2, 0x30, 0xE7, 0x0E, 0x12, 0x10, 0x03, 0xC2,
-/*1CF0*/0x30, 0x30, 0x30, 0x03, 0x12, 0x10, 0xFF, 0x20,
-	0x33, 0x28, 0xE5, 0xE7, 0x30, 0xE7, 0x05, 0x12,
-/*1D00*/0x0E, 0xA2, 0x80, 0x0D, 0xE5, 0xFE, 0xC3, 0x94,
-	0x20, 0x50, 0x06, 0x12, 0x0E, 0xA2, 0x43, 0xF9,
-/*1D10*/0x08, 0xE5, 0xF2, 0x30, 0xE7, 0x03, 0x53, 0xF9,
-	0x7F, 0xE5, 0xF1, 0x54, 0x70, 0xD3, 0x94, 0x00,
-/*1D20*/0x50, 0xD8, 0x22, 0x12, 0x0E, 0x04, 0x75, 0x83,
-	0x80, 0xE4, 0xF0, 0xE5, 0x08, 0x44, 0x07, 0x12,
-/*1D30*/0x0D, 0xFD, 0x75, 0x83, 0x84, 0x12, 0x0E, 0x02,
-	0x75, 0x83, 0x86, 0x12, 0x0E, 0x02, 0x75, 0x83,
-/*1D40*/0x8C, 0xE0, 0x54, 0xF3, 0x12, 0x0E, 0x03, 0x75,
-	0x83, 0x8E, 0x12, 0x0E, 0x02, 0x75, 0x83, 0x94,
-/*1D50*/0xE0, 0x54, 0xFB, 0xF0, 0x22, 0x12, 0x07, 0x2A,
-	0x75, 0x83, 0x8E, 0xE4, 0x12, 0x07, 0x29, 0x74,
-/*1D60*/0x01, 0x12, 0x07, 0x29, 0xE4, 0x12, 0x08, 0xBE,
-	0x75, 0x83, 0x8C, 0xE0, 0x44, 0x20, 0x12, 0x08,
-/*1D70*/0xBE, 0xE0, 0x54, 0xDF, 0xF0, 0x74, 0x84, 0x85,
-	0x08, 0x82, 0xF5, 0x83, 0xE0, 0x54, 0x7F, 0xF0,
-/*1D80*/0xE0, 0x44, 0x80, 0xF0, 0x22, 0x75, 0x56, 0x01,
-	0xE4, 0xFD, 0xF5, 0x57, 0xAF, 0x35, 0xFE, 0xFC,
-/*1D90*/0x12, 0x09, 0x15, 0x12, 0x1C, 0x9D, 0x12, 0x1E,
-	0x7A, 0x12, 0x1C, 0x4C, 0xAF, 0x57, 0x7E, 0x00,
-/*1DA0*/0xAD, 0x56, 0x7C, 0x00, 0x12, 0x04, 0x44, 0xAF,
-	0x56, 0x7E, 0x00, 0x02, 0x11, 0xEE, 0x75, 0x56,
-/*1DB0*/0x01, 0xE4, 0xFD, 0xF5, 0x57, 0xAF, 0x35, 0xFE,
-	0xFC, 0x12, 0x09, 0x15, 0x12, 0x1C, 0x9D, 0x12,
-/*1DC0*/0x1E, 0x7A, 0x12, 0x1C, 0x4C, 0xAF, 0x57, 0x7E,
-	0x00, 0xAD, 0x56, 0x7C, 0x00, 0x12, 0x04, 0x44,
-/*1DD0*/0xAF, 0x56, 0x7E, 0x00, 0x02, 0x11, 0xEE, 0xE4,
-	0xF5, 0x16, 0x12, 0x0E, 0x44, 0xFE, 0xE5, 0x08,
-/*1DE0*/0x44, 0x05, 0xFF, 0x12, 0x0E, 0x65, 0x8F, 0x82,
-	0x8E, 0x83, 0xF0, 0x05, 0x16, 0xE5, 0x16, 0xC3,
-/*1DF0*/0x94, 0x14, 0x40, 0xE6, 0xE5, 0x08, 0x12, 0x0E,
-	0x2B, 0xE4, 0xF0, 0x22, 0xE4, 0xF5, 0x58, 0xF5,
-/*1E00*/0x59, 0xF5, 0x5A, 0xFF, 0xFE, 0xAD, 0x58, 0xFC,
-	0x12, 0x09, 0x15, 0x7F, 0x04, 0x7E, 0x00, 0xAD,
-/*1E10*/0x58, 0x7C, 0x00, 0x12, 0x09, 0x15, 0x7F, 0x02,
-	0x7E, 0x00, 0xAD, 0x58, 0x7C, 0x00, 0x02, 0x09,
-/*1E20*/0x15, 0xE5, 0x3C, 0x25, 0x3E, 0xFC, 0xE5, 0x42,
-	0x24, 0x00, 0xFB, 0xE4, 0x33, 0xFA, 0xEC, 0xC3,
-/*1E30*/0x9B, 0xEA, 0x12, 0x07, 0x6B, 0x40, 0x0B, 0x8C,
-	0x42, 0xE5, 0x3D, 0x25, 0x3F, 0xF5, 0x41, 0x8F,
-/*1E40*/0x40, 0x22, 0x12, 0x09, 0x0B, 0x22, 0x74, 0x84,
-	0xF5, 0x18, 0x85, 0x08, 0x19, 0x85, 0x19, 0x82,
-/*1E50*/0x85, 0x18, 0x83, 0xE0, 0x54, 0x7F, 0xF0, 0xE0,
-	0x44, 0x80, 0xF0, 0xE0, 0x44, 0x80, 0xF0, 0x22,
-/*1E60*/0xEF, 0x4E, 0x70, 0x0B, 0x12, 0x07, 0x2A, 0x75,
-	0x83, 0xD2, 0xE0, 0x54, 0xDF, 0xF0, 0x22, 0x12,
-/*1E70*/0x07, 0x2A, 0x75, 0x83, 0xD2, 0xE0, 0x44, 0x20,
-	0xF0, 0x22, 0x75, 0x58, 0x01, 0x90, 0x07, 0x26,
-/*1E80*/0x12, 0x07, 0x35, 0xE0, 0x54, 0x3F, 0xF5, 0x41,
-	0x12, 0x07, 0x32, 0xE0, 0x54, 0x3F, 0xF5, 0x40,
-/*1E90*/0x22, 0x75, 0x56, 0x02, 0xE4, 0xF5, 0x57, 0x12,
-	0x1D, 0xFC, 0xAF, 0x57, 0x7E, 0x00, 0xAD, 0x56,
-/*1EA0*/0x7C, 0x00, 0x02, 0x04, 0x44, 0xE4, 0xF5, 0x42,
-	0xF5, 0x41, 0xF5, 0x40, 0xF5, 0x38, 0xF5, 0x39,
-/*1EB0*/0xF5, 0x3A, 0x22, 0xEF, 0x54, 0x07, 0xFF, 0xE5,
-	0xF9, 0x54, 0xF8, 0x4F, 0xF5, 0xF9, 0x22, 0x7F,
-/*1EC0*/0x01, 0xE4, 0xFE, 0x0F, 0x0E, 0xBE, 0xFF, 0xFB,
-	0x22, 0x01, 0x20, 0x00, 0x01, 0x04, 0x20, 0x00,
-/*1ED0*/0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-/*1EE0*/0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-/*1EF0*/0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-/*1F00*/0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-/*1F10*/0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-/*1F20*/0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-/*1F30*/0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-/*1F40*/0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-/*1F50*/0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-/*1F60*/0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-/*1F70*/0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-/*1F80*/0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-/*1F90*/0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-/*1FA0*/0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-/*1FB0*/0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-/*1FC0*/0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-/*1FD0*/0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-/*1FE0*/0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-/*1FF0*/0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-	0x01, 0x20, 0x11, 0x00, 0x04, 0x20, 0x00, 0x81
-};
-
-int ipath_sd7220_ib_load(struct ipath_devdata *dd)
-{
-	return ipath_sd7220_prog_ld(dd, IB_7220_SERDES, ipath_sd7220_ib_img,
-		sizeof(ipath_sd7220_ib_img), 0);
-}
-
-int ipath_sd7220_ib_vfy(struct ipath_devdata *dd)
-{
-	return ipath_sd7220_prog_vfy(dd, IB_7220_SERDES, ipath_sd7220_ib_img,
-		sizeof(ipath_sd7220_ib_img), 0);
-}
