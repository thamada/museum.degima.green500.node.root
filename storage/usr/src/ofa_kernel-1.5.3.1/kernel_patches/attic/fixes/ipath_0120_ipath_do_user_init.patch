diff --git a/drivers/infiniband/hw/ipath/ipath_file_ops.c b/drivers/infiniband/hw/ipath/ipath_file_ops.c
index 7193e3f..c152618 100644
--- a/drivers/infiniband/hw/ipath/ipath_file_ops.c
+++ b/drivers/infiniband/hw/ipath/ipath_file_ops.c
@@ -1989,7 +1989,12 @@ static int ipath_do_user_init(struct file *fp,
 	 * explictly set the in-memory tail copy to 0 beforehand, so we
 	 * don't have to wait to be sure the DMA update has happened
 	 * (chip resets head/tail to 0 on transition to enable).
+	 * The mutex ensures that the read value of dd->ipath_rcvctrl
+         * after the atomic set_bit is not stale, and avoids a race
+         * hazard with 2 processes attempting to enable (distinct)
+	 * ports simultaneously.
 	 */
+	mutex_lock(&ipath_mutex);
 	set_bit(dd->ipath_r_portenable_shift + pd->port_port,
 		&dd->ipath_rcvctrl);
 	if (!(dd->ipath_flags & IPATH_NODMA_RTAIL)) {
@@ -2001,6 +2006,7 @@ static int ipath_do_user_init(struct file *fp,
 	}
 	ipath_write_kreg(dd, dd->ipath_kregs->kr_rcvctrl,
 			 dd->ipath_rcvctrl);
+	mutex_unlock(&ipath_mutex);
 	/* Notify any waiting slaves */
 	if (pd->port_subport_cnt) {
 		clear_bit(IPATH_PORT_MASTER_UNINIT, &pd->port_flag);
