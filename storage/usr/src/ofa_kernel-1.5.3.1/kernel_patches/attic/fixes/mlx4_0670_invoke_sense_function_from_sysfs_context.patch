From 98f4278dd97e5f7907eb5585c6b7fc4d294c4f78 Mon Sep 17 00:00:00 2001
From: Yevgeny Petrilin <yevgenyp@mellanox.co.il>
Date: Wed, 21 Jan 2009 15:50:01 +0200
Subject: [PATCH] mlx4: Always sense from sysfs context.

Signed-off-by: Yevgeny Petrilin <yevgenyp@mellanox.co.il>
---
 drivers/net/mlx4/main.c  |   43 ++++++++++++++++++++++++++-----------------
 drivers/net/mlx4/mlx4.h  |    4 +++-
 drivers/net/mlx4/sense.c |   38 ++++++++++++++++++++++++--------------
 3 files changed, 53 insertions(+), 32 deletions(-)

diff --git a/drivers/net/mlx4/main.c b/drivers/net/mlx4/main.c
index 74655f3..50a6ce3 100644
--- a/drivers/net/mlx4/main.c
+++ b/drivers/net/mlx4/main.c
@@ -372,8 +372,7 @@ int mlx4_change_port_types(struct mlx4_dev *dev,
 	for (port = 0; port <  dev->caps.num_ports; port++) {
 		/* Change the port type only if the new type is different
 		 * from the current, and not set to Auto */
-		if (port_types[port] != dev->caps.port_type[port + 1] &&
-		    port_types[port] != MLX4_PORT_TYPE_AUTO) {
+		if (port_types[port] != dev->caps.port_type[port + 1]) {
 			change = 1;
 			dev->caps.port_type[port + 1] = port_types[port];
 		}
@@ -426,7 +425,7 @@ static ssize_t set_port_type(struct device *dev,
 	struct mlx4_dev *mdev = info->dev;
 	struct mlx4_priv *priv = mlx4_priv(mdev);
 	enum mlx4_port_type types[MLX4_MAX_PORTS];
-	enum mlx4_port_type tmp_type;
+	enum mlx4_port_type new_types[MLX4_MAX_PORTS];
 	int i;
 	int err = 0;
 
@@ -444,23 +443,15 @@ static ssize_t set_port_type(struct device *dev,
 	mutex_lock(&priv->port_mutex);
 	/* Possible type is always the one that was delivered */
 	mdev->caps.possible_type[info->port] = info->tmp_type;
-	if (info->tmp_type == MLX4_PORT_TYPE_AUTO) {
-		/* Sense immediatelly to find the actual port type
-		 * If no port was sensed, assign the currently 
-		 * configured port type */
-		err = mlx4_SENSE_PORT(mdev, info->port, &tmp_type);
-		if (!err && (tmp_type == MLX4_PORT_TYPE_ETH ||
-			     tmp_type == MLX4_PORT_TYPE_IB)) {
-			info->tmp_type = tmp_type;
-		} else
-			info->tmp_type = mdev->caps.port_type[info->port];
-	}
 
 	/* Collect the required port types from all ports,
 	 * If not specified, use the currently configured */
-	for (i = 0; i < mdev->caps.num_ports; i++)
+	for (i = 0; i < mdev->caps.num_ports; i++) {
 		types[i] = priv->port[i+1].tmp_type ? priv->port[i+1].tmp_type :
 					mdev->caps.possible_type[i+1];
+		if (types[i] == MLX4_PORT_TYPE_AUTO)
+			types[i] = mdev->caps.port_type[i+1];
+	}
 
 	if (priv->trig) {
 		/* Wait for the other ports to be modified, or perform
@@ -470,7 +461,25 @@ static ssize_t set_port_type(struct device *dev,
 		else
 			priv->trig = priv->changed_ports = 0;
 	}
-	err = mlx4_check_port_params(mdev, types);
+
+	if (!(mdev->caps.flags & MLX4_DEV_CAP_FLAG_DPDP)) {
+		for (i = 1; i <= mdev->caps.num_ports; i++) {
+			if (mdev->caps.possible_type[i] == MLX4_PORT_TYPE_AUTO) {
+				mdev->caps.possible_type[i] = mdev->caps.port_type[i];
+				err = -EINVAL;
+			}
+		}
+	}
+	if (err) {
+		mlx4_err(mdev, "Auto sensing is not supported on this HCA. "
+			       "Set only 'eth' or 'ib' for both ports "
+			       "(should be the same)\n");
+		goto out;
+	}
+
+	mlx4_do_sense_ports(mdev, new_types, types);
+
+	err = mlx4_check_port_params(mdev, new_types);
 	if (err)
 		goto out;
 
@@ -481,7 +490,7 @@ static ssize_t set_port_type(struct device *dev,
 		priv->port[i + 1].tmp_type = 0;
 	}
 
-	err = mlx4_change_port_types(mdev, types);
+	err = mlx4_change_port_types(mdev, new_types);
 
 out:
 	mutex_unlock(&priv->port_mutex);
diff --git a/drivers/net/mlx4/mlx4.h b/drivers/net/mlx4/mlx4.h
index 279afa6..c156a3b 100644
--- a/drivers/net/mlx4/mlx4.h
+++ b/drivers/net/mlx4/mlx4.h
@@ -408,11 +408,13 @@ void mlx4_srq_event(struct mlx4_dev *dev, u32 srqn, int event_type);
 
 void mlx4_handle_catas_err(struct mlx4_dev *dev);
 
+void mlx4_do_sense_ports(struct mlx4_dev *dev,
+			 enum mlx4_port_type *stype,
+			 enum mlx4_port_type *defaults);
 void mlx4_start_sense(struct mlx4_dev *dev);
 void mlx4_stop_sense(struct mlx4_dev *dev);
 int mlx4_sense_init(struct mlx4_dev *dev);
 void mlx4_sense_cleanup(struct mlx4_dev *dev);
-int mlx4_SENSE_PORT(struct mlx4_dev *dev, int port, enum mlx4_port_type *type);
 int mlx4_check_port_params(struct mlx4_dev *dev,
 			   enum mlx4_port_type *port_type);
 int mlx4_change_port_types(struct mlx4_dev *dev,
diff --git a/drivers/net/mlx4/sense.c b/drivers/net/mlx4/sense.c
index 44e1a08..073934c 100644
--- a/drivers/net/mlx4/sense.c
+++ b/drivers/net/mlx4/sense.c
@@ -39,7 +39,8 @@
 #include "mlx4.h"
 
 
-int mlx4_SENSE_PORT(struct mlx4_dev *dev, int port, enum mlx4_port_type *type)
+static int mlx4_SENSE_PORT(struct mlx4_dev *dev, int port,
+			   enum mlx4_port_type *type)
 {
 	u64 out_param;
 	int err = 0;
@@ -60,27 +61,23 @@ int mlx4_SENSE_PORT(struct mlx4_dev *dev, int port, enum mlx4_port_type *type)
 	return 0;
 }
 
-static void mlx4_sense_port(struct work_struct *work)
+void mlx4_do_sense_ports(struct mlx4_dev *dev,
+			 enum mlx4_port_type *stype,
+			 enum mlx4_port_type *defaults)
 {
-	struct delayed_work *delay = container_of(work, struct delayed_work, work);
-	struct mlx4_sense *sense = container_of(delay, struct mlx4_sense,
-						sense_poll);
-	struct mlx4_dev *dev = sense->dev;
-	struct mlx4_priv *priv = mlx4_priv(dev);
-	enum mlx4_port_type stype[MLX4_MAX_PORTS];
-	int err = 0;
+	struct mlx4_sense *sense = &mlx4_priv(dev)->sense;
+	int err;
 	int i;
 
-	mutex_lock(&priv->port_mutex);
 	for (i = 1; i <= dev->caps.num_ports; i++) {
 		stype[i-1] = 0;
 		if (sense->do_sense_port[i] && sense->sense_allowed[i] &&
 		    dev->caps.possible_type[i] == MLX4_PORT_TYPE_AUTO) {
 			err = mlx4_SENSE_PORT(dev, i, &stype[i-1]);
 			if (err)
-				goto sense_again;
+				stype[i-1] = defaults[i-1];
 		} else
-			stype[i-1] = dev->caps.port_type[i];
+			stype[i-1] = defaults[i-1];
 	}
 
 	/*
@@ -101,7 +98,21 @@ static void mlx4_sense_port(struct work_struct *work)
 	 * If sensed nothing, remain in current configuration.
 	 */
         for (i = 0; i < dev->caps.num_ports; i++)
-		stype[i] = stype[i] ? stype[i] : dev->caps.port_type[i+1];
+		stype[i] = stype[i] ? stype[i] : defaults[i];
+
+}
+
+static void mlx4_sense_port(struct work_struct *work)
+{
+	struct delayed_work *delay = container_of(work, struct delayed_work, work);
+	struct mlx4_sense *sense = container_of(delay, struct mlx4_sense,
+						sense_poll);
+	struct mlx4_dev *dev = sense->dev;
+	struct mlx4_priv *priv = mlx4_priv(dev);
+	enum mlx4_port_type stype[MLX4_MAX_PORTS];
+
+	mutex_lock(&priv->port_mutex);
+	mlx4_do_sense_ports(dev, stype, &dev->caps.port_type[1]);
 
 	if (mlx4_check_port_params(dev, stype))
 		goto sense_again;
@@ -116,7 +127,6 @@ sense_again:
 				   round_jiffies(MLX4_SENSE_RANGE));
 }
 
-
 void mlx4_start_sense(struct mlx4_dev *dev)
 {
 	struct mlx4_priv *priv = mlx4_priv(dev);
-- 
1.5.3

