--- a/drivers/infiniband/hw/ipath/ipath_iba6120.c	2009-02-02 18:15:59.000000000 -0800
+++ b/drivers/infiniband/hw/ipath/ipath_iba6120.c	2009-02-02 18:19:53.000000000 -0800
@@ -1520,13 +1520,17 @@
 
 	/*
 	 * For openfabrics, we need to be able to handle an IB header of
-	 * 24 dwords.  HT chip has arbitrary sized receive buffers, so we
-	 * made them the same size as the PIO buffers.  This chip does not
-	 * handle arbitrary size buffers, so we need the header large enough
-	 * to handle largest IB header, but still have room for a 2KB MTU
-	 * standard IB packet.
+	 * at least 24 dwords.  This chip does not handle arbitrary size
+	 * buffers, so we need the header large enough to handle largest
+	 * IB header, but still have room for a 2KB MTU standard IB packet.
+	 * Additionally, some processor/memory controller combinations
+	 * benefit quite strongly from having the DMA'ed data be cacheline
+	 * aligned and a cacheline multiple, so we set the size to 32 dwords
+	 * (2 64-byte primary cachelines for pretty much all processors of
+	 * interest).  The alignment hurts nothing, other than using somewhat
+	 * more memory.
 	 */
-	dd->ipath_rcvhdrentsize = 24;
+	dd->ipath_rcvhdrentsize = 32;
 	dd->ipath_rcvhdrsize = IPATH_DFLT_RCVHDRSIZE;
 	dd->ipath_rhf_offset = 0;
 	dd->ipath_egrtidbase = (u64 __iomem *)
--- a/drivers/infiniband/hw/ipath/ipath_iba7220.c	2009-02-02 18:15:14.000000000 -0800
+++ b/drivers/infiniband/hw/ipath/ipath_iba7220.c	2009-02-02 18:19:06.000000000 -0800
@@ -1521,7 +1521,7 @@
 
 	dd->ipath_flags |= IPATH_NODMA_RTAIL | IPATH_HAS_SEND_DMA |
 		IPATH_HAS_PBC_CNT | IPATH_HAS_THRESH_UPDATE;
-	dd->ipath_pioupd_thresh = 4U; /* set default update threshold */
+	dd->ipath_pioupd_thresh = 8U; /* set default update threshold */
 	return 0;
 }
 
@@ -1962,13 +1962,17 @@
 
 	/*
 	 * For openfabrics, we need to be able to handle an IB header of
-	 * 24 dwords.  HT chip has arbitrary sized receive buffers, so we
-	 * made them the same size as the PIO buffers.  This chip does not
-	 * handle arbitrary size buffers, so we need the header large enough
-	 * to handle largest IB header, but still have room for a 2KB MTU
-	 * standard IB packet.
+	 * at least 24 dwords.  This chip does not handle arbitrary size
+	 * buffers, so we need the header large enough to handle largest
+	 * IB header, but still have room for a 2KB MTU standard IB packet.
+	 * Additionally, some processor/memory controller combinations
+	 * benefit quite strongly from having the DMA'ed data be cacheline
+	 * aligned and a cacheline multiple, so we set the size to 32 dwords
+	 * (2 64-byte primary cachelines for pretty much all processors of
+	 * interest).  The alignment hurts nothing, other than using somewhat
+	 * more memory.
 	 */
-	dd->ipath_rcvhdrentsize = 24;
+	dd->ipath_rcvhdrentsize = 32;
 	dd->ipath_rcvhdrsize = IPATH_DFLT_RCVHDRSIZE;
 	dd->ipath_rhf_offset =
 		dd->ipath_rcvhdrentsize - sizeof(u64) / sizeof(u32);
@@ -2094,7 +2094,7 @@
 			 dd->ipath_rcvctrl);
 	dd->ipath_p0_rcvegrcnt = 2048; /* always */
 	if (dd->ipath_flags & IPATH_HAS_SEND_DMA)
-		dd->ipath_pioreserved = 3; /* kpiobufs used for PIO */
+		dd->ipath_pioreserved = 8; /* kpiobufs used for PIO */
 }
 
 
--- a/drivers/infiniband/hw/ipath/ipath_init_chip.c	2009-02-02 18:15:59.000000000 -0800
+++ b/drivers/infiniband/hw/ipath/ipath_init_chip.c	2009-02-02 18:19:53.000000000 -0800
@@ -927,6 +927,12 @@
 	ipath_cdbg(VERBOSE, "%d PIO bufs for kernel out of %d total %u "
 		   "each for %u user ports\n", kpiobufs,
 		   piobufs, dd->ipath_pbufsport, uports);
+	if (dd->ipath_pioupd_thresh &&
+		(dd->ipath_pioupd_thresh > dd->ipath_pbufsport - 2)) {
+		dd->ipath_pioupd_thresh = dd->ipath_pbufsport - 2;
+		ipath_cdbg(VERBOSE, "Drop pioupd_thresh to %u\n",
+			dd->ipath_pioupd_thresh);
+	}
 	ret = dd->ipath_f_early_init(dd);
 	if (ret) {
 		ipath_dev_err(dd, "Early initialization failure\n");
