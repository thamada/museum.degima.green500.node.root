diff --git a/drivers/infiniband/hw/ipath/Makefile b/drivers/infiniband/hw/ipath/Makefile
index e435c48..701ab97 100644
--- a/drivers/infiniband/hw/ipath/Makefile
+++ b/drivers/infiniband/hw/ipath/Makefile
@@ -34,6 +34,7 @@ ib_ipath-y := \
 	ipath_sysfs.o \
 	ipath_uc.o \
 	ipath_ud.o \
+	ipath_wc_pat.o \
 	ipath_user_pages.o \
 	ipath_user_sdma.o \
 	ipath_verbs_mcast.o \
diff --git a/drivers/infiniband/hw/ipath/ipath_driver.c b/drivers/infiniband/hw/ipath/ipath_driver.c
index 9bd53a2..e6f0386 100644
--- a/drivers/infiniband/hw/ipath/ipath_driver.c
+++ b/drivers/infiniband/hw/ipath/ipath_driver.c
@@ -39,6 +39,7 @@
 #include <linux/netdevice.h>
 #include <linux/vmalloc.h>
 
+#include "ipath_wc_pat.h"
 #include "ipath_kernel.h"
 #include "ipath_verbs.h"
 #include "ipath_layer.h"
@@ -609,19 +610,19 @@ static int __devinit ipath_init_one(struct pci_dev *pdev,
 #else
 	dd->ipath_kregbase = ioremap_nocache(addr, len);
 #endif
-
 	if (!dd->ipath_kregbase) {
 		ipath_dbg("Unable to map io addr %llx to kvirt, failing\n",
 			  addr);
 		ret = -ENOMEM;
-		goto bail_iounmap;
+		goto bail_regions;
 	}
 	dd->ipath_kregend = (u64 __iomem *)
 		((void __iomem *)dd->ipath_kregbase + len);
 	dd->ipath_physaddr = addr;	/* used for io_remap, etc. */
 	/* for user mmap */
-	ipath_cdbg(VERBOSE, "mapped io addr %llx to kregbase %p\n",
-		   addr, dd->ipath_kregbase);
+	ipath_cdbg(VERBOSE, "mapped io addr %llx to kregbase %p, "
+		   "length %lu bytes\n",
+		   addr, dd->ipath_kregbase, (unsigned long) len);
 
 	if (dd->ipath_f_bus(dd, pdev))
 		ipath_dev_err(dd, "Failed to setup config space; "
@@ -650,13 +651,15 @@ static int __devinit ipath_init_one(struct pci_dev *pdev,
 	if (ret)
 		goto bail_irqsetup;
 
-	ret = ipath_enable_wc(dd);
+	if (!ipath_wc_pat) {
+		ret = ipath_enable_wc(dd);
 
-	if (ret) {
-		ipath_dev_err(dd, "Write combining not enabled "
-			      "(err %d): performance may be poor\n",
-			      -ret);
-		ret = 0;
+		if (ret) {
+			ipath_dev_err(dd, "Write combining not enabled "
+				      "(err %d): performance may be poor\n",
+				      -ret);
+			ret = 0;
+		}
 	}
 
 	ipath_verify_pioperf(dd);
@@ -707,12 +710,15 @@ static void __devexit cleanup_device(struct ipath_devdata *dd)
 			 * re-init
 			 */
 			dd->ipath_kregbase = NULL;
+			dd->ipath_piobase = NULL;
+			dd->ipath_userbase = NULL;
 			dd->ipath_uregbase = 0;
 			dd->ipath_sregbase = 0;
 			dd->ipath_cregbase = 0;
 			dd->ipath_kregsize = 0;
 		}
-		ipath_disable_wc(dd);
+		if (!ipath_wc_pat)
+			ipath_disable_wc(dd);
 	}
 
 	if (dd->ipath_spectriggerhit)
@@ -856,6 +862,17 @@ static void __devexit ipath_remove_one(struct pci_dev *pdev)
 
 	ipath_cdbg(VERBOSE, "Unmapping kregbase %p\n", dd->ipath_kregbase);
 	iounmap((volatile void __iomem *) dd->ipath_kregbase);
+	if (dd->ipath_piobase) {
+		ipath_cdbg(VERBOSE, "Unmapping piobase %p\n",
+			   dd->ipath_piobase);
+		iounmap((volatile void __iomem *) dd->ipath_piobase);
+	}
+	if (dd->ipath_userbase) {
+		ipath_cdbg(VERBOSE, "Unmapping userbase %p\n",
+			   dd->ipath_userbase);
+		iounmap((volatile void __iomem *) dd->ipath_userbase);
+	}
+
 	pci_release_regions(pdev);
 	ipath_cdbg(VERBOSE, "calling pci_disable_device\n");
 	pci_disable_device(pdev);
@@ -2660,6 +2677,15 @@ static int __init infinipath_init(void)
 	if (ipath_debug & __IPATH_DBG)
 		printk(KERN_INFO DRIVER_LOAD_MSG "%s", ib_ipath_version);
 
+	if (ipath_wc_pat) {
+		if (ipath_enable_wc_pat() || !ipath_wc_pat_enabled()) {
+			printk(KERN_ERR IPATH_DRV_NAME
+			       ": WC PAT unavailable, fall-back to MTRR\n");
+			ipath_wc_pat = 0;
+		} else
+			ipath_dbg("WC PAT mechanism is enabled\n");
+	}
+
 	/*
 	 * These must be called before the driver is registered with
 	 * the PCI subsystem.
@@ -2668,7 +2694,7 @@ static int __init infinipath_init(void)
 	if (!idr_pre_get(&unit_table, GFP_KERNEL)) {
 		printk(KERN_ERR IPATH_DRV_NAME ": idr_pre_get() failed\n");
 		ret = -ENOMEM;
-		goto bail;
+		goto bail_wc_pat;
 	}
 
 	ret = pci_register_driver(&ipath_driver);
@@ -2712,6 +2738,10 @@ bail_pci:
 bail_unit:
 	idr_destroy(&unit_table);
 
+bail_wc_pat:
+	if (ipath_wc_pat)
+		ipath_disable_wc_pat();
+
 bail:
 	return ret;
 }
@@ -2727,6 +2757,11 @@ static void __exit infinipath_cleanup(void)
 	pci_unregister_driver(&ipath_driver);
 
 	idr_destroy(&unit_table);
+
+	if (ipath_wc_pat) {
+		ipath_disable_wc_pat();
+		ipath_dbg("WC PAT mechanism is disabled\n");
+	}
 }
 
 /**
diff --git a/drivers/infiniband/hw/ipath/ipath_file_ops.c b/drivers/infiniband/hw/ipath/ipath_file_ops.c
index 7193e3f..febabed 100644
--- a/drivers/infiniband/hw/ipath/ipath_file_ops.c
+++ b/drivers/infiniband/hw/ipath/ipath_file_ops.c
@@ -46,6 +46,7 @@
 #include "ipath_kernel.h"
 #include "ipath_common.h"
 #include "ipath_user_sdma.h"
+#include "ipath_wc_pat.h"
 
 static int ipath_open(struct inode *, struct file *);
 static int ipath_close(struct inode *, struct file *);
@@ -1085,6 +1086,9 @@ static int mmap_piobufs(struct vm_area_struct *vma,
 	vma->vm_flags &= ~VM_MAYREAD;
 	vma->vm_flags |= VM_DONTCOPY | VM_DONTEXPAND;
 
+	if (ipath_wc_pat)
+		vma->vm_page_prot = pgprot_wc(vma->vm_page_prot);
+
 	ret = io_remap_pfn_range(vma, vma->vm_start, phys >> PAGE_SHIFT,
 				 vma->vm_end - vma->vm_start,
 				 vma->vm_page_prot);
diff --git a/drivers/infiniband/hw/ipath/ipath_iba6110.c b/drivers/infiniband/hw/ipath/ipath_iba6110.c
index 5f78caa..904eb74 100644
--- a/drivers/infiniband/hw/ipath/ipath_iba6110.c
+++ b/drivers/infiniband/hw/ipath/ipath_iba6110.c
@@ -44,6 +44,7 @@
 
 #include "ipath_kernel.h"
 #include "ipath_registers.h"
+#include "ipath_wc_pat.h"
 
 static void ipath_setup_ht_setextled(struct ipath_devdata *, u64, u64);
 
@@ -1666,8 +1667,12 @@ static int ipath_ht_early_init(struct ipath_devdata *dd)
 	 * these out on the wire.
 	 * Chip Errata bug 6610
 	 */
-	piobuf = (u32 __iomem *) (((char __iomem *)(dd->ipath_kregbase)) +
-				  dd->ipath_piobufbase);
+	if (ipath_wc_pat)
+		piobuf = (u32 __iomem *) dd->ipath_piobase;
+	else
+		piobuf = (u32 __iomem *)
+			(((char __iomem *)(dd->ipath_kregbase)) +
+			 dd->ipath_piobufbase);
 	pioincr = dd->ipath_palign / sizeof(*piobuf);
 	for (i = 0; i < dd->ipath_piobcnt2k; i++) {
 		/*
diff --git a/drivers/infiniband/hw/ipath/ipath_init_chip.c b/drivers/infiniband/hw/ipath/ipath_init_chip.c
index 8161e01..8402087 100644
--- a/drivers/infiniband/hw/ipath/ipath_init_chip.c
+++ b/drivers/infiniband/hw/ipath/ipath_init_chip.c
@@ -37,6 +37,7 @@
 
 #include "ipath_kernel.h"
 #include "ipath_common.h"
+#include "ipath_wc_pat.h"
 
 /*
  * min buffers we want to have per port, after driver
@@ -220,6 +221,131 @@ static struct ipath_portdata *create_portdata0(struct ipath_devdata *dd)
 	return pd;
 }
 
+static int init_chip_wc_pat(struct ipath_devdata *dd)
+{
+	int ret = 0;
+	u64 __iomem *ipath_kregbase = NULL;
+	void __iomem *ipath_piobase = NULL;
+	u64 __iomem *ipath_userbase = NULL;
+	u64 ipath_kreglen;
+	u64 ipath_pio2koffset = dd->ipath_piobufbase & 0xffffffff;
+	u64 ipath_pio4koffset = dd->ipath_piobufbase >> 32;
+	u64 ipath_pio2klen = dd->ipath_piobcnt2k * dd->ipath_palign;
+	u64 ipath_pio4klen = dd->ipath_piobcnt4k * dd->ipath_4kalign;
+	u64 ipath_physaddr = dd->ipath_physaddr;
+	u64 ipath_piolen;
+	u64 ipath_userlen = 0;
+
+	/* Assumes chip address space looks like:
+		- kregs + sregs + cregs + uregs (in any order)
+		- piobufs (2K and 4K bufs in either order)
+	   or:
+		- kregs + sregs + cregs (in any order)
+		- piobufs (2K and 4K bufs in either order)
+		- uregs
+	*/
+	if (dd->ipath_piobcnt4k == 0) {
+		ipath_kreglen = ipath_pio2koffset;
+		ipath_piolen = ipath_pio2klen;
+	} else if (ipath_pio2koffset < ipath_pio4koffset) {
+		ipath_kreglen = ipath_pio2koffset;
+		ipath_piolen = ipath_pio4koffset + ipath_pio4klen -
+			ipath_kreglen;
+	} else {
+		ipath_kreglen = ipath_pio4koffset;
+		ipath_piolen = ipath_pio2koffset + ipath_pio2klen -
+			ipath_kreglen;
+	}
+	if (dd->ipath_sregbase > ipath_kreglen) {
+		ipath_dbg("Unexpected sregbase layout\n");
+		ret = -EINVAL;
+		goto done;
+	}
+	if (dd->ipath_cregbase > ipath_kreglen) {
+		ipath_dbg("Unexpected cregbase layout\n");
+		ret = -EINVAL;
+		goto done;
+	}
+	if (dd->ipath_uregbase > ipath_kreglen)
+		/* Map just the configured ports (not all hw ports) */
+		ipath_userlen = dd->ipath_ureg_align *
+				dd->ipath_cfgports;
+
+	/* Sanity checks passed, now create the new mappings */
+	ipath_kregbase = ioremap_nocache(ipath_physaddr,
+					 ipath_kreglen);
+	if (!ipath_kregbase) {
+		ipath_dbg("Unable to remap io addr %llx to kvirt\n",
+			  ipath_physaddr);
+		ret = -ENOMEM;
+		goto done;
+	}
+	ipath_cdbg(VERBOSE, "WC PAT remapped io addr %llx"
+		   " to kregbase %p for %llu bytes\n",
+		   ipath_physaddr, ipath_kregbase, ipath_kreglen);
+
+	ipath_piobase = (void __iomem *) ioremap_wc(
+				ipath_physaddr + ipath_kreglen,
+				ipath_piolen);
+	if (!ipath_piobase) {
+		ipath_dbg("Unable to remap io addr %llx to kvirt\n",
+			  ipath_physaddr + ipath_kreglen);
+		ret = -ENOMEM;
+		goto done_kregbase;
+	}
+	ipath_cdbg(VERBOSE, "WC PAT remapped io addr %llx"
+		   " to piobase %p for %llu bytes\n",
+		   ipath_physaddr + ipath_kreglen,
+		   ipath_piobase, ipath_piolen);
+
+	if (ipath_userlen) {
+		ipath_userbase = (void __iomem *) ioremap_nocache(
+					ipath_physaddr +
+					dd->ipath_uregbase,
+					ipath_userlen);
+		if (!ipath_userbase) {
+			ipath_dbg("Unable to remap io addr %llx "
+				  "to kvirt\n",
+				  ipath_physaddr + dd->ipath_uregbase);
+			ret = -ENOMEM;
+			goto done_piobase;
+		}
+		ipath_cdbg(VERBOSE, "WC PAT remapped io addr %llx"
+			   " to userbase %p for %llu bytes\n",
+			   ipath_physaddr + dd->ipath_uregbase,
+			   ipath_userbase, ipath_userlen);
+	}
+
+	/* All remapping successful, get rid of old mapping */
+	iounmap((volatile void __iomem *) dd->ipath_kregbase);
+
+	/* Finally update dd with the changes */
+	dd->ipath_kregbase = ipath_kregbase;
+	dd->ipath_kregend = (u64 __iomem *)
+		((char __iomem *) ipath_kregbase + ipath_kreglen);
+	dd->ipath_piobase = ipath_piobase;
+	dd->ipath_pio2kbase = (void __iomem *)
+		(((char __iomem *) dd->ipath_piobase) +
+		 ipath_pio2koffset - ipath_kreglen);
+	if (dd->ipath_piobcnt4k)
+		dd->ipath_pio4kbase = (void __iomem *)
+			(((char __iomem *) dd->ipath_piobase) +
+			 ipath_pio4koffset - ipath_kreglen);
+	if (ipath_userlen)
+		/* ureg will now be accessed relative to dd->ipath_userbase */
+		dd->ipath_userbase = ipath_userbase;
+	goto done;
+
+done_piobase:
+	iounmap((volatile void __iomem *) ipath_piobase);
+
+done_kregbase:
+	iounmap((volatile void __iomem *) ipath_kregbase);
+
+done:
+	return ret;
+}
+
 static int init_chip_first(struct ipath_devdata *dd)
 {
 	struct ipath_portdata *pd;
@@ -314,6 +440,15 @@ static int init_chip_first(struct ipath_devdata *dd)
 		 */
 		dd->ipath_4kalign = ALIGN(dd->ipath_piosize4k,
 					  dd->ipath_palign);
+	}
+
+	if (ipath_wc_pat) {
+		ret = init_chip_wc_pat(dd);
+		if (ret)
+			goto done;
+	}
+
+	if (dd->ipath_piobcnt4k) {
 		ipath_dbg("%u 2k(%x) piobufs @ %p, %u 4k(%x) @ %p "
 			  "(%x aligned)\n",
 			  dd->ipath_piobcnt2k, dd->ipath_piosize2k,
diff --git a/drivers/infiniband/hw/ipath/ipath_kernel.h b/drivers/infiniband/hw/ipath/ipath_kernel.h
index 16fd6d9..af69c29 100644
--- a/drivers/infiniband/hw/ipath/ipath_kernel.h
+++ b/drivers/infiniband/hw/ipath/ipath_kernel.h
@@ -287,6 +287,10 @@ struct ipath_devdata {
 	void __iomem *ipath_pio2kbase;
 	/* kvirt address of 1st 4k pio buffer */
 	void __iomem *ipath_pio4kbase;
+	/* mem-mapped pointer to base of PIO buffers (if using WC PAT) */
+	void __iomem *ipath_piobase;
+	/* mem-mapped pointer to base of user chip regs (if using WC PAT) */
+	u64 __iomem *ipath_userbase;
 	/*
 	 * points to area where PIOavail registers will be DMA'ed.
 	 * Has to be on a page of it's own, because the page will be
@@ -1135,10 +1139,15 @@ static inline u32 ipath_read_ureg32(const struct ipath_devdata *dd,
 	if (!dd->ipath_kregbase || !(dd->ipath_flags & IPATH_PRESENT))
 		return 0;
 
-	return readl(regno + (u64 __iomem *)
-		     (dd->ipath_uregbase +
-		      (char __iomem *)dd->ipath_kregbase +
-		      dd->ipath_ureg_align * port));
+	if (dd->ipath_userbase)
+		return readl(regno + (u64 __iomem *)
+			     ((char __iomem *)dd->ipath_userbase +
+			      dd->ipath_ureg_align * port));
+	else
+		return readl(regno + (u64 __iomem *)
+			     (dd->ipath_uregbase +
+			      (char __iomem *)dd->ipath_kregbase +
+			      dd->ipath_ureg_align * port));
 }
 
 /**
@@ -1153,9 +1162,17 @@ static inline u32 ipath_read_ureg32(const struct ipath_devdata *dd,
 static inline void ipath_write_ureg(const struct ipath_devdata *dd,
 				    ipath_ureg regno, u64 value, int port)
 {
-	u64 __iomem *ubase = (u64 __iomem *)
-		(dd->ipath_uregbase + (char __iomem *) dd->ipath_kregbase +
-		 dd->ipath_ureg_align * port);
+	u64 __iomem *ubase;
+	if (dd->ipath_userbase)
+		ubase = (u64 __iomem *)
+			((char __iomem *) dd->ipath_userbase +
+			 dd->ipath_ureg_align * port);
+	else
+		ubase = (u64 __iomem *)
+			(dd->ipath_uregbase +
+			 (char __iomem *) dd->ipath_kregbase +
+			 dd->ipath_ureg_align * port);
+
 	if (dd->ipath_kregbase)
 		writeq(value, &ubase[regno]);
 }
diff --git a/drivers/infiniband/hw/ipath/ipath_wc_pat.c b/drivers/infiniband/hw/ipath/ipath_wc_pat.c
new file mode 100644
index 0000000..8edf2fb
--- /dev/null
+++ b/drivers/infiniband/hw/ipath/ipath_wc_pat.c
@@ -0,0 +1,280 @@
+/*
+ * Copyright (c) 2008 QLogic Corporation. All rights reserved.
+ * Copyright (c) 2006-2007 Mellanox Technologies. All rights reserved.
+ *
+ * This software is available to you under a choice of one of two
+ * licenses.  You may choose to be licensed under the terms of the GNU
+ * General Public License (GPL) Version 2, available from the file
+ * COPYING in the main directory of this source tree, or the
+ * OpenIB.org BSD license below:
+ *
+ *     Redistribution and use in source and binary forms, with or
+ *     without modification, are permitted provided that the following
+ *     conditions are met:
+ *
+ *      - Redistributions of source code must retain the above
+ *        copyright notice, this list of conditions and the following
+ *        disclaimer.
+ *
+ *      - Redistributions in binary form must reproduce the above
+ *        copyright notice, this list of conditions and the following
+ *        disclaimer in the documentation and/or other materials
+ *        provided with the distribution.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
+ * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
+ * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ */
+
+#include <asm/processor.h>
+#include <linux/io.h>
+#include <linux/pci.h>
+#include "ipath_kernel.h"
+#include "ipath_wc_pat.h"
+
+/* ipath_wc_pat parameter:
+ *   0 is WC via MTRR
+ *   1 is WC via PAT
+ *   2 is WC via PAT and over-ride chip-set wc errata and PAT checks
+ *   If PAT initialization fails, code reverts back to MTRR
+ */
+unsigned ipath_wc_pat = 1; /* default (1) is to use PAT, not MTRR */
+module_param_named(wc_pat, ipath_wc_pat, uint, S_IRUGO);
+MODULE_PARM_DESC(wc_pat, "enable write-combining via PAT mechanism");
+
+static u32 old_pat_lo[NR_CPUS] = {0};
+static u32 old_pat_hi[NR_CPUS] = {0};
+static u32 new_pat_lo[NR_CPUS] = {0};
+static unsigned int wc_enabled;
+
+#define IPATH_PAT_MASK	(0xFFFFF8FF)	/* PAT1 mask for the PAT MSR */
+#define IPATH_PAT_EXP	(0x00000400)	/* expected PAT1 value (WT) */
+#define IPATH_PAT_MOD	(0x00000100)	/* PAT1 value to select WC */
+#define IPATH_WC_MASK	(~_PAGE_PCD)	/* selects PAT1 for this page */
+#define IPATH_WC_FLAGS	(_PAGE_PWT)	/* selects PAT1 for this page */
+
+#if defined(__i386__) || defined(__x86_64__)
+
+#define X86_MSR_PAT_OFFSET  0x277
+
+/*  Returns non-zero if we have a chipset write-combining problem */
+static int have_wc_errata(void)
+{
+	struct pci_dev *dev;
+	u8 rev;
+
+	if (ipath_wc_pat == 2)
+		return 0;
+
+	dev = pci_get_class(PCI_CLASS_BRIDGE_HOST << 8, NULL);
+	if (dev != NULL) {
+		/*
+		 * ServerWorks LE chipsets < rev 6 have problems with
+		 * write-combining.
+		 */
+		if (dev->vendor == PCI_VENDOR_ID_SERVERWORKS &&
+		    dev->device == PCI_DEVICE_ID_SERVERWORKS_LE) {
+			pci_read_config_byte(dev, PCI_CLASS_REVISION, &rev);
+			if (rev <= 5) {
+				ipath_dbg("Serverworks LE rev < 6 detected. "
+					  "Write-combining disabled\n");
+				pci_dev_put(dev);
+				return -ENOSYS;
+			}
+		}
+		/* Intel 450NX errata # 23. Non ascending cacheline evictions
+		   to write combining memory may resulting in data corruption
+		 */
+		if (dev->vendor == PCI_VENDOR_ID_INTEL &&
+		    dev->device == PCI_DEVICE_ID_INTEL_82451NX) {
+			ipath_dbg("Intel 450NX MMC detected. "
+				  "Write-combining disabled.\n");
+			pci_dev_put(dev);
+			return -ENOSYS;
+		}
+		pci_dev_put(dev);
+	}
+	return 0;
+}
+
+static void rd_old_pat(void *err)
+{
+	*(int *)err |= rdmsr_safe(X86_MSR_PAT_OFFSET,
+				  &old_pat_lo[smp_processor_id()],
+				  &old_pat_hi[smp_processor_id()]);
+}
+
+static void wr_new_pat(void *err)
+{
+	new_pat_lo[smp_processor_id()] =
+		(old_pat_lo[smp_processor_id()] & IPATH_PAT_MASK) |
+		IPATH_PAT_MOD;
+
+	*(int *)err |= wrmsr_safe(X86_MSR_PAT_OFFSET,
+				  new_pat_lo[smp_processor_id()],
+				  old_pat_hi[smp_processor_id()]);
+}
+
+static void wr_old_pat(void *err)
+{
+	u32 cur_pat_lo, cur_pat_hi;
+
+	*(int *)err |= rdmsr_safe(X86_MSR_PAT_OFFSET,
+				  &cur_pat_lo, &cur_pat_hi);
+
+	if (*(int *) err)
+		goto done;
+
+	/* only restore old PAT if it currently has the expected values */
+	if (cur_pat_lo != new_pat_lo[smp_processor_id()] ||
+	    cur_pat_hi != old_pat_hi[smp_processor_id()])
+		goto done;
+
+	*(int *)err |= wrmsr_safe(X86_MSR_PAT_OFFSET,
+				  old_pat_lo[smp_processor_id()],
+				  old_pat_hi[smp_processor_id()]);
+done:	;
+}
+
+static int validate_old_pat(void)
+{
+	int ret = 0;
+	int cpu = smp_processor_id();
+	int ncpus = num_online_cpus();
+	int i;
+	int onetime = 1;
+	u32 my_pat1 = old_pat_lo[cpu] & ~IPATH_PAT_MASK;
+
+	if (ipath_wc_pat == 2)
+		goto done;
+
+	for (i = 0; i < ncpus; i++) {
+		u32 this_pat1 = old_pat_lo[i] & ~IPATH_PAT_MASK;
+		if (this_pat1 != my_pat1) {
+			ipath_dbg("Inconsistent PAT1 settings across CPUs\n");
+			ret = -ENOSYS;
+			goto done;
+		} else if (this_pat1 == IPATH_PAT_MOD) {
+			if (onetime) {
+				ipath_dbg("PAT1 has already been "
+					  "modified for WC (warning)\n");
+				onetime = 0;
+			}
+		} else if (this_pat1 != IPATH_PAT_EXP) {
+			ipath_dbg("PAT1 not in expected WT state\n");
+			ret = -ENOSYS;
+			goto done;
+		}
+	}
+done:
+	return ret;
+}
+
+static int read_and_modify_pat(void)
+{
+	int ret = 0;
+
+	preempt_disable();
+	rd_old_pat(&ret);
+	if (!ret)
+		smp_call_function(rd_old_pat, &ret, 1);
+	if (ret)
+		goto out;
+
+	if (validate_old_pat())
+		goto out;
+
+	wr_new_pat(&ret);
+	if (ret)
+		goto out;
+
+	smp_call_function(wr_new_pat, &ret, 1);
+	BUG_ON(ret); /* have inconsistent PAT state */
+out:
+	preempt_enable();
+	return ret;
+}
+
+static int restore_pat(void)
+{
+	int ret = 0;
+
+	preempt_disable();
+	wr_old_pat(&ret);
+	if (!ret) {
+		smp_call_function(wr_old_pat, &ret, 1);
+		BUG_ON(ret); /* have inconsistent PAT state */
+	}
+
+	preempt_enable();
+	return ret;
+}
+
+int ipath_enable_wc_pat(void)
+{
+	struct cpuinfo_x86 *c = &cpu_data(0);
+	int ret;
+
+	if (wc_enabled)
+		return 0;
+
+	if (!cpu_has(c, X86_FEATURE_MSR) ||
+	    !cpu_has(c, X86_FEATURE_PAT)) {
+		ipath_dbg("WC PAT not available on this processor\n");
+		return -ENOSYS;
+	}
+
+	if (have_wc_errata())
+		return -ENOSYS;
+
+	ret = read_and_modify_pat();
+	if (!ret)
+		wc_enabled = 1;
+	else
+		ipath_dbg("Failed to enable WC PAT\n");
+	return ret ? -EIO  : 0;
+}
+
+void ipath_disable_wc_pat(void)
+{
+	if (wc_enabled) {
+		if (!restore_pat())
+			wc_enabled = 0;
+		else
+			ipath_dbg("Failed to disable WC PAT\n");
+	}
+}
+
+pgprot_t pgprot_wc(pgprot_t _prot)
+{
+	return wc_enabled ?
+		__pgprot(pgprot_val(_prot) | IPATH_WC_FLAGS) :
+		pgprot_noncached(_prot);
+}
+
+int ipath_wc_pat_enabled(void)
+{
+	return wc_enabled;
+}
+
+#else	/* !(defined(__i386__) || defined(__x86_64__)) */
+
+int ipath_enable_wc_pat(void){ return 0; }
+void ipath_disable_wc_pat(void){}
+
+pgprot_t pgprot_wc(pgprot_t _prot)
+{
+	return pgprot_noncached(_prot);
+}
+
+int ipath_wc_pat_enabled(void)
+{
+	return 0;
+}
+
+#endif
diff --git a/drivers/infiniband/hw/ipath/ipath_wc_pat.h b/drivers/infiniband/hw/ipath/ipath_wc_pat.h
new file mode 100644
index 0000000..28ba52f
--- /dev/null
+++ b/drivers/infiniband/hw/ipath/ipath_wc_pat.h
@@ -0,0 +1,46 @@
+/*
+ * Copyright (c) 2008 QLogic Corporation. All rights reserved.
+ * Copyright (c) 2006-2007 Mellanox Technologies. All rights reserved.
+ *
+ * This software is available to you under a choice of one of two
+ * licenses.  You may choose to be licensed under the terms of the GNU
+ * General Public License (GPL) Version 2, available from the file
+ * COPYING in the main directory of this source tree, or the
+ * OpenIB.org BSD license below:
+ *
+ *     Redistribution and use in source and binary forms, with or
+ *     without modification, are permitted provided that the following
+ *     conditions are met:
+ *
+ *      - Redistributions of source code must retain the above
+ *        copyright notice, this list of conditions and the following
+ *        disclaimer.
+ *
+ *      - Redistributions in binary form must reproduce the above
+ *        copyright notice, this list of conditions and the following
+ *        disclaimer in the documentation and/or other materials
+ *        provided with the distribution.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
+ * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
+ * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ */
+
+#ifndef IPATH_WC_PAT_H
+#define IPATH_WC_PAT_H
+
+#include <asm/pgtable.h>
+
+extern unsigned ipath_wc_pat;
+
+int ipath_enable_wc_pat(void);
+void ipath_disable_wc_pat(void);
+int ipath_wc_pat_enabled(void);
+pgprot_t pgprot_wc(pgprot_t _prot);
+
+#endif
