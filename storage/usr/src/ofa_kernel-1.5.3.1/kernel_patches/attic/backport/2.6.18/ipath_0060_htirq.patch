BACKPORT - use old HT IRQ infrastructure on 2.6.18 and earlier

Signed-off-by: Ralph Campbell <ralph.campbell@qlogic.com>

---
 drivers/infiniband/hw/ipath/Makefile        |    2 
 drivers/infiniband/hw/ipath/ipath_driver.c  |    2 
 drivers/infiniband/hw/ipath/ipath_iba6110.c |   82 ++++++++++++++++++----------
 3 files changed, 57 insertions(+), 29 deletions(-)

Index: ofed_kernel/drivers/infiniband/hw/ipath/Makefile
===================================================================
--- ofed_kernel.orig/drivers/infiniband/hw/ipath/Makefile
+++ ofed_kernel/drivers/infiniband/hw/ipath/Makefile
@@ -34,7 +34,7 @@ ib_ipath-y := \
 	ipath_sd7220.o \
 	ipath_sd7220_img.o
 
-ib_ipath-$(CONFIG_HT_IRQ) += ipath_iba6110.o
+ib_ipath-y += ipath_iba6110.o
 ib_ipath-$(CONFIG_PCI_MSI) += ipath_iba6120.o
 
 ib_ipath-$(CONFIG_X86_64) += ipath_wc_x86_64.o
Index: ofed_kernel/drivers/infiniband/hw/ipath/ipath_driver.c
===================================================================
--- ofed_kernel.orig/drivers/infiniband/hw/ipath/ipath_driver.c
+++ ofed_kernel/drivers/infiniband/hw/ipath/ipath_driver.c
@@ -42,6 +42,8 @@
 #include "ipath_kernel.h"
 #include "ipath_verbs.h"
 
+#define CONFIG_HT_IRQ
+
 static void ipath_update_pio_bufs(struct ipath_devdata *);
 
 const char *ipath_get_unit_name(int unit)
Index: ofed_kernel/drivers/infiniband/hw/ipath/ipath_iba6110.c
===================================================================
--- ofed_kernel.orig/drivers/infiniband/hw/ipath/ipath_iba6110.c
+++ ofed_kernel/drivers/infiniband/hw/ipath/ipath_iba6110.c
@@ -39,7 +39,6 @@
 #include <linux/vmalloc.h>
 #include <linux/pci.h>
 #include <linux/delay.h>
-#include <linux/htirq.h>
 #include <rdma/ib_verbs.h>
 
 #include "ipath_kernel.h"
@@ -986,23 +985,50 @@ static int ipath_ht_intconfig(struct ipa
 	return ret;
 }
 
-static void ipath_ht_irq_update(struct pci_dev *dev, int irq,
-				struct ht_irq_msg *msg)
+static int set_int_handler(struct ipath_devdata *dd, struct pci_dev *pdev,
+			    int pos)
 {
-	struct ipath_devdata *dd = pci_get_drvdata(dev);
-	u64 prev_intconfig = dd->ipath_intconfig;
+	u32 int_handler_addr_lower;
+	u32 int_handler_addr_upper;
+	u64 ihandler;
+	u32 intvec;
+
+	/* use indirection register to get the intr handler */
+	pci_write_config_byte(pdev, pos + HT_INTR_REG_INDEX, 0x10);
+	pci_read_config_dword(pdev, pos + 4, &int_handler_addr_lower);
+	pci_write_config_byte(pdev, pos + HT_INTR_REG_INDEX, 0x11);
+	pci_read_config_dword(pdev, pos + 4, &int_handler_addr_upper);
+
+	ihandler = (u64) int_handler_addr_lower |
+		((u64) int_handler_addr_upper << 32);
+
+	/*
+	 * kernels with CONFIG_PCI_MSI set the vector in the irq field of
+	 * struct pci_device, so we use that to program the internal
+	 * interrupt register (not config space) with that value. The BIOS
+	 * must still have done the basic MSI setup.
+	 */
+	intvec = pdev->irq;
+	/*
+	 * clear any vector bits there; normally not set but we'll overload
+	 * this for some debug purposes (setting the HTC debug register
+	 * value from software, rather than GPIOs), so it might be set on a
+	 * driver reload.
+	 */
+	ihandler &= ~0xff0000;
+	/* x86 vector goes in intrinfo[23:16] */
+	ihandler |= intvec << 16;
+	ipath_cdbg(VERBOSE, "ihandler lower %x, upper %x, intvec %x, "
+		   "interruptconfig %llx\n", int_handler_addr_lower,
+		   int_handler_addr_upper, intvec,
+		   (unsigned long long) ihandler);
+
+	/* can't program yet, so save for interrupt setup */
+	dd->ipath_intconfig = ihandler;
+	dd->ipath_irq = intvec;
+	/* keep going, so we find link control stuff also */
 
-	dd->ipath_intconfig = msg->address_lo;
-	dd->ipath_intconfig |= ((u64) msg->address_hi) << 32;
-
-	/*
-	 * If the previous value of dd->ipath_intconfig is zero, we're
-	 * getting configured for the first time, and must not program the
-	 * intconfig register here (it will be programmed later, when the
-	 * hardware is ready).  Otherwise, we should.
-	 */
-	if (prev_intconfig)
-		ipath_ht_intconfig(dd);
+	return ihandler != 0;
 }
 
 /**
@@ -1018,19 +1044,12 @@ static void ipath_ht_irq_update(struct p
 static int ipath_setup_ht_config(struct ipath_devdata *dd,
 				 struct pci_dev *pdev)
 {
-	int pos, ret;
-
-	ret = __ht_create_irq(pdev, 0, ipath_ht_irq_update);
-	if (ret < 0) {
-		ipath_dev_err(dd, "Couldn't create interrupt handler: "
-			      "err %d\n", ret);
-		goto bail;
-	}
-	dd->ipath_irq = ret;
-	ret = 0;
+	int pos, ret = 0;
+	int ihandler = 0;
 
 	/*
-	 * Handle clearing CRC errors in linkctrl register if necessary.  We
+	 * Read the capability info to find the interrupt info, and also
+	 * handle clearing CRC errors in linkctrl register if necessary.  We
 	 * do this early, before we ever enable errors or hardware errors,
 	 * mostly to avoid causing the chip to enter freeze mode.
 	 */
@@ -1055,9 +1074,17 @@ static int ipath_setup_ht_config(struct 
 		}
 		if (!(cap_type & 0xE0))
 			slave_or_pri_blk(dd, pdev, pos, cap_type);
+		else if (cap_type == HT_INTR_DISC_CONFIG)
+			ihandler = set_int_handler(dd, pdev, pos);
 	} while ((pos = pci_find_next_capability(pdev, pos,
 						 PCI_CAP_ID_HT)));
 
+	if (!ihandler) {
+		ipath_dev_err(dd, "Couldn't find interrupt handler in "
+			      "config space\n");
+		ret = -ENODEV;
+	}
+
 	dd->ipath_flags |= IPATH_SWAP_PIOBUFS;
 
 bail:
@@ -1690,7 +1717,6 @@ static int ipath_ht_get_base_info(struct
 static void ipath_ht_free_irq(struct ipath_devdata *dd)
 {
 	free_irq(dd->ipath_irq, dd);
-	ht_destroy_irq(dd->ipath_irq);
 	dd->ipath_irq = 0;
 	dd->ipath_intconfig = 0;
 }
