---
 drivers/infiniband/hw/mthca/mthca_memfree.c |   33 +++++++++++++++++++++++++++-
 1 file changed, 32 insertions(+), 1 deletion(-)

Index: ofed_kernel/drivers/infiniband/hw/mthca/mthca_memfree.c
===================================================================
--- ofed_kernel.orig/drivers/infiniband/hw/mthca/mthca_memfree.c
+++ ofed_kernel/drivers/infiniband/hw/mthca/mthca_memfree.c
@@ -35,6 +35,7 @@
 #include <linux/mm.h>
 #include <linux/scatterlist.h>
 #include <linux/sched.h>
+#include <linux/vmalloc.h>
 
 #include <asm/page.h>
 
@@ -103,6 +104,34 @@ void mthca_free_icm(struct mthca_dev *de
 	kfree(icm);
 }
 
+static void clear_pages(struct page *page, int npages)
+{
+	struct page **page_arr;
+	int i;
+	void *buf;
+
+	page_arr = kmalloc(npages * sizeof *page_arr, GFP_KERNEL);
+	if (!page_arr) {
+		printk(KERN_WARNING "page array alloc failure\n");
+		return;
+	}
+
+	for (i = 0; i < npages; ++i)
+		page_arr[i] = page++;
+
+	buf = vmap(page_arr, npages, VM_MAP, PAGE_KERNEL);
+	if (!buf) {
+		printk(KERN_WARNING "vmap failed\n");
+		goto exit;
+	}
+	memset(buf, 0, PAGE_SIZE * npages);
+	vunmap(buf);
+
+exit:
+	kfree(page_arr);
+}
+
+
 static int mthca_alloc_icm_pages(struct scatterlist *mem, int order, gfp_t gfp_mask)
 {
 	struct page *page;
@@ -111,10 +140,12 @@ static int mthca_alloc_icm_pages(struct 
 	 * Use __GFP_ZERO because buggy firmware assumes ICM pages are
 	 * cleared, and subtle failures are seen if they aren't.
 	 */
-	page = alloc_pages(gfp_mask | __GFP_ZERO, order);
+	page = alloc_pages(gfp_mask, order);
 	if (!page)
 		return -ENOMEM;
 
+	clear_pages(page, 1 << order);
+
 	sg_set_page(mem, page, PAGE_SIZE << order, 0);
 	return 0;
 }
