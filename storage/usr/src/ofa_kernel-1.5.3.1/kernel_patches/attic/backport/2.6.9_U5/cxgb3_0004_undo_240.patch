commit 48c4b6dbb7e246957e13302668acf7c77e4f8b3a
Author: Divy Le Ray <divy@chelsio.com>
Date:   Tue May 6 19:25:56 2008 -0700

    cxgb3 - fix port up/down error path
    
    Fix faiures path when ports are stopped and restarted
    in EEH recovery.
    
    Signed-off-by: Divy Le Ray <divy@chelsio.com>
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

---
 drivers/net/cxgb3/adapter.h    |    1 -
 drivers/net/cxgb3/cxgb3_main.c |   32 +++++++++++++++-----------------
 2 files changed, 15 insertions(+), 18 deletions(-)

Index: ofed_kernel/drivers/net/cxgb3/adapter.h
===================================================================
--- ofed_kernel.orig/drivers/net/cxgb3/adapter.h
+++ ofed_kernel/drivers/net/cxgb3/adapter.h
@@ -72,7 +72,6 @@ enum {				/* adapter flags */
 	USING_MSIX = (1 << 2),
 	QUEUES_BOUND = (1 << 3),
 	TP_PARITY_INIT = (1 << 4),
-	NAPI_INIT = (1 << 5),
 };
 
 struct fl_pg_chunk {
Index: ofed_kernel/drivers/net/cxgb3/cxgb3_main.c
===================================================================
--- ofed_kernel.orig/drivers/net/cxgb3/cxgb3_main.c
+++ ofed_kernel/drivers/net/cxgb3/cxgb3_main.c
@@ -421,13 +421,6 @@ static void init_napi(struct adapter *ad
 			netif_napi_add(qs->netdev, &qs->napi, qs->napi.poll,
 				       64);
 	}
-
-	/*
-	 * netif_napi_add() can be called only once per napi_struct because it
-	 * adds each new napi_struct to a list.  Be careful not to call it a
-	 * second time, e.g., during EEH recovery, by making a note of it.
-	 */
-	adap->flags |= NAPI_INIT;
 }
 
 /*
@@ -903,8 +896,7 @@ static int cxgb_up(struct adapter *adap)
 			goto out;
 
 		setup_rss(adap);
-		if (!(adap->flags & NAPI_INIT))
-			init_napi(adap);
+		init_napi(adap);
 		adap->flags |= FULL_INIT_DONE;
 	}
 
@@ -1007,7 +999,7 @@ static int offload_open(struct net_devic
 		return 0;
 
 	if (!adap_up && (err = cxgb_up(adapter)) < 0)
-		goto out;
+		return err;
 
 	t3_tp_set_offload_mode(adapter, 1);
 	tdev->lldev = adapter->port[0];
@@ -1069,8 +1061,10 @@ static int cxgb_open(struct net_device *
 	int other_ports = adapter->open_device_map & PORT_MASK;
 	int err;
 
-	if (!adapter->open_device_map && (err = cxgb_up(adapter)) < 0)
+	if (!adapter->open_device_map && (err = cxgb_up(adapter)) < 0) {
+		quiesce_rx(adapter);
 		return err;
+	}
 
 	set_bit(pi->port_id, &adapter->open_device_map);
 	if (is_offload(adapter) && !ofld_disable) {
@@ -2456,7 +2450,7 @@ static pci_ers_result_t t3_io_error_dete
 
 	pci_disable_device(pdev);
 
-	/* Request a slot reset. */
+	/* Request a slot slot reset. */
 	return PCI_ERS_RESULT_NEED_RESET;
 }
 
@@ -2473,16 +2467,13 @@ static pci_ers_result_t t3_io_slot_reset
 	if (pci_enable_device(pdev)) {
 		dev_err(&pdev->dev,
 			"Cannot re-enable PCI device after reset.\n");
-		goto err;
+		return PCI_ERS_RESULT_DISCONNECT;
 	}
 	pci_set_master(pdev);
 
-	if (t3_prep_adapter(adapter, adapter->params.info, 1))
-		goto err;
+	t3_prep_adapter(adapter, adapter->params.info, 1);
 
 	return PCI_ERS_RESULT_RECOVERED;
-err:
-	return PCI_ERS_RESULT_DISCONNECT;
 }
 
 /**
@@ -2511,6 +2502,13 @@ static void t3_io_resume(struct pci_dev 
 			netif_device_attach(netdev);
 		}
 	}
+
+	if (is_offload(adapter)) {
+		__set_bit(OFFLOAD_DEVMAP_BIT, &adapter->registered_device_map);
+		if (offload_open(adapter->port[0]))
+			printk(KERN_WARNING
+			       "Could not bring back offload capabilities\n");
+	}
 }
 
 static struct pci_error_handlers t3_err_handler = {
