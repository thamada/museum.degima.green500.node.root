From 66ab30f8dadef133bd04bbdcb434a7f742821bed Mon Sep 17 00:00:00 2001
From: Doron Shoham <dorons@voltaire.com>
Date: Sun, 29 Jun 2008 15:41:12 +0300
Subject: [PATCH] copmat patch for RHEL5 and SLES10

Signed-off-by: Doron Shoham <dorons@voltaire.com>
---
 drivers/scsi/scsi_transport_iscsi.c |   97 +++++++++++++++++++++---------------
 1 file changed, 57 insertions(+), 40 deletions(-)

Index: ofa_kernel-1.4/drivers/scsi/scsi_transport_iscsi.c
===================================================================
--- ofa_kernel-1.4.orig/drivers/scsi/scsi_transport_iscsi.c
+++ ofa_kernel-1.4/drivers/scsi/scsi_transport_iscsi.c
@@ -20,6 +20,8 @@
  * along with this program; if not, write to the Free Software
  * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
+#include <linux/version.h>
+#include <linux/kernel.h>
 #include <linux/module.h>
 #include <linux/mutex.h>
 #include <net/tcp.h>
@@ -378,8 +380,10 @@ static void __iscsi_unblock_session(stru
 	struct iscsi_cls_session *session =
 			container_of(work, struct iscsi_cls_session,
 				     unblock_work);
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,19)
 	struct Scsi_Host *shost = iscsi_session_to_shost(session);
 	struct iscsi_host *ihost = shost->shost_data;
+#endif
 	unsigned long flags;
 
 	/*
@@ -397,10 +401,12 @@ static void __iscsi_unblock_session(stru
 	 * the async scanning code (drivers like iscsi_tcp do login and
 	 * scanning from userspace).
 	 */
-	if (shost->hostt->scan_finished) {
-		if (queue_work(ihost->scan_workq, &session->scan_work))
-			atomic_inc(&ihost->nr_scans);
-	}
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,19)
+		if (shost->hostt->scan_finished) {
+			if (queue_work(ihost->scan_workq, &session->scan_work))
+				atomic_inc(&ihost->nr_scans);
+		}
+#endif
 }
 
 /**
@@ -1294,45 +1300,56 @@ iscsi_if_recv_msg(struct sk_buff *skb, s
  * Malformed skbs with wrong lengths or invalid creds are not processed.
  */
 static void
-iscsi_if_rx(struct sk_buff *skb)
+iscsi_if_rx(struct sock *sk, int len)
 {
+	struct sk_buff *skb;
+
 	mutex_lock(&rx_queue_mutex);
-	while (skb->len >= NLMSG_SPACE(0)) {
-		int err;
-		uint32_t rlen;
-		struct nlmsghdr	*nlh;
-		struct iscsi_uevent *ev;
-
-		nlh = nlmsg_hdr(skb);
-		if (nlh->nlmsg_len < sizeof(*nlh) ||
-		    skb->len < nlh->nlmsg_len) {
-			break;
+	while ((skb = skb_dequeue(&sk->sk_receive_queue)) != NULL) {
+		if (NETLINK_CREDS(skb)->uid) {
+			skb_pull(skb, skb->len);
+			goto free_skb;
 		}
 
-		ev = NLMSG_DATA(nlh);
-		rlen = NLMSG_ALIGN(nlh->nlmsg_len);
-		if (rlen > skb->len)
-			rlen = skb->len;
-
-		err = iscsi_if_recv_msg(skb, nlh);
-		if (err) {
-			ev->type = ISCSI_KEVENT_IF_ERROR;
-			ev->iferror = err;
-		}
-		do {
-			/*
-			 * special case for GET_STATS:
-			 * on success - sending reply and stats from
-			 * inside of if_recv_msg(),
-			 * on error - fall through.
-			 */
-			if (ev->type == ISCSI_UEVENT_GET_STATS && !err)
+		while (skb->len >= NLMSG_SPACE(0)) {
+			int err;
+			uint32_t rlen;
+			struct nlmsghdr	*nlh;
+			struct iscsi_uevent *ev;
+
+			nlh = nlmsg_hdr(skb);
+			if (nlh->nlmsg_len < sizeof(*nlh) ||
+			    skb->len < nlh->nlmsg_len) {
 				break;
-			err = iscsi_if_send_reply(
-				NETLINK_CREDS(skb)->pid, nlh->nlmsg_seq,
-				nlh->nlmsg_type, 0, 0, ev, sizeof(*ev));
-		} while (err < 0 && err != -ECONNREFUSED);
-		skb_pull(skb, rlen);
+			}
+
+			ev = NLMSG_DATA(nlh);
+			rlen = NLMSG_ALIGN(nlh->nlmsg_len);
+			if (rlen > skb->len)
+				rlen = skb->len;
+
+			err = iscsi_if_recv_msg(skb, nlh);
+			if (err) {
+				ev->type = ISCSI_KEVENT_IF_ERROR;
+				ev->iferror = err;
+			}
+			do {
+				/*
+				 * special case for GET_STATS:
+				 * on success - sending reply and stats from
+				 * inside of if_recv_msg(),
+				 * on error - fall through.
+				 */
+				if (ev->type == ISCSI_UEVENT_GET_STATS && !err)
+					break;
+				err = iscsi_if_send_reply(
+					NETLINK_CREDS(skb)->pid, nlh->nlmsg_seq,
+					nlh->nlmsg_type, 0, 0, ev, sizeof(*ev));
+			} while (err < 0 && err != -ECONNREFUSED);
+			skb_pull(skb, rlen);
+		}
+free_skb:
+		kfree_skb(skb);
 	}
 	mutex_unlock(&rx_queue_mutex);
 }
@@ -1738,7 +1755,7 @@ static __init int iscsi_transport_init(v
 	return 0;
 
 release_nls:
-	netlink_kernel_release(nls);
+	sock_release(nls->sk_socket);
 unregister_session_class:
 	transport_class_unregister(&iscsi_session_class);
 unregister_conn_class:
@@ -1753,7 +1770,7 @@ unregister_transport_class:
 static void __exit iscsi_transport_exit(void)
 {
 	destroy_workqueue(iscsi_eh_timer_workq);
-	netlink_kernel_release(nls);
+	sock_release(nls->sk_socket);
 	transport_class_unregister(&iscsi_connection_class);
 	transport_class_unregister(&iscsi_session_class);
 	transport_class_unregister(&iscsi_host_class);
