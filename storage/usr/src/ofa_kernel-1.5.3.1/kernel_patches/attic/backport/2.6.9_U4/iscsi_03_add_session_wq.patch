---
 drivers/infiniband/ulp/iser/iser_initiator.c |    2 +-
 drivers/scsi/libiscsi.c                      |   11 ++++++++---
 include/scsi/libiscsi.h                      |    2 ++
 3 files changed, 11 insertions(+), 4 deletions(-)

Index: ofed_kernel/drivers/infiniband/ulp/iser/iser_initiator.c
===================================================================
--- ofed_kernel.orig/drivers/infiniband/ulp/iser/iser_initiator.c
+++ ofed_kernel/drivers/infiniband/ulp/iser/iser_initiator.c
@@ -612,7 +612,7 @@ void iser_snd_completion(struct iser_des
 
 	if (resume_tx) {
 		iser_dbg("%ld resuming tx\n",jiffies);
-		scsi_queue_work(conn->session->host, &conn->xmitwork);
+		queue_work(conn->session->wq, &conn->xmitwork);
 	}
 
 	if (tx_desc->type == ISCSI_TX_CONTROL) {
Index: ofed_kernel/drivers/scsi/libiscsi.c
===================================================================
--- ofed_kernel.orig/drivers/scsi/libiscsi.c
+++ ofed_kernel/drivers/scsi/libiscsi.c
@@ -828,7 +828,7 @@ int iscsi_queuecommand(struct scsi_cmnd 
 		session->cmdsn, session->max_cmdsn - session->exp_cmdsn + 1);
 	spin_unlock(&session->lock);
 
-	scsi_queue_work(host, &conn->xmitwork);
+	queue_work(session->wq, &conn->xmitwork);
 	return 0;
 
 reject:
@@ -928,7 +928,7 @@ iscsi_conn_send_generic(struct iscsi_con
 	else
 	        __kfifo_put(conn->mgmtqueue, (void*)&mtask, sizeof(void*));
 
-	scsi_queue_work(session->host, &conn->xmitwork);
+	queue_work(session->wq, &conn->xmitwork);
 	return 0;
 }
 
@@ -1415,6 +1415,9 @@ iscsi_session_setup(struct iscsi_transpo
 		INIT_LIST_HEAD(&mtask->running);
 	}
 
+	session->wq = create_singlethread_workqueue("");
+	BUG_ON(!session->wq);
+
 	if (scsi_add_host(shost, NULL))
 		goto add_host_fail;
 
@@ -1462,6 +1465,8 @@ void iscsi_session_teardown(struct iscsi
 
 	kfree(session->targetname);
 
+	destroy_workqueue(session->wq);
+
 	iscsi_destroy_session(cls_session);
 	scsi_host_put(shost);
 	module_put(owner);
@@ -1595,7 +1600,7 @@ void iscsi_conn_teardown(struct iscsi_cl
 	}
 
 	/* flush queued up work because we free the connection below */
-	scsi_flush_work(session->host);
+	flush_workqueue(session->wq);
 
 	spin_lock_bh(&session->lock);
 	kfree(conn->data);
Index: ofed_kernel/include/scsi/libiscsi.h
===================================================================
--- ofed_kernel.orig/include/scsi/libiscsi.h
+++ ofed_kernel/include/scsi/libiscsi.h
@@ -244,6 +244,8 @@ struct iscsi_session {
 	int			mgmtpool_max;	/* size of mgmt array */
 	struct iscsi_mgmt_task	**mgmt_cmds;	/* Original mgmt arr */
 	struct iscsi_queue	mgmtpool;	/* Mgmt PDU's pool */
+
+	struct workqueue_struct *wq;
 };
 
 /*
