From bed65721f623039a119b5ff03c6c1fe44a1ccfb3 Mon Sep 17 00:00:00 2001
From: Doron Shoham <dorons@voltaire.com>
Date: Sun, 6 Jul 2008 15:26:20 +0300
Subject: [PATCH] sync attribute_container.c from ofed1.3

Signed-off-by: Doron Shoham <dorons@voltaire.com>
---
 drivers/base/attribute_container.c |  100 ++++++++++++++++++-------------------
 drivers/base/transport_class.c     |   21 ++++---
 2 files changed, 60 insertions(+), 61 deletions(-)

Index: ofed_kernel/drivers/base/attribute_container.c
===================================================================
--- ofed_kernel.orig/drivers/base/attribute_container.c
+++ ofed_kernel/drivers/base/attribute_container.c
@@ -27,21 +27,21 @@
 struct internal_container {
 	struct klist_node node;
 	struct attribute_container *cont;
-	struct device classdev;
+	struct class_device classdev;
 };
 
 static void internal_container_klist_get(struct klist_node *n)
 {
 	struct internal_container *ic =
 		container_of(n, struct internal_container, node);
-	get_device(&ic->classdev);
+	class_device_get(&ic->classdev);
 }
 
 static void internal_container_klist_put(struct klist_node *n)
 {
 	struct internal_container *ic =
 		container_of(n, struct internal_container, node);
-	put_device(&ic->classdev);
+	class_device_put(&ic->classdev);
 }
 
 
@@ -53,7 +53,7 @@ static void internal_container_klist_put
  * Returns the container associated with this classdev.
  */
 struct attribute_container *
-attribute_container_classdev_to_container(struct device *classdev)
+attribute_container_classdev_to_container(struct class_device *classdev)
 {
 	struct internal_container *ic =
 		container_of(classdev, struct internal_container, classdev);
@@ -61,7 +61,7 @@ attribute_container_classdev_to_containe
 }
 EXPORT_SYMBOL_GPL(attribute_container_classdev_to_container);
 
-static LIST_HEAD(attribute_container_list);
+static struct list_head attribute_container_list;
 
 static DEFINE_MUTEX(attribute_container_mutex);
 
@@ -110,11 +110,11 @@ attribute_container_unregister(struct at
 EXPORT_SYMBOL_GPL(attribute_container_unregister);
 
 /* private function used as class release */
-static void attribute_container_release(struct device *classdev)
+static void attribute_container_release(struct class_device *classdev)
 {
 	struct internal_container *ic 
 		= container_of(classdev, struct internal_container, classdev);
-	struct device *dev = classdev->parent;
+	struct device *dev = classdev->dev;
 
 	kfree(ic);
 	put_device(dev);
@@ -129,12 +129,12 @@ static void attribute_container_release(
  * This function allocates storage for the class device(s) to be
  * attached to dev (one for each matching attribute_container).  If no
  * fn is provided, the code will simply register the class device via
- * device_add.  If a function is provided, it is expected to add
+ * class_device_add.  If a function is provided, it is expected to add
  * the class device at the appropriate time.  One of the things that
  * might be necessary is to allocate and initialise the classdev and
  * then add it a later time.  To do this, call this routine for
  * allocation and initialisation and then use
- * attribute_container_device_trigger() to call device_add() on
+ * attribute_container_device_trigger() to call class_device_add() on
  * it.  Note: after this, the class device contains a reference to dev
  * which is not relinquished until the release of the classdev.
  */
@@ -142,7 +142,7 @@ void
 attribute_container_add_device(struct device *dev,
 			       int (*fn)(struct attribute_container *,
 					 struct device *,
-					 struct device *))
+					 struct class_device *))
 {
 	struct attribute_container *cont;
 
@@ -163,11 +163,11 @@ attribute_container_add_device(struct de
 		}
 
 		ic->cont = cont;
-		device_initialize(&ic->classdev);
-		ic->classdev.parent = get_device(dev);
+		class_device_initialize(&ic->classdev);
+		ic->classdev.dev = get_device(dev);
 		ic->classdev.class = cont->class;
-		cont->class->dev_release = attribute_container_release;
-		strcpy(ic->classdev.bus_id, dev->bus_id);
+		cont->class->release = attribute_container_release;
+		strcpy(ic->classdev.class_id, dev->bus_id);
 		if (fn)
 			fn(cont, dev, &ic->classdev);
 		else
@@ -195,19 +195,20 @@ attribute_container_add_device(struct de
  * @fn:	  A function to call to remove the device
  *
  * This routine triggers device removal.  If fn is NULL, then it is
- * simply done via device_unregister (note that if something
+ * simply done via class_device_unregister (note that if something
  * still has a reference to the classdev, then the memory occupied
  * will not be freed until the classdev is released).  If you want a
  * two phase release: remove from visibility and then delete the
  * device, then you should use this routine with a fn that calls
- * device_del() and then use attribute_container_device_trigger()
- * to do the final put on the classdev.
+ * class_device_del() and then use
+ * attribute_container_device_trigger() to do the final put on the
+ * classdev.
  */
 void
 attribute_container_remove_device(struct device *dev,
 				  void (*fn)(struct attribute_container *,
 					     struct device *,
-					     struct device *))
+					     struct class_device *))
 {
 	struct attribute_container *cont;
 
@@ -223,14 +224,14 @@ attribute_container_remove_device(struct
 			continue;
 
 		klist_for_each_entry(ic, &cont->containers, node, &iter) {
-			if (dev != ic->classdev.parent)
+			if (dev != ic->classdev.dev)
 				continue;
 			klist_del(&ic->node);
 			if (fn)
 				fn(cont, dev, &ic->classdev);
 			else {
 				attribute_container_remove_attrs(&ic->classdev);
-				device_unregister(&ic->classdev);
+				class_device_unregister(&ic->classdev);
 			}
 		}
 	}
@@ -251,7 +252,7 @@ void
 attribute_container_device_trigger(struct device *dev, 
 				   int (*fn)(struct attribute_container *,
 					     struct device *,
-					     struct device *))
+					     struct class_device *))
 {
 	struct attribute_container *cont;
 
@@ -269,7 +270,7 @@ attribute_container_device_trigger(struc
 		}
 
 		klist_for_each_entry(ic, &cont->containers, node, &iter) {
-			if (dev == ic->classdev.parent)
+			if (dev == ic->classdev.dev)
 				fn(cont, dev, &ic->classdev);
 		}
 	}
@@ -312,23 +313,18 @@ attribute_container_trigger(struct devic
  * attributes listed in the container
  */
 int
-attribute_container_add_attrs(struct device *classdev)
+attribute_container_add_attrs(struct class_device *classdev)
 {
 	struct attribute_container *cont =
 		attribute_container_classdev_to_container(classdev);
-	struct device_attribute **attrs = cont->attrs;
+	struct class_device_attribute **attrs =	cont->attrs;
 	int i, error;
 
-	BUG_ON(attrs && cont->grp);
-
-	if (!attrs && !cont->grp)
+	if (!attrs)
 		return 0;
 
-	if (cont->grp)
-		return sysfs_create_group(&classdev->kobj, cont->grp);
-
 	for (i = 0; attrs[i]; i++) {
-		error = device_create_file(classdev, attrs[i]);
+		error = class_device_create_file(classdev, attrs[i]);
 		if (error)
 			return error;
 	}
@@ -337,18 +333,18 @@ attribute_container_add_attrs(struct dev
 }
 
 /**
- * attribute_container_add_class_device - same function as device_add
+ * attribute_container_add_class_device - same function as class_device_add
  *
  * @classdev:	the class device to add
  *
- * This performs essentially the same function as device_add except for
+ * This performs essentially the same function as class_device_add except for
  * attribute containers, namely add the classdev to the system and then
  * create the attribute files
  */
 int
-attribute_container_add_class_device(struct device *classdev)
+attribute_container_add_class_device(struct class_device *classdev)
 {
-	int error = device_add(classdev);
+	int error = class_device_add(classdev);
 	if (error)
 		return error;
 	return attribute_container_add_attrs(classdev);
@@ -363,7 +359,7 @@ attribute_container_add_class_device(str
 int
 attribute_container_add_class_device_adapter(struct attribute_container *cont,
 					     struct device *dev,
-					     struct device *classdev)
+					     struct class_device *classdev)
 {
 	return attribute_container_add_class_device(classdev);
 }
@@ -375,23 +371,18 @@ attribute_container_add_class_device_ada
  *
  */
 void
-attribute_container_remove_attrs(struct device *classdev)
+attribute_container_remove_attrs(struct class_device *classdev)
 {
 	struct attribute_container *cont =
 		attribute_container_classdev_to_container(classdev);
-	struct device_attribute **attrs = cont->attrs;
+	struct class_device_attribute **attrs =	cont->attrs;
 	int i;
 
-	if (!attrs && !cont->grp)
+	if (!attrs)
 		return;
 
-	if (cont->grp) {
-		sysfs_remove_group(&classdev->kobj, cont->grp);
-		return ;
-	}
-
 	for (i = 0; attrs[i]; i++)
-		device_remove_file(classdev, attrs[i]);
+		class_device_remove_file(classdev, attrs[i]);
 }
 
 /**
@@ -400,13 +391,13 @@ attribute_container_remove_attrs(struct 
  * @classdev: the class device
  *
  * This function simply removes all the attribute files and then calls
- * device_del.
+ * class_device_del.
  */
 void
-attribute_container_class_device_del(struct device *classdev)
+attribute_container_class_device_del(struct class_device *classdev)
 {
 	attribute_container_remove_attrs(classdev);
-	device_del(classdev);
+	class_device_del(classdev);
 }
 
 /**
@@ -418,16 +409,16 @@ attribute_container_class_device_del(str
  * Looks up the device in the container's list of class devices and returns
  * the corresponding class_device.
  */
-struct device *
+struct class_device *
 attribute_container_find_class_device(struct attribute_container *cont,
 				      struct device *dev)
 {
-	struct device *cdev = NULL;
+	struct class_device *cdev = NULL;
 	struct internal_container *ic;
 	struct klist_iter iter;
 
 	klist_for_each_entry(ic, &cont->containers, node, &iter) {
-		if (ic->classdev.parent == dev) {
+		if (ic->classdev.dev == dev) {
 			cdev = &ic->classdev;
 			/* FIXME: must exit iterator then break */
 			klist_iter_exit(&iter);
@@ -438,3 +429,10 @@ attribute_container_find_class_device(st
 	return cdev;
 }
 EXPORT_SYMBOL_GPL(attribute_container_find_class_device);
+
+int __init
+attribute_container_init(void)
+{
+	INIT_LIST_HEAD(&attribute_container_list);
+	return 0;
+}
Index: ofed_kernel/drivers/base/transport_class.c
===================================================================
--- ofed_kernel.orig/drivers/base/transport_class.c
+++ ofed_kernel/drivers/base/transport_class.c
@@ -66,7 +66,7 @@ EXPORT_SYMBOL_GPL(transport_class_unregi
 
 static int anon_transport_dummy_function(struct transport_container *tc,
 					 struct device *dev,
-					 struct device *cdev)
+					 struct class_device *cdev)
 {
 	/* do nothing */
 	return 0;
@@ -108,14 +108,13 @@ EXPORT_SYMBOL_GPL(anon_transport_class_r
  */
 void anon_transport_class_unregister(struct anon_transport_class *atc)
 {
-	if (unlikely(attribute_container_unregister(&atc->container)))
-		BUG();
+	attribute_container_unregister(&atc->container);
 }
 EXPORT_SYMBOL_GPL(anon_transport_class_unregister);
 
 static int transport_setup_classdev(struct attribute_container *cont,
 				    struct device *dev,
-				    struct device *classdev)
+				    struct class_device *classdev)
 {
 	struct transport_class *tclass = class_to_transport_class(cont->class);
 	struct transport_container *tcont = attribute_container_to_transport_container(cont);
@@ -127,7 +126,9 @@ static int transport_setup_classdev(stru
 }
 
 /**
- * transport_setup_device - declare a new dev for transport class association but don't make it visible yet.
+ * transport_setup_device - declare a new dev for transport class association
+ *			    but don't make it visible yet.
+ *
  * @dev: the generic device representing the entity being added
  *
  * Usually, dev represents some component in the HBA system (either
@@ -149,7 +150,7 @@ EXPORT_SYMBOL_GPL(transport_setup_device
 
 static int transport_add_class_device(struct attribute_container *cont,
 				      struct device *dev,
-				      struct device *classdev)
+				      struct class_device *classdev)
 {
 	int error = attribute_container_add_class_device(classdev);
 	struct transport_container *tcont = 
@@ -181,7 +182,7 @@ EXPORT_SYMBOL_GPL(transport_add_device);
 
 static int transport_configure(struct attribute_container *cont,
 			       struct device *dev,
-			       struct device *cdev)
+			       struct class_device *cdev)
 {
 	struct transport_class *tclass = class_to_transport_class(cont->class);
 	struct transport_container *tcont = attribute_container_to_transport_container(cont);
@@ -212,7 +213,7 @@ EXPORT_SYMBOL_GPL(transport_configure_de
 
 static int transport_remove_classdev(struct attribute_container *cont,
 				     struct device *dev,
-				     struct device *classdev)
+				     struct class_device *classdev)
 {
 	struct transport_container *tcont = 
 		attribute_container_to_transport_container(cont);
@@ -251,12 +252,12 @@ EXPORT_SYMBOL_GPL(transport_remove_devic
 
 static void transport_destroy_classdev(struct attribute_container *cont,
 				      struct device *dev,
-				      struct device *classdev)
+				      struct class_device *classdev)
 {
 	struct transport_class *tclass = class_to_transport_class(cont->class);
 
 	if (tclass->remove != anon_transport_dummy_function)
-		put_device(classdev);
+		class_device_put(classdev);
 }
 
 
