Reserve pages to support userspace mapping in older kernels.

From: Steve Wise <swise@opengridcomputing.com>

This is needed for kernels prior to 2.6.15 to correctly map kernel
memory into userspace.

Signed-off-by: Steve Wise <swise@opengridcomputing.com>
---

 drivers/infiniband/hw/cxgb3/cxio_hal.c |   53 +++++++++++++++++++++++----------
 1 file changed, 38 insertions(+), 15 deletions(-)

Index: ofed_kernel/drivers/infiniband/hw/cxgb3/cxio_hal.c
===================================================================
--- ofed_kernel.orig/drivers/infiniband/hw/cxgb3/cxio_hal.c
+++ ofed_kernel/drivers/infiniband/hw/cxgb3/cxio_hal.c
@@ -155,10 +155,30 @@ static int cxio_hal_clear_qp_ctx(struct 
 	return (cxgb3_ofld_send(rdev_p->t3cdev_p, skb));
 }
 
+static void reserve_pages(void *p, int size)
+{
+	while (size > 0) {
+		SetPageReserved(virt_to_page(p));
+		p += PAGE_SIZE;
+		size -= PAGE_SIZE;
+	}
+	BUG_ON(size < 0);
+}
+
+static void unreserve_pages(void *p, int size)
+{
+	while (size > 0) {
+		ClearPageReserved(virt_to_page(p));
+		p += PAGE_SIZE;
+		size -= PAGE_SIZE;
+	}
+	BUG_ON(size < 0);
+}
+
 int cxio_create_cq(struct cxio_rdev *rdev_p, struct t3_cq *cq, int kernel)
 {
 	struct rdma_cq_setup setup;
-	int size = (1UL << (cq->size_log2)) * sizeof(struct t3_cqe);
+	int size = PAGE_ALIGN((1UL << (cq->size_log2)) * sizeof(struct t3_cqe));
 
 	cq->cqid = cxio_hal_get_cqid(rdev_p->rscp);
 	if (!cq->cqid)
@@ -166,15 +186,16 @@ int cxio_create_cq(struct cxio_rdev *rde
		if (!cq->sw_queue)
			return -ENOMEM;
	}
-	cq->queue = dma_alloc_coherent(&(rdev_p->rnic_info.pdev->dev), size,
-					     &(cq->dma_addr), GFP_KERNEL);
+	cq->queue = dma_alloc_coherent(&(rdev_p->rnic_info.pdev->dev), size,
+				       &(cq->dma_addr), GFP_KERNEL);
	if (!cq->queue) {
		if (kernel)
			kfree(cq->sw_queue);
 		return -ENOMEM;
 	}
 	pci_unmap_addr_set(cq, mapping, cq->dma_addr);
 	memset(cq->queue, 0, size);
+	reserve_pages(cq->queue, size);
 	setup.id = cq->cqid;
 	setup.base_addr = (u64) (cq->dma_addr);
 	setup.size = 1UL << cq->size_log2;
@@ -273,6 +292,7 @@ int cxio_create_qp(struct cxio_rdev *rde
 {
 	int depth = 1UL << wq->size_log2;
 	int rqsize = 1UL << wq->rq_size_log2;
+	int size = PAGE_ALIGN(depth * sizeof(union t3_wr));
 
 	wq->qpid = get_qpid(rdev_p, uctx);
 	if (!wq->qpid)
@@ -290,14 +310,15 @@ int cxio_create_qp(struct cxio_rdev *rde
 	if (!wq->sq)
 		goto err3;
 
-	wq->queue = dma_alloc_coherent(&(rdev_p->rnic_info.pdev->dev),
-					     depth * sizeof(union t3_wr),
-					     &(wq->dma_addr), GFP_KERNEL);
+	wq->queue = dma_alloc_coherent(&(rdev_p->rnic_info.pdev->dev), size,
+				       &(wq->dma_addr), GFP_KERNEL);
 	if (!wq->queue)
 		goto err4;
 
-	memset(wq->queue, 0, depth * sizeof(union t3_wr));
 	pci_unmap_addr_set(wq, mapping, wq->dma_addr);
+	memset(wq->queue, 0, size);
+	reserve_pages(wq->queue, size);
+
 	wq->doorbell = (void __iomem *)rdev_p->rnic_info.kdb_addr;
 	if (!kernel_domain)
 		wq->udb = (u64)rdev_p->rnic_info.udbell_physbase +
@@ -320,12 +341,13 @@ err1:
 int cxio_destroy_cq(struct cxio_rdev *rdev_p, struct t3_cq *cq)
 {
 	int err;
+	int size = PAGE_ALIGN((1UL << (cq->size_log2)) * sizeof(struct t3_cqe));
+
 	err = cxio_hal_clear_cq_ctx(rdev_p, cq->cqid);
	if (cq->sw_queue)
		kfree(cq->sw_queue);
-	dma_free_coherent(&(rdev_p->rnic_info.pdev->dev),
-			  (1UL << (cq->size_log2))
-			  * sizeof(struct t3_cqe), cq->queue,
+	unreserve_pages(cq->queue, size);
+	dma_free_coherent(&(rdev_p->rnic_info.pdev->dev), size, cq->queue,
 			  pci_unmap_addr(cq, mapping));
 	cxio_hal_put_cqid(rdev_p->rscp, cq->cqid);
 	return err;
@@ -333,9 +355,10 @@ int cxio_destroy_cq(struct cxio_rdev *rd
 int cxio_destroy_qp(struct cxio_rdev *rdev_p, struct t3_wq *wq,
 		    struct cxio_ucontext *uctx)
 {
-	dma_free_coherent(&(rdev_p->rnic_info.pdev->dev),
-			  (1UL << (wq->size_log2))
-			  * sizeof(union t3_wr), wq->queue,
+	int size = PAGE_ALIGN((1UL << (wq->size_log2)) * sizeof(union t3_wr));
+
+	unreserve_pages(wq->queue, size);
+	dma_free_coherent(&(rdev_p->rnic_info.pdev->dev), size, wq->queue,
 			  pci_unmap_addr(wq, mapping));
 	kfree(wq->sq);
 	cxio_hal_rqtpool_free(rdev_p, wq->rq_addr, (1UL << wq->rq_size_log2));
