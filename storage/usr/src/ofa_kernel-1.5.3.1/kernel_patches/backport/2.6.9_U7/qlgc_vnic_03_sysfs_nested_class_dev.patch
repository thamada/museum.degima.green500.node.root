---
 drivers/infiniband/ulp/qlgc_vnic/vnic_main.c    |    3 
 drivers/infiniband/ulp/qlgc_vnic/vnic_netpath.c |    3 
 drivers/infiniband/ulp/qlgc_vnic/vnic_stats.h   |   10 +
 drivers/infiniband/ulp/qlgc_vnic/vnic_sys.c     |  138 ++++++++++++++++++++++--
 drivers/infiniband/ulp/qlgc_vnic/vnic_sys.h     |   10 +
 5 files changed, 151 insertions(+), 13 deletions(-)

Index: ofed_kernel/drivers/infiniband/ulp/qlgc_vnic/vnic_main.c
===================================================================
--- ofed_kernel.orig/drivers/infiniband/ulp/qlgc_vnic/vnic_main.c
+++ ofed_kernel/drivers/infiniband/ulp/qlgc_vnic/vnic_main.c
@@ -773,7 +773,8 @@ static void vnic_handle_free_vnic_evt(st
  	sysfs_remove_group(&vnic->class_dev_info.class_dev.kobj,
   			   &vnic_dev_attr_group);
   	vnic_cleanup_stats_files(vnic);
-  	class_device_unregister(&vnic->class_dev_info.class_dev);
+  	vnic_nested_class_device_unregister(&vnic->class_dev_info.class_dev,
+					    &interface_cdev.class_dev);
   	wait_for_completion(&vnic->class_dev_info.released);
 	free_netdev(vnic->netdevice);
 }
Index: ofed_kernel/drivers/infiniband/ulp/qlgc_vnic/vnic_netpath.c
===================================================================
--- ofed_kernel.orig/drivers/infiniband/ulp/qlgc_vnic/vnic_netpath.c
+++ ofed_kernel/drivers/infiniband/ulp/qlgc_vnic/vnic_netpath.c
@@ -84,7 +84,8 @@ void netpath_free(struct netpath *netpat
 	netpath->viport = NULL;
 	sysfs_remove_group(&netpath->class_dev_info.class_dev.kobj,
 			   &vnic_path_attr_group);
-	class_device_unregister(&netpath->class_dev_info.class_dev);
+	vnic_nested_class_device_unregister(&netpath->class_dev_info.class_dev,
+				    &netpath->parent->class_dev_info.class_dev);
 	wait_for_completion(&netpath->class_dev_info.released);
 }
 
Index: ofed_kernel/drivers/infiniband/ulp/qlgc_vnic/vnic_stats.h
===================================================================
--- ofed_kernel.orig/drivers/infiniband/ulp/qlgc_vnic/vnic_stats.h
+++ ofed_kernel/drivers/infiniband/ulp/qlgc_vnic/vnic_stats.h
@@ -113,11 +113,11 @@ static inline int vnic_setup_stats_files
 {
 	init_completion(&vnic->stat_info.released);
 	vnic->stat_info.class_dev.class = &vnic_class;
-	vnic->stat_info.class_dev.parent = &vnic->class_dev_info.class_dev;
 	snprintf(vnic->stat_info.class_dev.class_id, BUS_ID_SIZE,
 		 "stats");
 
-	if (class_device_register(&vnic->stat_info.class_dev)) {
+	if (vnic_nested_class_device_register(&vnic->stat_info.class_dev,
+				      &vnic->class_dev_info.class_dev)) {
 		SYS_ERROR("create_vnic: error in registering"
 			  " stat class dev\n");
 		goto stats_out;
@@ -129,7 +129,8 @@ static inline int vnic_setup_stats_files
 
 	return 0;
 err_stats_file:
-	class_device_unregister(&vnic->stat_info.class_dev);
+	vnic_nested_class_device_unregister(&vnic->stat_info.class_dev,
+					    &vnic->class_dev_info.class_dev);
 	wait_for_completion(&vnic->stat_info.released);
 stats_out:
 	return -1;
@@ -139,7 +140,8 @@ static inline void vnic_cleanup_stats_fi
 {
 	sysfs_remove_group(&vnic->class_dev_info.class_dev.kobj,
 			   &vnic_stats_attr_group);
-	class_device_unregister(&vnic->stat_info.class_dev);
+	vnic_nested_class_device_unregister(&vnic->stat_info.class_dev,
+					    &vnic->class_dev_info.class_dev);
 	wait_for_completion(&vnic->stat_info.released);
 }
 
Index: ofed_kernel/drivers/infiniband/ulp/qlgc_vnic/vnic_sys.c
===================================================================
--- ofed_kernel.orig/drivers/infiniband/ulp/qlgc_vnic/vnic_sys.c
+++ ofed_kernel/drivers/infiniband/ulp/qlgc_vnic/vnic_sys.c
@@ -515,11 +515,11 @@ static struct vnic *create_vnic(struct p
 	init_completion(&vnic->class_dev_info.released);
 
 	vnic->class_dev_info.class_dev.class = &vnic_class;
-	vnic->class_dev_info.class_dev.parent = &interface_cdev.class_dev;
 	snprintf(vnic->class_dev_info.class_dev.class_id, BUS_ID_SIZE,
 		 vnic_config->name);
 
-	if (class_device_register(&vnic->class_dev_info.class_dev)) {
+	if (vnic_nested_class_device_register(&vnic->class_dev_info.class_dev,
+					      &interface_cdev.class_dev)) {
 		SYS_ERROR("create_vnic: error in registering"
 			  " vnic class dev\n");
 		goto free_vnic;
@@ -541,7 +541,8 @@ err_stats:
 	sysfs_remove_group(&vnic->class_dev_info.class_dev.kobj,
 			   &vnic_dev_attr_group);
 err_attr:
-	class_device_unregister(&vnic->class_dev_info.class_dev);
+	vnic_nested_class_device_unregister(&vnic->class_dev_info.class_dev,
+					    &interface_cdev.class_dev);
 	wait_for_completion(&vnic->class_dev_info.released);
 free_vnic:
 	list_del(&vnic->list_ptrs);
@@ -900,12 +901,11 @@ static int setup_path_class_files(struct
 	init_completion(&path->class_dev_info.released);
 
 	path->class_dev_info.class_dev.class = &vnic_class;
-	path->class_dev_info.class_dev.parent =
-	    &path->parent->class_dev_info.class_dev;
 	snprintf(path->class_dev_info.class_dev.class_id,
 		 BUS_ID_SIZE, name);
 
-	if (class_device_register(&path->class_dev_info.class_dev)) {
+	if (vnic_nested_class_device_register(&path->class_dev_info.class_dev,
+				&path->parent->class_dev_info.class_dev)) {
 		SYS_ERROR("error in registering path class dev\n");
 		goto out;
 	}
@@ -919,7 +919,8 @@ static int setup_path_class_files(struct
 	return 0;
 
 err_path:
-	class_device_unregister(&path->class_dev_info.class_dev);
+	vnic_nested_class_device_unregister(&path->class_dev_info.class_dev,
+				     &path->parent->class_dev_info.class_dev);
 	wait_for_completion(&path->class_dev_info.released);
 out:
 	return -1;
@@ -1192,3 +1193,126 @@ out:
 }
 
 CLASS_DEVICE_ATTR(create_secondary, S_IWUSR, NULL, vnic_create_secondary);
+
+/*
+ * The ability to nest class_device structures was added in 2.6.14.
+ * Following functions are for providing similar functionality
+ * for older kernels
+ */
+
+static int class_device_dev_link(struct class_device * class_dev)
+{
+	if (class_dev->dev)
+		return sysfs_create_link(&class_dev->kobj,
+					 &class_dev->dev->kobj, "device");
+	return 0;
+}
+
+static int class_device_driver_link(struct class_device * class_dev)
+{
+	if ((class_dev->dev) && (class_dev->dev->driver))
+		return sysfs_create_link(&class_dev->kobj,
+				 &class_dev->dev->driver->kobj, "driver");
+	return 0;
+}
+
+static int class_device_add_attrs(struct class_device * cd)
+{
+	int i;
+	int error = 0;
+	struct class * cls = cd->class;
+
+	if (cls->class_dev_attrs) {
+		for (i = 0; attr_name(cls->class_dev_attrs[i]); i++) {
+			error = class_device_create_file(cd,
+						 &cls->class_dev_attrs[i]);
+			if (error)
+				goto Err;
+		}
+	}
+ Done:
+	return error;
+ Err:
+	while (--i >= 0)
+		class_device_remove_file(cd,&cls->class_dev_attrs[i]);
+	goto Done;
+}
+
+static int vnic_nested_class_device_add(struct class_device *class_dev,
+					struct class_device *parent_dev)
+{
+	struct class * parent = NULL;
+	struct class_interface * class_intf;
+	int error;
+
+	class_dev = class_device_get(class_dev);
+	if (!class_dev)
+		return -EINVAL;
+
+	if (!strlen(class_dev->class_id)) {
+		error = -EINVAL;
+		goto register_done;
+	}
+
+	parent = class_get(class_dev->class);
+
+	pr_debug("CLASS: registering class device: ID = '%s'\n",
+		 class_dev->class_id);
+
+	/* first, register with generic layer. */
+	kobject_set_name(&class_dev->kobj, class_dev->class_id);
+
+	class_dev->kobj.parent = &parent_dev->kobj;
+
+	if ((error = kobject_add(&class_dev->kobj)))
+		goto register_done;
+
+	/* now take care of our own registration */
+	if (parent) {
+		down_write(&parent->subsys.rwsem);
+		list_add_tail(&class_dev->node, &parent->children);
+		list_for_each_entry(class_intf, &parent->interfaces, node)
+			if (class_intf->add)
+				class_intf->add(class_dev);
+		up_write(&parent->subsys.rwsem);
+	}
+	class_device_add_attrs(class_dev);
+	class_device_dev_link(class_dev);
+	class_device_driver_link(class_dev);
+
+ register_done:
+	if (error && parent)
+		class_put(parent);
+	class_device_put(class_dev);
+	return error;
+}
+
+/*
+ * vnic_nested_class_device_register()
+ * Similar to class_device_register() but sets the parent
+ * of the class_device to the specified class_device.
+ *
+ */
+int vnic_nested_class_device_register(struct class_device *class_dev,
+				      struct class_device *parent_dev)
+{
+	int ret;
+	parent_dev = class_device_get(parent_dev);
+
+	if (!parent_dev)
+		return -EINVAL;
+
+	class_device_initialize(class_dev);
+
+	if((ret = vnic_nested_class_device_add(class_dev, parent_dev)))
+		class_device_put(parent_dev);
+
+	return ret;
+}
+
+void vnic_nested_class_device_unregister(struct class_device *class_dev,
+					 struct class_device *parent_dev)
+{
+	class_device_unregister(class_dev);
+	class_device_put(parent_dev);
+}
Index: ofed_kernel/drivers/infiniband/ulp/qlgc_vnic/vnic_sys.h
===================================================================
--- ofed_kernel.orig/drivers/infiniband/ulp/qlgc_vnic/vnic_sys.h
+++ ofed_kernel/drivers/infiniband/ulp/qlgc_vnic/vnic_sys.h
@@ -38,6 +38,16 @@ struct class_dev_info {
 	struct completion	released;
 };
 
+/*
+ * vnic_nested_class_device_register()
+ * Similar to class_device_register() but sets the parent
+ * of the class_device to the specified class_device.
+ *
+ */
+int vnic_nested_class_device_register(struct class_device *class_dev,
+				      struct class_device *parent_dev);
+void vnic_nested_class_device_unregister(struct class_device *class_dev,
+					 struct class_device *parent_dev);
 extern struct class vnic_class;
 extern struct class_dev_info interface_cdev;
 extern struct attribute_group vnic_dev_attr_group;
