From e78b3ad108429bc706c913b5753a70bb44381565 Mon Sep 17 00:00:00 2001
From: Yevgeny Petrilin <yevgenyp@mellanox.co.il>
Date: Wed, 3 Mar 2010 11:26:51 +0200
Subject: [PATCH] mlx4_en: not running QUERY PORT from ethtool context

Signed-off-by: Yevgeny Petrilin <yevgenyp@mellanox.co.il>
---
 drivers/net/mlx4/en_ethtool.c  |    6 ++----
 drivers/net/mlx4/en_netdev.c   |    7 +++++++
 drivers/net/mlx4/en_port.c     |    4 ++--
 drivers/net/mlx4/en_selftest.c |   20 +++++++++++++-------
 drivers/net/mlx4/mlx4_en.h     |    3 +++
 5 files changed, 27 insertions(+), 13 deletions(-)

diff --git a/drivers/net/mlx4/en_ethtool.c b/drivers/net/mlx4/en_ethtool.c
index 69188c6..7b81ea1 100644
--- a/drivers/net/mlx4/en_ethtool.c
+++ b/drivers/net/mlx4/en_ethtool.c
@@ -281,9 +281,7 @@ static int mlx4_en_get_settings(struct net_device *dev, struct ethtool_cmd *cmd)
 	cmd->supported = SUPPORTED_10000baseT_Full;
 	cmd->advertising = ADVERTISED_10000baseT_Full;
 
-	if (mlx4_en_QUERY_PORT(priv->mdev, priv->port))
-		return -ENOMEM;
-
+	spin_lock(&priv->port_lock);
 	trans_type = priv->port_state.transciver;
 	if (netif_carrier_ok(dev)) {
 		cmd->speed = priv->port_state.link_speed;
@@ -292,7 +290,7 @@ static int mlx4_en_get_settings(struct net_device *dev, struct ethtool_cmd *cmd)
 		cmd->speed = -1;
 		cmd->duplex = -1;
 	}
-
+	spin_unlock(&priv->port_lock);
 	if (trans_type > 0 && trans_type <= 0xC) {
 		cmd->port = PORT_FIBRE;
 		cmd->transceiver = XCVR_EXTERNAL;
diff --git a/drivers/net/mlx4/en_netdev.c b/drivers/net/mlx4/en_netdev.c
index 4bb21c0..5b306b0 100644
--- a/drivers/net/mlx4/en_netdev.c
+++ b/drivers/net/mlx4/en_netdev.c
@@ -539,6 +539,12 @@ static void mlx4_en_do_get_stats(struct work_struct *work)
 	if (err)
 		en_dbg(HW, priv, "Could not update stats \n");
 
+	if (++priv->query_freq == QUERY_FREQ) {
+		if (mlx4_en_QUERY_PORT(mdev, priv->port))
+			en_dbg(HW, priv, "Could not query port state\n");
+		priv->query_freq = 0;
+	}
+
 	mutex_lock(&mdev->state_lock);
 	if (mdev->device_up) {
 		if (priv->port_up)
@@ -1022,6 +1028,7 @@ int mlx4_en_init_netdev(struct mlx4_en_dev *mdev, int port,
 	priv->msg_enable = MLX4_EN_MSG_LEVEL;
 	spin_lock_init(&priv->stats_lock);
	spin_lock_init(&priv->vlan_lock);
+	spin_lock_init(&priv->port_lock);
 	INIT_WORK(&priv->mcast_task, mlx4_en_do_set_multicast);
 	INIT_WORK(&priv->mac_task, mlx4_en_do_set_mac);
 	INIT_WORK(&priv->watchdog_task, mlx4_en_restart);
diff --git a/drivers/net/mlx4/en_port.c b/drivers/net/mlx4/en_port.c
index 7f5a322..2fbc52f 100644
--- a/drivers/net/mlx4/en_port.c
+++ b/drivers/net/mlx4/en_port.c
@@ -160,8 +160,7 @@ int mlx4_en_QUERY_PORT(struct mlx4_en_dev *mdev, u8 port)
 		goto out;
 	qport_context = mailbox->buf;
 
-	/* This command is always accessed from Ethtool context
-	 * already synchronized, no need in locking */
+	spin_lock(&priv->port_lock);
 	state->link_state = !!(qport_context->link_up & MLX4_EN_LINK_UP_MASK);
 	if ((qport_context->link_speed & MLX4_EN_SPEED_MASK) ==
 	    MLX4_EN_1G_SPEED)
@@ -169,6 +168,7 @@ int mlx4_en_QUERY_PORT(struct mlx4_en_dev *mdev, u8 port)
 	state->transciver = qport_context->transceiver;
 	if (be32_to_cpu(qport_context->transceiver_code_hi) & 0x400)
 		state->transciver = 0x80;
+	spin_unlock(&priv->port_lock);
 
 out:
 	mlx4_free_cmd_mailbox(mdev->dev, mailbox);
diff --git a/drivers/net/mlx4/en_selftest.c b/drivers/net/mlx4/en_selftest.c
index 43357d3..19eab82 100644
--- a/drivers/net/mlx4/en_selftest.c
+++ b/drivers/net/mlx4/en_selftest.c
@@ -113,23 +113,29 @@ mlx4_en_test_loopback_exit:
 
 static int mlx4_en_test_link(struct mlx4_en_priv *priv)
 {
+	int ret;
+
 	if (mlx4_en_QUERY_PORT(priv->mdev, priv->port))
 		return -ENOMEM;
-	if (priv->port_state.link_state == 1)
-		return 0;
-	else
-		return 1;
+	spin_lock(&priv->port_lock);
+	ret = !priv->port_state.link_state;
+	spin_unlock(&priv->port_lock);
+	return ret;
 }
 
 static int mlx4_en_test_speed(struct mlx4_en_priv *priv)
 {
+	int speed;
 
 	if (mlx4_en_QUERY_PORT(priv->mdev, priv->port))
 		return -ENOMEM;
 
-	/* The device currently only supports 10G speed */
-	if (priv->port_state.link_speed != SPEED_10000)
-		return priv->port_state.link_speed;
+	spin_lock(&priv->port_lock);
+	speed = priv->port_state.link_speed;
+	spin_unlock(&priv->port_lock);
+	/* The device currently only supports 10G or 1G speed */
+	if (speed != SPEED_10000 && speed != SPEED_1000)
+		return speed;
 	return 0;
 }
 
diff --git a/drivers/net/mlx4/mlx4_en.h b/drivers/net/mlx4/mlx4_en.h
index 9c616d6..7a2c1e6 100644
--- a/drivers/net/mlx4/mlx4_en.h
+++ b/drivers/net/mlx4/mlx4_en.h
@@ -102,6 +102,7 @@
 #define STAMP_SHIFT		31
 #define STAMP_VAL		0x7fffffff
 #define STATS_DELAY		(HZ / 4)
+#define QUERY_FREQ		(HZ / STATS_DELAY)
 
 /* Typical TSO descriptor with 16 gather entries is 352 bytes... */
 #define MAX_DESC_SIZE		512
@@ -490,6 +491,7 @@ struct mlx4_en_priv {
 	struct net_device_stats ret_stats;
 	struct mlx4_en_port_state port_state;
 	spinlock_t stats_lock;
+	spinlock_t port_lock;
 
 	unsigned long last_moder_packets;
 	unsigned long last_moder_tx_packets;
@@ -535,6 +537,7 @@ struct mlx4_en_priv {
 	struct mlx4_en_frag_info frag_info[MLX4_EN_MAX_RX_FRAGS];
 	u16 num_frags;
 	u16 log_rx_info;
+	u8  query_freq;
 
 	struct mlx4_en_tx_ring tx_ring[MAX_TX_RINGS];
 	struct mlx4_en_rx_ring rx_ring[MAX_RX_RINGS];
-- 
1.5.3.7

