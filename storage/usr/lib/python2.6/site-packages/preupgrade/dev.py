# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Library General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
# (c) 2007, 2008 Red Hat.
# Written by skvidal@fedoraproject.org, wwoods@redhat.com

import os
from preupgrade.error import PUError

def st_dev_to_devicename(st_dev):
    '''Try to convert st_dev to a devicename by reading /proc/partitions.
    Obviously this will only work when st_dev represents a partition.'''
    (major, minor) = (os.major(st_dev), os.minor(st_dev))
    proc_partitions = open('/proc/partitions')
    dummy = proc_partitions.readline() # skip the header line
    majmin = [str(major), str(minor)]
    for line in proc_partitions:
        l = line.split()
        if len(l) == 4 and l[0:2] == majmin:
            return l[3]
    return None

def devicename_to_st_dev(device):
    '''Try to convert a devicename to an st_dev by using os.stat.'''
    s = os.stat(device)
    if hasattr(s,"st_rdev"):
        return s.st_rdev

def device_to_uuid(device):
    '''Try to convert a devicename to a filesystem UUID.'''
    if not device.startswith('/dev/'):
        device = '/dev/' + device
    if not os.path.exists(device):
        return None
    # FIXME: handle exceptions/bad return values here
    p = os.popen('/sbin/blkid -s UUID -o value ' + device)
    line = p.readline()
    p.close()
    line = line.strip()
    if line:
        return line
    else:
        # canonicalize the devicename and try again
        st_dev = devicename_to_st_dev(device)
        device = st_dev_to_devicename(st_dev)
        return device_to_uuid(device)

def is_mdraid(devname):
    '''Return True if devname is an active mdraid device'''
    return os.path.exists("/sys/block/%s/md/level" % devname)

def is_dmraid(devname):
    '''Return True if devname is a dmraid device'''
    return os.path.exists("/sys/block/%s/dm/uuid" % devname)

def bootpath_to_anacondapath(somepath, UUID=False):
    '''Convert a path under /boot to a path that anaconda will understand.
    Returns a string anaconda's loader can use to find that path, e.g.:
    '/boot/upgrade/stage2.img' -> 'hd:sda1:/upgrade/stage2.img'

    If UUID is set to True, the returned string will use UUID= to specify
    the target device, e.g.: 'hd:UUID=[uuid]:/upgrade/stage2.img'
    This is much more reliable, but only supported in Anaconda 11.5.1.15
    (Fedora 10 Alpha) or later.

    Raises PUError if something goes wrong.'''
    st_dev = os.stat(somepath).st_dev
    bootdev = st_dev_to_devicename(st_dev)
    mtab = open("/etc/mtab")
    mountpoint = ''
    for line in mtab:
        (dev, mp, rest) = line.split(' ', 2)
        if os.path.exists(dev):
            if devicename_to_st_dev(dev) == st_dev:
                mountpoint = mp
                break
    if not mountpoint:
        raise PUError, "Could not find mount point for boot device %s" % bootdev

    if is_mdraid(bootdev) or is_dmraid(bootdev):
        raise PUError, "/boot is on RAID device %s" % bootdev

    if mountpoint != '/':
        somepath = somepath.replace(mountpoint, '', 1)

    if bootdev and somepath:
        if UUID:
            bootdev = 'UUID=%s' % device_to_uuid(bootdev)
        return 'hd:%s:%s' % (bootdev, somepath)
    else:
        return None
