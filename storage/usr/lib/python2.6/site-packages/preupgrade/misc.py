# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Library General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
# (c) 2007, 2008 Red Hat.
# Written by skvidal@fedoraproject.org, wwoods@redhat.com

import os
import sys
import shlex

def isParaVirt():
    """
    This function determines if the running system is a paravirt guest.
    This code is borrowed heavily from rhnreg.py (packaged with rhn-setup).
       2.  Check /sys/hypervisor/uuid.  If exists and is non-zero, we know
           the system is a para-virt guest; exit.
    """

    isGuest = False
    if os.path.exists("/proc/xen/xsd_port"):
        return False
    if os.path.exists("/sys/hypervisor/uuid"):
        try:
            uuid_file = open('/sys/hypervisor/uuid', 'r')
            uuid = uuid_file.read()
            uuid_file.close()
            if len(uuid.strip("0-\n")) != 0:
                isGuest = True
        except IOError:
            # Failed; must not be para-virt.
            pass

    return isGuest

def getlang():
    lang = 'en_US' # fallback
    infile = '/etc/sysconfig/i18n'
    s = shlex.shlex(open(infile), infile, posix=True)
    while True:
        t = s.get_token()
        if not t:
            break
        if t == 'LANG':
            eq = s.get_token() # =
            if eq == '=':
                lang = s.get_token()  # value
    return lang

def hrsize(size, precision=1):
    '''Return a string representing the "human-readable" size'''
    abbr = [(1<<40L,'TB'),
            (1<<30L,'GB'),
            (1<<20L,'MB'),
            (1<<10L,'kB'),
            (1,'bytes')]
    if size == 1:
        return "1 byte"
    factor, suffix = abbr[-1]
    for factor, suffix in abbr:
        if size > factor:
            break
    if precision == 0:
        return "%d%s" % (int(size)/factor, suffix)
    else:
        return ("%." + str(precision)+"f%s") % (float(size)/factor, suffix)

def get_sysconfig_keymap():
    '''Return the value of KEYTABLE in /etc/sysconfig/keyboard, or None
    if the file is missing or KEYTABLE is not set'''
    layout = None
    infile = '/etc/sysconfig/keyboard'
    try:
        s = shlex.shlex(open(infile), infile, posix=True)
        while s:
            t = s.get_token()
            if not t:
                break
            if t == 'KEYTABLE':
                eq = s.get_token() # =
                if eq == '=':
                    layout = s.get_token()  # value
    except IOError:
        pass
    return layout

def getkeymap():
    '''Get the system keymap from /etc/sysconfig/keyboard'''
    # Most upgrades won't require typing, so it's OK to just fall back to 'us'
    return get_sysconfig_keymap() or 'us'

def grubby(kernel, initrd, title="upgrade fedora", args='',):
    '''Run /sbin/grubby to create an entry for the given kernel+initrd.
    Overwrites any existing entries for the given kernel path.'''
    cmd = '/sbin/grubby --title="%s" --remove-kernel="%s" --add-kernel="%s" --initrd="%s"' % (title, kernel, kernel, initrd)
    if args != '':
        cmd = cmd+' --args="%s"' % args
    #DEBUG FIXME
    print 'DEBUG %s' % cmd

    return os.system(cmd)

def grubby_make_next_boot_only():
    '''Tell grubby to make the newly-added boot entry the default for the
    next boot only.'''
    return os.system("/bin/echo 'savedefault --default=0 --once' | /sbin/grub >/dev/null")

def generate_repodata(dir, comps=None, callback=None):
    '''Run createrepo on the given directory.'''
    try:
        from createrepo import MDError
        generate_repodata = generate_repodata_f9
    except ImportError:
        sys.path.append('/usr/share/createrepo')
        from dumpMetadata import MDError
        generate_repodata = generate_repodata_f8

    try:
        generate_repodata(dir, comps, callback)
    except (MDError, IOError), e:
        # FIXME: Handle this a little more cleanly
        print e
        return False
    return True

def generate_repodata_f9(dir, comps=None, callback=None):
    '''Run createrepo (from Fedora 9 or later) on the given directory.'''
    from createrepo import MetaDataGenerator, MetaDataConfig
    conf = MetaDataConfig()
    conf.directory = dir
    conf.database = True
    if comps:
        conf.groupfile = comps
    mdgen = MetaDataGenerator(config_obj=conf, callback=callback)
    mdgen.doPkgMetadata()
    mdgen.doRepoMetadata()
    mdgen.doFinalMove()

def generate_repodata_f8(dir, comps=None, callback=None):
    '''Run createrepo (from Fedora 8) on the given directory.'''
    from genpkgmetadata import MetaDataGenerator, parseArgs
    args = ['--database']
    if comps:
        args.extend(['--groupfile', comps])
    args.append(dir)
    cmds, dirs = parseArgs(args)
    tempdir = os.path.join(cmds['outputdir'], cmds['tempdir'])
    finaldir = os.path.join(cmds['outputdir'], cmds['finaldir'])
    for d in (tempdir, finaldir):
        if os.path.isdir(d):
            shutil.rmtree(d)
        elif os.path.exists(d):
            os.unlink(d)
    os.mkdir(tempdir)
    mdgen = MetaDataGenerator(cmds)
    mdgen.doPkgMetadata(dirs[0])
    mdgen.doRepoMetadata()
    os.rename(tempdir, finaldir)
